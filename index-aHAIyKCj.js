(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); function Y0(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var Yh = { exports: {} }, Qa = {}, Qh = { exports: {} }, st = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var x1; function uE() { if (x1) return st; x1 = 1; var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), v = Symbol.iterator; function m(W) { return W === null || typeof W != "object" ? null : (W = v && W[v] || W["@@iterator"], typeof W == "function" ? W : null) } var g = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, S = Object.assign, b = {}; function P(W, re, Ae) { this.props = W, this.context = re, this.refs = b, this.updater = Ae || g } P.prototype.isReactComponent = {}, P.prototype.setState = function (W, re) { if (typeof W != "object" && typeof W != "function" && W != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, W, re, "setState") }, P.prototype.forceUpdate = function (W) { this.updater.enqueueForceUpdate(this, W, "forceUpdate") }; function C() { } C.prototype = P.prototype; function F(W, re, Ae) { this.props = W, this.context = re, this.refs = b, this.updater = Ae || g } var A = F.prototype = new C; A.constructor = F, S(A, P.prototype), A.isPureReactComponent = !0; var N = Array.isArray, D = Object.prototype.hasOwnProperty, V = { current: null }, B = { key: !0, ref: !0, __self: !0, __source: !0 }; function I(W, re, Ae) { var Fe, Be = {}, Ee = null, Ie = null; if (re != null) for (Fe in re.ref !== void 0 && (Ie = re.ref), re.key !== void 0 && (Ee = "" + re.key), re) D.call(re, Fe) && !B.hasOwnProperty(Fe) && (Be[Fe] = re[Fe]); var be = arguments.length - 2; if (be === 1) Be.children = Ae; else if (1 < be) { for (var Je = Array(be), pt = 0; pt < be; pt++)Je[pt] = arguments[pt + 2]; Be.children = Je } if (W && W.defaultProps) for (Fe in be = W.defaultProps, be) Be[Fe] === void 0 && (Be[Fe] = be[Fe]); return { $$typeof: t, type: W, key: Ee, ref: Ie, props: Be, _owner: V.current } } function Y(W, re) { return { $$typeof: t, type: W.type, key: re, ref: W.ref, props: W.props, _owner: W._owner } } function Z(W) { return typeof W == "object" && W !== null && W.$$typeof === t } function ie(W) { var re = { "=": "=0", ":": "=2" }; return "$" + W.replace(/[=:]/g, function (Ae) { return re[Ae] }) } var se = /\/+/g; function q(W, re) { return typeof W == "object" && W !== null && W.key != null ? ie("" + W.key) : re.toString(36) } function ue(W, re, Ae, Fe, Be) { var Ee = typeof W; (Ee === "undefined" || Ee === "boolean") && (W = null); var Ie = !1; if (W === null) Ie = !0; else switch (Ee) { case "string": case "number": Ie = !0; break; case "object": switch (W.$$typeof) { case t: case e: Ie = !0 } }if (Ie) return Ie = W, Be = Be(Ie), W = Fe === "" ? "." + q(Ie, 0) : Fe, N(Be) ? (Ae = "", W != null && (Ae = W.replace(se, "$&/") + "/"), ue(Be, re, Ae, "", function (pt) { return pt })) : Be != null && (Z(Be) && (Be = Y(Be, Ae + (!Be.key || Ie && Ie.key === Be.key ? "" : ("" + Be.key).replace(se, "$&/") + "/") + W)), re.push(Be)), 1; if (Ie = 0, Fe = Fe === "" ? "." : Fe + ":", N(W)) for (var be = 0; be < W.length; be++) { Ee = W[be]; var Je = Fe + q(Ee, be); Ie += ue(Ee, re, Ae, Je, Be) } else if (Je = m(W), typeof Je == "function") for (W = Je.call(W), be = 0; !(Ee = W.next()).done;)Ee = Ee.value, Je = Fe + q(Ee, be++), Ie += ue(Ee, re, Ae, Je, Be); else if (Ee === "object") throw re = String(W), Error("Objects are not valid as a React child (found: " + (re === "[object Object]" ? "object with keys {" + Object.keys(W).join(", ") + "}" : re) + "). If you meant to render a collection of children, use an array instead."); return Ie } function ye(W, re, Ae) { if (W == null) return W; var Fe = [], Be = 0; return ue(W, Fe, "", "", function (Ee) { return re.call(Ae, Ee, Be++) }), Fe } function ae(W) { if (W._status === -1) { var re = W._result; re = re(), re.then(function (Ae) { (W._status === 0 || W._status === -1) && (W._status = 1, W._result = Ae) }, function (Ae) { (W._status === 0 || W._status === -1) && (W._status = 2, W._result = Ae) }), W._status === -1 && (W._status = 0, W._result = re) } if (W._status === 1) return W._result.default; throw W._result } var _ = { current: null }, Q = { transition: null }, le = { ReactCurrentDispatcher: _, ReactCurrentBatchConfig: Q, ReactCurrentOwner: V }; function ce() { throw Error("act(...) is not supported in production builds of React.") } return st.Children = { map: ye, forEach: function (W, re, Ae) { ye(W, function () { re.apply(this, arguments) }, Ae) }, count: function (W) { var re = 0; return ye(W, function () { re++ }), re }, toArray: function (W) { return ye(W, function (re) { return re }) || [] }, only: function (W) { if (!Z(W)) throw Error("React.Children.only expected to receive a single React element child."); return W } }, st.Component = P, st.Fragment = n, st.Profiler = i, st.PureComponent = F, st.StrictMode = r, st.Suspense = c, st.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = le, st.act = ce, st.cloneElement = function (W, re, Ae) { if (W == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + W + "."); var Fe = S({}, W.props), Be = W.key, Ee = W.ref, Ie = W._owner; if (re != null) { if (re.ref !== void 0 && (Ee = re.ref, Ie = V.current), re.key !== void 0 && (Be = "" + re.key), W.type && W.type.defaultProps) var be = W.type.defaultProps; for (Je in re) D.call(re, Je) && !B.hasOwnProperty(Je) && (Fe[Je] = re[Je] === void 0 && be !== void 0 ? be[Je] : re[Je]) } var Je = arguments.length - 2; if (Je === 1) Fe.children = Ae; else if (1 < Je) { be = Array(Je); for (var pt = 0; pt < Je; pt++)be[pt] = arguments[pt + 2]; Fe.children = be } return { $$typeof: t, type: W.type, key: Be, ref: Ee, props: Fe, _owner: Ie } }, st.createContext = function (W) { return W = { $$typeof: a, _currentValue: W, _currentValue2: W, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, W.Provider = { $$typeof: s, _context: W }, W.Consumer = W }, st.createElement = I, st.createFactory = function (W) { var re = I.bind(null, W); return re.type = W, re }, st.createRef = function () { return { current: null } }, st.forwardRef = function (W) { return { $$typeof: u, render: W } }, st.isValidElement = Z, st.lazy = function (W) { return { $$typeof: h, _payload: { _status: -1, _result: W }, _init: ae } }, st.memo = function (W, re) { return { $$typeof: f, type: W, compare: re === void 0 ? null : re } }, st.startTransition = function (W) { var re = Q.transition; Q.transition = {}; try { W() } finally { Q.transition = re } }, st.unstable_act = ce, st.useCallback = function (W, re) { return _.current.useCallback(W, re) }, st.useContext = function (W) { return _.current.useContext(W) }, st.useDebugValue = function () { }, st.useDeferredValue = function (W) { return _.current.useDeferredValue(W) }, st.useEffect = function (W, re) { return _.current.useEffect(W, re) }, st.useId = function () { return _.current.useId() }, st.useImperativeHandle = function (W, re, Ae) { return _.current.useImperativeHandle(W, re, Ae) }, st.useInsertionEffect = function (W, re) { return _.current.useInsertionEffect(W, re) }, st.useLayoutEffect = function (W, re) { return _.current.useLayoutEffect(W, re) }, st.useMemo = function (W, re) { return _.current.useMemo(W, re) }, st.useReducer = function (W, re, Ae) { return _.current.useReducer(W, re, Ae) }, st.useRef = function (W) { return _.current.useRef(W) }, st.useState = function (W) { return _.current.useState(W) }, st.useSyncExternalStore = function (W, re, Ae) { return _.current.useSyncExternalStore(W, re, Ae) }, st.useTransition = function () { return _.current.useTransition() }, st.version = "18.3.1", st } var w1; function Q0() { return w1 || (w1 = 1, Qh.exports = uE()), Qh.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var S1; function cE() { if (S1) return Qa; S1 = 1; var t = Q0(), e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 }; function a(u, c, f) { var h, v = {}, m = null, g = null; f !== void 0 && (m = "" + f), c.key !== void 0 && (m = "" + c.key), c.ref !== void 0 && (g = c.ref); for (h in c) r.call(c, h) && !s.hasOwnProperty(h) && (v[h] = c[h]); if (u && u.defaultProps) for (h in c = u.defaultProps, c) v[h] === void 0 && (v[h] = c[h]); return { $$typeof: e, type: u, key: m, ref: g, props: v, _owner: i.current } } return Qa.Fragment = n, Qa.jsx = a, Qa.jsxs = a, Qa } var b1; function fE() { return b1 || (b1 = 1, Yh.exports = cE()), Yh.exports } var De = fE(), j = Q0(); const Jh = Y0(j); var wc = {}, _h = { exports: {} }, Gn = {}, $h = { exports: {} }, ep = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var C1; function dE() { return C1 || (C1 = 1, function (t) { function e(Q, le) { var ce = Q.length; Q.push(le); e: for (; 0 < ce;) { var W = ce - 1 >>> 1, re = Q[W]; if (0 < i(re, le)) Q[W] = le, Q[ce] = re, ce = W; else break e } } function n(Q) { return Q.length === 0 ? null : Q[0] } function r(Q) { if (Q.length === 0) return null; var le = Q[0], ce = Q.pop(); if (ce !== le) { Q[0] = ce; e: for (var W = 0, re = Q.length, Ae = re >>> 1; W < Ae;) { var Fe = 2 * (W + 1) - 1, Be = Q[Fe], Ee = Fe + 1, Ie = Q[Ee]; if (0 > i(Be, ce)) Ee < re && 0 > i(Ie, Be) ? (Q[W] = Ie, Q[Ee] = ce, W = Ee) : (Q[W] = Be, Q[Fe] = ce, W = Fe); else if (Ee < re && 0 > i(Ie, ce)) Q[W] = Ie, Q[Ee] = ce, W = Ee; else break e } } return le } function i(Q, le) { var ce = Q.sortIndex - le.sortIndex; return ce !== 0 ? ce : Q.id - le.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; t.unstable_now = function () { return s.now() } } else { var a = Date, u = a.now(); t.unstable_now = function () { return a.now() - u } } var c = [], f = [], h = 1, v = null, m = 3, g = !1, S = !1, b = !1, P = typeof setTimeout == "function" ? setTimeout : null, C = typeof clearTimeout == "function" ? clearTimeout : null, F = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function A(Q) { for (var le = n(f); le !== null;) { if (le.callback === null) r(f); else if (le.startTime <= Q) r(f), le.sortIndex = le.expirationTime, e(c, le); else break; le = n(f) } } function N(Q) { if (b = !1, A(Q), !S) if (n(c) !== null) S = !0, ae(D); else { var le = n(f); le !== null && _(N, le.startTime - Q) } } function D(Q, le) { S = !1, b && (b = !1, C(I), I = -1), g = !0; var ce = m; try { for (A(le), v = n(c); v !== null && (!(v.expirationTime > le) || Q && !ie());) { var W = v.callback; if (typeof W == "function") { v.callback = null, m = v.priorityLevel; var re = W(v.expirationTime <= le); le = t.unstable_now(), typeof re == "function" ? v.callback = re : v === n(c) && r(c), A(le) } else r(c); v = n(c) } if (v !== null) var Ae = !0; else { var Fe = n(f); Fe !== null && _(N, Fe.startTime - le), Ae = !1 } return Ae } finally { v = null, m = ce, g = !1 } } var V = !1, B = null, I = -1, Y = 5, Z = -1; function ie() { return !(t.unstable_now() - Z < Y) } function se() { if (B !== null) { var Q = t.unstable_now(); Z = Q; var le = !0; try { le = B(!0, Q) } finally { le ? q() : (V = !1, B = null) } } else V = !1 } var q; if (typeof F == "function") q = function () { F(se) }; else if (typeof MessageChannel < "u") { var ue = new MessageChannel, ye = ue.port2; ue.port1.onmessage = se, q = function () { ye.postMessage(null) } } else q = function () { P(se, 0) }; function ae(Q) { B = Q, V || (V = !0, q()) } function _(Q, le) { I = P(function () { Q(t.unstable_now()) }, le) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (Q) { Q.callback = null }, t.unstable_continueExecution = function () { S || g || (S = !0, ae(D)) }, t.unstable_forceFrameRate = function (Q) { 0 > Q || 125 < Q ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Y = 0 < Q ? Math.floor(1e3 / Q) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return m }, t.unstable_getFirstCallbackNode = function () { return n(c) }, t.unstable_next = function (Q) { switch (m) { case 1: case 2: case 3: var le = 3; break; default: le = m }var ce = m; m = le; try { return Q() } finally { m = ce } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (Q, le) { switch (Q) { case 1: case 2: case 3: case 4: case 5: break; default: Q = 3 }var ce = m; m = Q; try { return le() } finally { m = ce } }, t.unstable_scheduleCallback = function (Q, le, ce) { var W = t.unstable_now(); switch (typeof ce == "object" && ce !== null ? (ce = ce.delay, ce = typeof ce == "number" && 0 < ce ? W + ce : W) : ce = W, Q) { case 1: var re = -1; break; case 2: re = 250; break; case 5: re = 1073741823; break; case 4: re = 1e4; break; default: re = 5e3 }return re = ce + re, Q = { id: h++, callback: le, priorityLevel: Q, startTime: ce, expirationTime: re, sortIndex: -1 }, ce > W ? (Q.sortIndex = ce, e(f, Q), n(c) === null && Q === n(f) && (b ? (C(I), I = -1) : b = !0, _(N, ce - W))) : (Q.sortIndex = re, e(c, Q), S || g || (S = !0, ae(D))), Q }, t.unstable_shouldYield = ie, t.unstable_wrapCallback = function (Q) { var le = m; return function () { var ce = m; m = le; try { return Q.apply(this, arguments) } finally { m = ce } } } }(ep)), ep } var P1; function hE() { return P1 || (P1 = 1, $h.exports = dE()), $h.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var T1; function pE() {
  if (T1) return Gn; T1 = 1; var t = Q0(), e = hE(); function n(o) { for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + o, d = 1; d < arguments.length; d++)l += "&args[]=" + encodeURIComponent(arguments[d]); return "Minified React error #" + o + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var r = new Set, i = {}; function s(o, l) { a(o, l), a(o + "Capture", l) } function a(o, l) { for (i[o] = l, o = 0; o < l.length; o++)r.add(l[o]) } var u = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), c = Object.prototype.hasOwnProperty, f = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, h = {}, v = {}; function m(o) { return c.call(v, o) ? !0 : c.call(h, o) ? !1 : f.test(o) ? v[o] = !0 : (h[o] = !0, !1) } function g(o, l, d, p) { if (d !== null && d.type === 0) return !1; switch (typeof l) { case "function": case "symbol": return !0; case "boolean": return p ? !1 : d !== null ? !d.acceptsBooleans : (o = o.toLowerCase().slice(0, 5), o !== "data-" && o !== "aria-"); default: return !1 } } function S(o, l, d, p) { if (l === null || typeof l > "u" || g(o, l, d, p)) return !0; if (p) return !1; if (d !== null) switch (d.type) { case 3: return !l; case 4: return l === !1; case 5: return isNaN(l); case 6: return isNaN(l) || 1 > l }return !1 } function b(o, l, d, p, y, w, T) { this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = p, this.attributeNamespace = y, this.mustUseProperty = d, this.propertyName = o, this.type = l, this.sanitizeURL = w, this.removeEmptyString = T } var P = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (o) { P[o] = new b(o, 0, !1, o, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (o) { var l = o[0]; P[l] = new b(l, 1, !1, o[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (o) { P[o] = new b(o, 2, !1, o.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (o) { P[o] = new b(o, 2, !1, o, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (o) { P[o] = new b(o, 3, !1, o.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (o) { P[o] = new b(o, 3, !0, o, null, !1, !1) }), ["capture", "download"].forEach(function (o) { P[o] = new b(o, 4, !1, o, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (o) { P[o] = new b(o, 6, !1, o, null, !1, !1) }), ["rowSpan", "start"].forEach(function (o) { P[o] = new b(o, 5, !1, o.toLowerCase(), null, !1, !1) }); var C = /[\-:]([a-z])/g; function F(o) { return o[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (o) { var l = o.replace(C, F); P[l] = new b(l, 1, !1, o, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (o) { var l = o.replace(C, F); P[l] = new b(l, 1, !1, o, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (o) { var l = o.replace(C, F); P[l] = new b(l, 1, !1, o, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (o) { P[o] = new b(o, 1, !1, o.toLowerCase(), null, !1, !1) }), P.xlinkHref = new b("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (o) { P[o] = new b(o, 1, !1, o.toLowerCase(), null, !0, !0) }); function A(o, l, d, p) { var y = P.hasOwnProperty(l) ? P[l] : null; (y !== null ? y.type !== 0 : p || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (S(l, d, y, p) && (d = null), p || y === null ? m(l) && (d === null ? o.removeAttribute(l) : o.setAttribute(l, "" + d)) : y.mustUseProperty ? o[y.propertyName] = d === null ? y.type === 3 ? !1 : "" : d : (l = y.attributeName, p = y.attributeNamespace, d === null ? o.removeAttribute(l) : (y = y.type, d = y === 3 || y === 4 && d === !0 ? "" : "" + d, p ? o.setAttributeNS(p, l, d) : o.setAttribute(l, d)))) } var N = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, D = Symbol.for("react.element"), V = Symbol.for("react.portal"), B = Symbol.for("react.fragment"), I = Symbol.for("react.strict_mode"), Y = Symbol.for("react.profiler"), Z = Symbol.for("react.provider"), ie = Symbol.for("react.context"), se = Symbol.for("react.forward_ref"), q = Symbol.for("react.suspense"), ue = Symbol.for("react.suspense_list"), ye = Symbol.for("react.memo"), ae = Symbol.for("react.lazy"), _ = Symbol.for("react.offscreen"), Q = Symbol.iterator; function le(o) { return o === null || typeof o != "object" ? null : (o = Q && o[Q] || o["@@iterator"], typeof o == "function" ? o : null) } var ce = Object.assign, W; function re(o) {
    if (W === void 0) try { throw Error() } catch (d) { var l = d.stack.trim().match(/\n( *(at )?)/); W = l && l[1] || "" } return `
`+ W + o
  } var Ae = !1; function Fe(o, l) {
    if (!o || Ae) return ""; Ae = !0; var d = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (l) if (l = function () { throw Error() }, Object.defineProperty(l.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(l, []) } catch (te) { var p = te } Reflect.construct(o, [], l) } else { try { l.call() } catch (te) { p = te } o.call(l.prototype) } else { try { throw Error() } catch (te) { p = te } o() } } catch (te) {
      if (te && p && typeof te.stack == "string") {
        for (var y = te.stack.split(`
`), w = p.stack.split(`
`), T = y.length - 1, L = w.length - 1; 1 <= T && 0 <= L && y[T] !== w[L];)L--; for (; 1 <= T && 0 <= L; T--, L--)if (y[T] !== w[L]) {
          if (T !== 1 || L !== 1) do if (T--, L--, 0 > L || y[T] !== w[L]) {
            var U = `
`+ y[T].replace(" at new ", " at "); return o.displayName && U.includes("<anonymous>") && (U = U.replace("<anonymous>", o.displayName)), U
          } while (1 <= T && 0 <= L); break
        }
      }
    } finally { Ae = !1, Error.prepareStackTrace = d } return (o = o ? o.displayName || o.name : "") ? re(o) : ""
  } function Be(o) { switch (o.tag) { case 5: return re(o.type); case 16: return re("Lazy"); case 13: return re("Suspense"); case 19: return re("SuspenseList"); case 0: case 2: case 15: return o = Fe(o.type, !1), o; case 11: return o = Fe(o.type.render, !1), o; case 1: return o = Fe(o.type, !0), o; default: return "" } } function Ee(o) { if (o == null) return null; if (typeof o == "function") return o.displayName || o.name || null; if (typeof o == "string") return o; switch (o) { case B: return "Fragment"; case V: return "Portal"; case Y: return "Profiler"; case I: return "StrictMode"; case q: return "Suspense"; case ue: return "SuspenseList" }if (typeof o == "object") switch (o.$$typeof) { case ie: return (o.displayName || "Context") + ".Consumer"; case Z: return (o._context.displayName || "Context") + ".Provider"; case se: var l = o.render; return o = o.displayName, o || (o = l.displayName || l.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o; case ye: return l = o.displayName || null, l !== null ? l : Ee(o.type) || "Memo"; case ae: l = o._payload, o = o._init; try { return Ee(o(l)) } catch { } }return null } function Ie(o) { var l = o.type; switch (o.tag) { case 24: return "Cache"; case 9: return (l.displayName || "Context") + ".Consumer"; case 10: return (l._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return o = l.render, o = o.displayName || o.name || "", l.displayName || (o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return l; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Ee(l); case 8: return l === I ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof l == "function") return l.displayName || l.name || null; if (typeof l == "string") return l }return null } function be(o) { switch (typeof o) { case "boolean": case "number": case "string": case "undefined": return o; case "object": return o; default: return "" } } function Je(o) { var l = o.type; return (o = o.nodeName) && o.toLowerCase() === "input" && (l === "checkbox" || l === "radio") } function pt(o) { var l = Je(o) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(o.constructor.prototype, l), p = "" + o[l]; if (!o.hasOwnProperty(l) && typeof d < "u" && typeof d.get == "function" && typeof d.set == "function") { var y = d.get, w = d.set; return Object.defineProperty(o, l, { configurable: !0, get: function () { return y.call(this) }, set: function (T) { p = "" + T, w.call(this, T) } }), Object.defineProperty(o, l, { enumerable: d.enumerable }), { getValue: function () { return p }, setValue: function (T) { p = "" + T }, stopTracking: function () { o._valueTracker = null, delete o[l] } } } } function Qt(o) { o._valueTracker || (o._valueTracker = pt(o)) } function ht(o) { if (!o) return !1; var l = o._valueTracker; if (!l) return !0; var d = l.getValue(), p = ""; return o && (p = Je(o) ? o.checked ? "true" : "false" : o.value), o = p, o !== d ? (l.setValue(o), !0) : !1 } function Et(o) { if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null; try { return o.activeElement || o.body } catch { return o.body } } function jn(o, l) { var d = l.checked; return ce({}, l, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: d ?? o._wrapperState.initialChecked }) } function vn(o, l) { var d = l.defaultValue == null ? "" : l.defaultValue, p = l.checked != null ? l.checked : l.defaultChecked; d = be(l.value != null ? l.value : d), o._wrapperState = { initialChecked: p, initialValue: d, controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null } } function un(o, l) { l = l.checked, l != null && A(o, "checked", l, !1) } function Ct(o, l) { un(o, l); var d = be(l.value), p = l.type; if (d != null) p === "number" ? (d === 0 && o.value === "" || o.value != d) && (o.value = "" + d) : o.value !== "" + d && (o.value = "" + d); else if (p === "submit" || p === "reset") { o.removeAttribute("value"); return } l.hasOwnProperty("value") ? Kt(o, l.type, d) : l.hasOwnProperty("defaultValue") && Kt(o, l.type, be(l.defaultValue)), l.checked == null && l.defaultChecked != null && (o.defaultChecked = !!l.defaultChecked) } function it(o, l, d) { if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) { var p = l.type; if (!(p !== "submit" && p !== "reset" || l.value !== void 0 && l.value !== null)) return; l = "" + o._wrapperState.initialValue, d || l === o.value || (o.value = l), o.defaultValue = l } d = o.name, d !== "" && (o.name = ""), o.defaultChecked = !!o._wrapperState.initialChecked, d !== "" && (o.name = d) } function Kt(o, l, d) { (l !== "number" || Et(o.ownerDocument) !== o) && (d == null ? o.defaultValue = "" + o._wrapperState.initialValue : o.defaultValue !== "" + d && (o.defaultValue = "" + d)) } var cr = Array.isArray; function Dn(o, l, d, p) { if (o = o.options, l) { l = {}; for (var y = 0; y < d.length; y++)l["$" + d[y]] = !0; for (d = 0; d < o.length; d++)y = l.hasOwnProperty("$" + o[d].value), o[d].selected !== y && (o[d].selected = y), y && p && (o[d].defaultSelected = !0) } else { for (d = "" + be(d), l = null, y = 0; y < o.length; y++) { if (o[y].value === d) { o[y].selected = !0, p && (o[y].defaultSelected = !0); return } l !== null || o[y].disabled || (l = o[y]) } l !== null && (l.selected = !0) } } function bn(o, l) { if (l.dangerouslySetInnerHTML != null) throw Error(n(91)); return ce({}, l, { value: void 0, defaultValue: void 0, children: "" + o._wrapperState.initialValue }) } function ci(o, l) { var d = l.value; if (d == null) { if (d = l.children, l = l.defaultValue, d != null) { if (l != null) throw Error(n(92)); if (cr(d)) { if (1 < d.length) throw Error(n(93)); d = d[0] } l = d } l == null && (l = ""), d = l } o._wrapperState = { initialValue: be(d) } } function Or(o, l) { var d = be(l.value), p = be(l.defaultValue); d != null && (d = "" + d, d !== o.value && (o.value = d), l.defaultValue == null && o.defaultValue !== d && (o.defaultValue = d)), p != null && (o.defaultValue = "" + p) } function In(o) { var l = o.textContent; l === o._wrapperState.initialValue && l !== "" && l !== null && (o.value = l) } function fi(o) { switch (o) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function fr(o, l) { return o == null || o === "http://www.w3.org/1999/xhtml" ? fi(l) : o === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : o } var Ht, Zn = function (o) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (l, d, p, y) { MSApp.execUnsafeLocalFunction(function () { return o(l, d, p, y) }) } : o }(function (o, l) { if (o.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in o) o.innerHTML = l; else { for (Ht = Ht || document.createElement("div"), Ht.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = Ht.firstChild; o.firstChild;)o.removeChild(o.firstChild); for (; l.firstChild;)o.appendChild(l.firstChild) } }); function dr(o, l) { if (l) { var d = o.firstChild; if (d && d === o.lastChild && d.nodeType === 3) { d.nodeValue = l; return } } o.textContent = l } var R = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, de = ["Webkit", "ms", "Moz", "O"]; Object.keys(R).forEach(function (o) { de.forEach(function (l) { l = l + o.charAt(0).toUpperCase() + o.substring(1), R[l] = R[o] }) }); function ge(o, l, d) { return l == null || typeof l == "boolean" || l === "" ? "" : d || typeof l != "number" || l === 0 || R.hasOwnProperty(o) && R[o] ? ("" + l).trim() : l + "px" } function ke(o, l) { o = o.style; for (var d in l) if (l.hasOwnProperty(d)) { var p = d.indexOf("--") === 0, y = ge(d, l[d], p); d === "float" && (d = "cssFloat"), p ? o.setProperty(d, y) : o[d] = y } } var H = ce({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function oe(o, l) { if (l) { if (H[o] && (l.children != null || l.dangerouslySetInnerHTML != null)) throw Error(n(137, o)); if (l.dangerouslySetInnerHTML != null) { if (l.children != null) throw Error(n(60)); if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML)) throw Error(n(61)) } if (l.style != null && typeof l.style != "object") throw Error(n(62)) } } function k(o, l) { if (o.indexOf("-") === -1) return typeof l.is == "string"; switch (o) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var fe = null; function ze(o) { return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o } var x = null, ee = null, ne = null; function E(o) { if (o = Na(o)) { if (typeof x != "function") throw Error(n(280)); var l = o.stateNode; l && (l = Nu(l), x(o.stateNode, o.type, l)) } } function z(o) { ee ? ne ? ne.push(o) : ne = [o] : ee = o } function $() { if (ee) { var o = ee, l = ne; if (ne = ee = null, E(o), l) for (o = 0; o < l.length; o++)E(l[o]) } } function Ve(o, l) { return o(l) } function Ce() { } var Pe = !1; function at(o, l, d) { if (Pe) return o(l, d); Pe = !0; try { return Ve(o, l, d) } finally { Pe = !1, (ee !== null || ne !== null) && (Ce(), $()) } } function On(o, l) { var d = o.stateNode; if (d === null) return null; var p = Nu(d); if (p === null) return null; d = p[l]; e: switch (l) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (p = !p.disabled) || (o = o.type, p = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !p; break e; default: o = !1 }if (o) return null; if (d && typeof d != "function") throw Error(n(231, l, typeof d)); return d } var kt = !1; if (u) try { var ot = {}; Object.defineProperty(ot, "passive", { get: function () { kt = !0 } }), window.addEventListener("test", ot, ot), window.removeEventListener("test", ot, ot) } catch { kt = !1 } function qt(o, l, d, p, y, w, T, L, U) { var te = Array.prototype.slice.call(arguments, 3); try { l.apply(d, te) } catch (ve) { this.onError(ve) } } var jt = !1, $t = null, di = !1, Bi = null, It = { onError: function (o) { jt = !0, $t = o } }; function zn(o, l, d, p, y, w, T, L, U) { jt = !1, $t = null, qt.apply(It, arguments) } function en(o, l, d, p, y, w, T, L, U) { if (zn.apply(this, arguments), jt) { if (jt) { var te = $t; jt = !1, $t = null } else throw Error(n(198)); di || (di = !0, Bi = te) } } function mn(o) { var l = o, d = o; if (o.alternate) for (; l.return;)l = l.return; else { o = l; do l = o, l.flags & 4098 && (d = l.return), o = l.return; while (o) } return l.tag === 3 ? d : null } function Yn(o) { if (o.tag === 13) { var l = o.memoizedState; if (l === null && (o = o.alternate, o !== null && (l = o.memoizedState)), l !== null) return l.dehydrated } return null } function ma(o) { if (mn(o) !== o) throw Error(n(188)) } function wk(o) { var l = o.alternate; if (!l) { if (l = mn(o), l === null) throw Error(n(188)); return l !== o ? null : o } for (var d = o, p = l; ;) { var y = d.return; if (y === null) break; var w = y.alternate; if (w === null) { if (p = y.return, p !== null) { d = p; continue } break } if (y.child === w.child) { for (w = y.child; w;) { if (w === d) return ma(y), o; if (w === p) return ma(y), l; w = w.sibling } throw Error(n(188)) } if (d.return !== p.return) d = y, p = w; else { for (var T = !1, L = y.child; L;) { if (L === d) { T = !0, d = y, p = w; break } if (L === p) { T = !0, p = y, d = w; break } L = L.sibling } if (!T) { for (L = w.child; L;) { if (L === d) { T = !0, d = w, p = y; break } if (L === p) { T = !0, p = w, d = y; break } L = L.sibling } if (!T) throw Error(n(189)) } } if (d.alternate !== p) throw Error(n(190)) } if (d.tag !== 3) throw Error(n(188)); return d.stateNode.current === d ? o : l } function Hm(o) { return o = wk(o), o !== null ? qm(o) : null } function qm(o) { if (o.tag === 5 || o.tag === 6) return o; for (o = o.child; o !== null;) { var l = qm(o); if (l !== null) return l; o = o.sibling } return null } var Gm = e.unstable_scheduleCallback, Xm = e.unstable_cancelCallback, Sk = e.unstable_shouldYield, bk = e.unstable_requestPaint, Gt = e.unstable_now, Ck = e.unstable_getCurrentPriorityLevel, vd = e.unstable_ImmediatePriority, Zm = e.unstable_UserBlockingPriority, vu = e.unstable_NormalPriority, Pk = e.unstable_LowPriority, Ym = e.unstable_IdlePriority, mu = null, Zr = null; function Tk(o) { if (Zr && typeof Zr.onCommitFiberRoot == "function") try { Zr.onCommitFiberRoot(mu, o, void 0, (o.current.flags & 128) === 128) } catch { } } var Mr = Math.clz32 ? Math.clz32 : Ek, kk = Math.log, Ak = Math.LN2; function Ek(o) { return o >>>= 0, o === 0 ? 32 : 31 - (kk(o) / Ak | 0) | 0 } var gu = 64, yu = 4194304; function ga(o) { switch (o & -o) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return o & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return o & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return o } } function xu(o, l) { var d = o.pendingLanes; if (d === 0) return 0; var p = 0, y = o.suspendedLanes, w = o.pingedLanes, T = d & 268435455; if (T !== 0) { var L = T & ~y; L !== 0 ? p = ga(L) : (w &= T, w !== 0 && (p = ga(w))) } else T = d & ~y, T !== 0 ? p = ga(T) : w !== 0 && (p = ga(w)); if (p === 0) return 0; if (l !== 0 && l !== p && !(l & y) && (y = p & -p, w = l & -l, y >= w || y === 16 && (w & 4194240) !== 0)) return l; if (p & 4 && (p |= d & 16), l = o.entangledLanes, l !== 0) for (o = o.entanglements, l &= p; 0 < l;)d = 31 - Mr(l), y = 1 << d, p |= o[d], l &= ~y; return p } function Fk(o, l) { switch (o) { case 1: case 2: case 4: return l + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return l + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Rk(o, l) { for (var d = o.suspendedLanes, p = o.pingedLanes, y = o.expirationTimes, w = o.pendingLanes; 0 < w;) { var T = 31 - Mr(w), L = 1 << T, U = y[T]; U === -1 ? (!(L & d) || L & p) && (y[T] = Fk(L, l)) : U <= l && (o.expiredLanes |= L), w &= ~L } } function md(o) { return o = o.pendingLanes & -1073741825, o !== 0 ? o : o & 1073741824 ? 1073741824 : 0 } function Qm() { var o = gu; return gu <<= 1, !(gu & 4194240) && (gu = 64), o } function gd(o) { for (var l = [], d = 0; 31 > d; d++)l.push(o); return l } function ya(o, l, d) { o.pendingLanes |= l, l !== 536870912 && (o.suspendedLanes = 0, o.pingedLanes = 0), o = o.eventTimes, l = 31 - Mr(l), o[l] = d } function Dk(o, l) { var d = o.pendingLanes & ~l; o.pendingLanes = l, o.suspendedLanes = 0, o.pingedLanes = 0, o.expiredLanes &= l, o.mutableReadLanes &= l, o.entangledLanes &= l, l = o.entanglements; var p = o.eventTimes; for (o = o.expirationTimes; 0 < d;) { var y = 31 - Mr(d), w = 1 << y; l[y] = 0, p[y] = -1, o[y] = -1, d &= ~w } } function yd(o, l) { var d = o.entangledLanes |= l; for (o = o.entanglements; d;) { var p = 31 - Mr(d), y = 1 << p; y & l | o[p] & l && (o[p] |= l), d &= ~y } } var Pt = 0; function Jm(o) { return o &= -o, 1 < o ? 4 < o ? o & 268435455 ? 16 : 536870912 : 4 : 1 } var _m, xd, $m, eg, tg, wd = !1, wu = [], Li = null, ji = null, Ii = null, xa = new Map, wa = new Map, zi = [], Ok = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function ng(o, l) { switch (o) { case "focusin": case "focusout": Li = null; break; case "dragenter": case "dragleave": ji = null; break; case "mouseover": case "mouseout": Ii = null; break; case "pointerover": case "pointerout": xa.delete(l.pointerId); break; case "gotpointercapture": case "lostpointercapture": wa.delete(l.pointerId) } } function Sa(o, l, d, p, y, w) { return o === null || o.nativeEvent !== w ? (o = { blockedOn: l, domEventName: d, eventSystemFlags: p, nativeEvent: w, targetContainers: [y] }, l !== null && (l = Na(l), l !== null && xd(l)), o) : (o.eventSystemFlags |= p, l = o.targetContainers, y !== null && l.indexOf(y) === -1 && l.push(y), o) } function Mk(o, l, d, p, y) { switch (l) { case "focusin": return Li = Sa(Li, o, l, d, p, y), !0; case "dragenter": return ji = Sa(ji, o, l, d, p, y), !0; case "mouseover": return Ii = Sa(Ii, o, l, d, p, y), !0; case "pointerover": var w = y.pointerId; return xa.set(w, Sa(xa.get(w) || null, o, l, d, p, y)), !0; case "gotpointercapture": return w = y.pointerId, wa.set(w, Sa(wa.get(w) || null, o, l, d, p, y)), !0 }return !1 } function rg(o) { var l = To(o.target); if (l !== null) { var d = mn(l); if (d !== null) { if (l = d.tag, l === 13) { if (l = Yn(d), l !== null) { o.blockedOn = l, tg(o.priority, function () { $m(d) }); return } } else if (l === 3 && d.stateNode.current.memoizedState.isDehydrated) { o.blockedOn = d.tag === 3 ? d.stateNode.containerInfo : null; return } } } o.blockedOn = null } function Su(o) { if (o.blockedOn !== null) return !1; for (var l = o.targetContainers; 0 < l.length;) { var d = bd(o.domEventName, o.eventSystemFlags, l[0], o.nativeEvent); if (d === null) { d = o.nativeEvent; var p = new d.constructor(d.type, d); fe = p, d.target.dispatchEvent(p), fe = null } else return l = Na(d), l !== null && xd(l), o.blockedOn = d, !1; l.shift() } return !0 } function ig(o, l, d) { Su(o) && d.delete(l) } function Vk() { wd = !1, Li !== null && Su(Li) && (Li = null), ji !== null && Su(ji) && (ji = null), Ii !== null && Su(Ii) && (Ii = null), xa.forEach(ig), wa.forEach(ig) } function ba(o, l) { o.blockedOn === l && (o.blockedOn = null, wd || (wd = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Vk))) } function Ca(o) { function l(y) { return ba(y, o) } if (0 < wu.length) { ba(wu[0], o); for (var d = 1; d < wu.length; d++) { var p = wu[d]; p.blockedOn === o && (p.blockedOn = null) } } for (Li !== null && ba(Li, o), ji !== null && ba(ji, o), Ii !== null && ba(Ii, o), xa.forEach(l), wa.forEach(l), d = 0; d < zi.length; d++)p = zi[d], p.blockedOn === o && (p.blockedOn = null); for (; 0 < zi.length && (d = zi[0], d.blockedOn === null);)rg(d), d.blockedOn === null && zi.shift() } var us = N.ReactCurrentBatchConfig, bu = !0; function Nk(o, l, d, p) { var y = Pt, w = us.transition; us.transition = null; try { Pt = 1, Sd(o, l, d, p) } finally { Pt = y, us.transition = w } } function Bk(o, l, d, p) { var y = Pt, w = us.transition; us.transition = null; try { Pt = 4, Sd(o, l, d, p) } finally { Pt = y, us.transition = w } } function Sd(o, l, d, p) { if (bu) { var y = bd(o, l, d, p); if (y === null) Id(o, l, p, Cu, d), ng(o, p); else if (Mk(y, o, l, d, p)) p.stopPropagation(); else if (ng(o, p), l & 4 && -1 < Ok.indexOf(o)) { for (; y !== null;) { var w = Na(y); if (w !== null && _m(w), w = bd(o, l, d, p), w === null && Id(o, l, p, Cu, d), w === y) break; y = w } y !== null && p.stopPropagation() } else Id(o, l, p, null, d) } } var Cu = null; function bd(o, l, d, p) { if (Cu = null, o = ze(p), o = To(o), o !== null) if (l = mn(o), l === null) o = null; else if (d = l.tag, d === 13) { if (o = Yn(l), o !== null) return o; o = null } else if (d === 3) { if (l.stateNode.current.memoizedState.isDehydrated) return l.tag === 3 ? l.stateNode.containerInfo : null; o = null } else l !== o && (o = null); return Cu = o, null } function og(o) { switch (o) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Ck()) { case vd: return 1; case Zm: return 4; case vu: case Pk: return 16; case Ym: return 536870912; default: return 16 }default: return 16 } } var Ui = null, Cd = null, Pu = null; function sg() { if (Pu) return Pu; var o, l = Cd, d = l.length, p, y = "value" in Ui ? Ui.value : Ui.textContent, w = y.length; for (o = 0; o < d && l[o] === y[o]; o++); var T = d - o; for (p = 1; p <= T && l[d - p] === y[w - p]; p++); return Pu = y.slice(o, 1 < p ? 1 - p : void 0) } function Tu(o) { var l = o.keyCode; return "charCode" in o ? (o = o.charCode, o === 0 && l === 13 && (o = 13)) : o = l, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0 } function ku() { return !0 } function ag() { return !1 } function Qn(o) { function l(d, p, y, w, T) { this._reactName = d, this._targetInst = y, this.type = p, this.nativeEvent = w, this.target = T, this.currentTarget = null; for (var L in o) o.hasOwnProperty(L) && (d = o[L], this[L] = d ? d(w) : w[L]); return this.isDefaultPrevented = (w.defaultPrevented != null ? w.defaultPrevented : w.returnValue === !1) ? ku : ag, this.isPropagationStopped = ag, this } return ce(l.prototype, { preventDefault: function () { this.defaultPrevented = !0; var d = this.nativeEvent; d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = ku) }, stopPropagation: function () { var d = this.nativeEvent; d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = ku) }, persist: function () { }, isPersistent: ku }), l } var cs = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (o) { return o.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Pd = Qn(cs), Pa = ce({}, cs, { view: 0, detail: 0 }), Lk = Qn(Pa), Td, kd, Ta, Au = ce({}, Pa, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ed, button: 0, buttons: 0, relatedTarget: function (o) { return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget }, movementX: function (o) { return "movementX" in o ? o.movementX : (o !== Ta && (Ta && o.type === "mousemove" ? (Td = o.screenX - Ta.screenX, kd = o.screenY - Ta.screenY) : kd = Td = 0, Ta = o), Td) }, movementY: function (o) { return "movementY" in o ? o.movementY : kd } }), lg = Qn(Au), jk = ce({}, Au, { dataTransfer: 0 }), Ik = Qn(jk), zk = ce({}, Pa, { relatedTarget: 0 }), Ad = Qn(zk), Uk = ce({}, cs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Wk = Qn(Uk), Kk = ce({}, cs, { clipboardData: function (o) { return "clipboardData" in o ? o.clipboardData : window.clipboardData } }), Hk = Qn(Kk), qk = ce({}, cs, { data: 0 }), ug = Qn(qk), Gk = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Xk = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Zk = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Yk(o) { var l = this.nativeEvent; return l.getModifierState ? l.getModifierState(o) : (o = Zk[o]) ? !!l[o] : !1 } function Ed() { return Yk } var Qk = ce({}, Pa, { key: function (o) { if (o.key) { var l = Gk[o.key] || o.key; if (l !== "Unidentified") return l } return o.type === "keypress" ? (o = Tu(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? Xk[o.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ed, charCode: function (o) { return o.type === "keypress" ? Tu(o) : 0 }, keyCode: function (o) { return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0 }, which: function (o) { return o.type === "keypress" ? Tu(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0 } }), Jk = Qn(Qk), _k = ce({}, Au, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), cg = Qn(_k), $k = ce({}, Pa, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ed }), eA = Qn($k), tA = ce({}, cs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), nA = Qn(tA), rA = ce({}, Au, { deltaX: function (o) { return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0 }, deltaY: function (o) { return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), iA = Qn(rA), oA = [9, 13, 27, 32], Fd = u && "CompositionEvent" in window, ka = null; u && "documentMode" in document && (ka = document.documentMode); var sA = u && "TextEvent" in window && !ka, fg = u && (!Fd || ka && 8 < ka && 11 >= ka), dg = " ", hg = !1; function pg(o, l) { switch (o) { case "keyup": return oA.indexOf(l.keyCode) !== -1; case "keydown": return l.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function vg(o) { return o = o.detail, typeof o == "object" && "data" in o ? o.data : null } var fs = !1; function aA(o, l) { switch (o) { case "compositionend": return vg(l); case "keypress": return l.which !== 32 ? null : (hg = !0, dg); case "textInput": return o = l.data, o === dg && hg ? null : o; default: return null } } function lA(o, l) { if (fs) return o === "compositionend" || !Fd && pg(o, l) ? (o = sg(), Pu = Cd = Ui = null, fs = !1, o) : null; switch (o) { case "paste": return null; case "keypress": if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) { if (l.char && 1 < l.char.length) return l.char; if (l.which) return String.fromCharCode(l.which) } return null; case "compositionend": return fg && l.locale !== "ko" ? null : l.data; default: return null } } var uA = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function mg(o) { var l = o && o.nodeName && o.nodeName.toLowerCase(); return l === "input" ? !!uA[o.type] : l === "textarea" } function gg(o, l, d, p) { z(p), l = Ou(l, "onChange"), 0 < l.length && (d = new Pd("onChange", "change", null, d, p), o.push({ event: d, listeners: l })) } var Aa = null, Ea = null; function cA(o) { Ng(o, 0) } function Eu(o) { var l = ms(o); if (ht(l)) return o } function fA(o, l) { if (o === "change") return l } var yg = !1; if (u) { var Rd; if (u) { var Dd = "oninput" in document; if (!Dd) { var xg = document.createElement("div"); xg.setAttribute("oninput", "return;"), Dd = typeof xg.oninput == "function" } Rd = Dd } else Rd = !1; yg = Rd && (!document.documentMode || 9 < document.documentMode) } function wg() { Aa && (Aa.detachEvent("onpropertychange", Sg), Ea = Aa = null) } function Sg(o) { if (o.propertyName === "value" && Eu(Ea)) { var l = []; gg(l, Ea, o, ze(o)), at(cA, l) } } function dA(o, l, d) { o === "focusin" ? (wg(), Aa = l, Ea = d, Aa.attachEvent("onpropertychange", Sg)) : o === "focusout" && wg() } function hA(o) { if (o === "selectionchange" || o === "keyup" || o === "keydown") return Eu(Ea) } function pA(o, l) { if (o === "click") return Eu(l) } function vA(o, l) { if (o === "input" || o === "change") return Eu(l) } function mA(o, l) { return o === l && (o !== 0 || 1 / o === 1 / l) || o !== o && l !== l } var Vr = typeof Object.is == "function" ? Object.is : mA; function Fa(o, l) { if (Vr(o, l)) return !0; if (typeof o != "object" || o === null || typeof l != "object" || l === null) return !1; var d = Object.keys(o), p = Object.keys(l); if (d.length !== p.length) return !1; for (p = 0; p < d.length; p++) { var y = d[p]; if (!c.call(l, y) || !Vr(o[y], l[y])) return !1 } return !0 } function bg(o) { for (; o && o.firstChild;)o = o.firstChild; return o } function Cg(o, l) { var d = bg(o); o = 0; for (var p; d;) { if (d.nodeType === 3) { if (p = o + d.textContent.length, o <= l && p >= l) return { node: d, offset: l - o }; o = p } e: { for (; d;) { if (d.nextSibling) { d = d.nextSibling; break e } d = d.parentNode } d = void 0 } d = bg(d) } } function Pg(o, l) { return o && l ? o === l ? !0 : o && o.nodeType === 3 ? !1 : l && l.nodeType === 3 ? Pg(o, l.parentNode) : "contains" in o ? o.contains(l) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(l) & 16) : !1 : !1 } function Tg() { for (var o = window, l = Et(); l instanceof o.HTMLIFrameElement;) { try { var d = typeof l.contentWindow.location.href == "string" } catch { d = !1 } if (d) o = l.contentWindow; else break; l = Et(o.document) } return l } function Od(o) { var l = o && o.nodeName && o.nodeName.toLowerCase(); return l && (l === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || l === "textarea" || o.contentEditable === "true") } function gA(o) { var l = Tg(), d = o.focusedElem, p = o.selectionRange; if (l !== d && d && d.ownerDocument && Pg(d.ownerDocument.documentElement, d)) { if (p !== null && Od(d)) { if (l = p.start, o = p.end, o === void 0 && (o = l), "selectionStart" in d) d.selectionStart = l, d.selectionEnd = Math.min(o, d.value.length); else if (o = (l = d.ownerDocument || document) && l.defaultView || window, o.getSelection) { o = o.getSelection(); var y = d.textContent.length, w = Math.min(p.start, y); p = p.end === void 0 ? w : Math.min(p.end, y), !o.extend && w > p && (y = p, p = w, w = y), y = Cg(d, w); var T = Cg(d, p); y && T && (o.rangeCount !== 1 || o.anchorNode !== y.node || o.anchorOffset !== y.offset || o.focusNode !== T.node || o.focusOffset !== T.offset) && (l = l.createRange(), l.setStart(y.node, y.offset), o.removeAllRanges(), w > p ? (o.addRange(l), o.extend(T.node, T.offset)) : (l.setEnd(T.node, T.offset), o.addRange(l))) } } for (l = [], o = d; o = o.parentNode;)o.nodeType === 1 && l.push({ element: o, left: o.scrollLeft, top: o.scrollTop }); for (typeof d.focus == "function" && d.focus(), d = 0; d < l.length; d++)o = l[d], o.element.scrollLeft = o.left, o.element.scrollTop = o.top } } var yA = u && "documentMode" in document && 11 >= document.documentMode, ds = null, Md = null, Ra = null, Vd = !1; function kg(o, l, d) { var p = d.window === d ? d.document : d.nodeType === 9 ? d : d.ownerDocument; Vd || ds == null || ds !== Et(p) || (p = ds, "selectionStart" in p && Od(p) ? p = { start: p.selectionStart, end: p.selectionEnd } : (p = (p.ownerDocument && p.ownerDocument.defaultView || window).getSelection(), p = { anchorNode: p.anchorNode, anchorOffset: p.anchorOffset, focusNode: p.focusNode, focusOffset: p.focusOffset }), Ra && Fa(Ra, p) || (Ra = p, p = Ou(Md, "onSelect"), 0 < p.length && (l = new Pd("onSelect", "select", null, l, d), o.push({ event: l, listeners: p }), l.target = ds))) } function Fu(o, l) { var d = {}; return d[o.toLowerCase()] = l.toLowerCase(), d["Webkit" + o] = "webkit" + l, d["Moz" + o] = "moz" + l, d } var hs = { animationend: Fu("Animation", "AnimationEnd"), animationiteration: Fu("Animation", "AnimationIteration"), animationstart: Fu("Animation", "AnimationStart"), transitionend: Fu("Transition", "TransitionEnd") }, Nd = {}, Ag = {}; u && (Ag = document.createElement("div").style, "AnimationEvent" in window || (delete hs.animationend.animation, delete hs.animationiteration.animation, delete hs.animationstart.animation), "TransitionEvent" in window || delete hs.transitionend.transition); function Ru(o) { if (Nd[o]) return Nd[o]; if (!hs[o]) return o; var l = hs[o], d; for (d in l) if (l.hasOwnProperty(d) && d in Ag) return Nd[o] = l[d]; return o } var Eg = Ru("animationend"), Fg = Ru("animationiteration"), Rg = Ru("animationstart"), Dg = Ru("transitionend"), Og = new Map, Mg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Wi(o, l) { Og.set(o, l), s(l, [o]) } for (var Bd = 0; Bd < Mg.length; Bd++) { var Ld = Mg[Bd], xA = Ld.toLowerCase(), wA = Ld[0].toUpperCase() + Ld.slice(1); Wi(xA, "on" + wA) } Wi(Eg, "onAnimationEnd"), Wi(Fg, "onAnimationIteration"), Wi(Rg, "onAnimationStart"), Wi("dblclick", "onDoubleClick"), Wi("focusin", "onFocus"), Wi("focusout", "onBlur"), Wi(Dg, "onTransitionEnd"), a("onMouseEnter", ["mouseout", "mouseover"]), a("onMouseLeave", ["mouseout", "mouseover"]), a("onPointerEnter", ["pointerout", "pointerover"]), a("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Da = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), SA = new Set("cancel close invalid load scroll toggle".split(" ").concat(Da)); function Vg(o, l, d) { var p = o.type || "unknown-event"; o.currentTarget = d, en(p, l, void 0, o), o.currentTarget = null } function Ng(o, l) { l = (l & 4) !== 0; for (var d = 0; d < o.length; d++) { var p = o[d], y = p.event; p = p.listeners; e: { var w = void 0; if (l) for (var T = p.length - 1; 0 <= T; T--) { var L = p[T], U = L.instance, te = L.currentTarget; if (L = L.listener, U !== w && y.isPropagationStopped()) break e; Vg(y, L, te), w = U } else for (T = 0; T < p.length; T++) { if (L = p[T], U = L.instance, te = L.currentTarget, L = L.listener, U !== w && y.isPropagationStopped()) break e; Vg(y, L, te), w = U } } } if (di) throw o = Bi, di = !1, Bi = null, o } function Ft(o, l) { var d = l[qd]; d === void 0 && (d = l[qd] = new Set); var p = o + "__bubble"; d.has(p) || (Bg(l, o, 2, !1), d.add(p)) } function jd(o, l, d) { var p = 0; l && (p |= 4), Bg(d, o, p, l) } var Du = "_reactListening" + Math.random().toString(36).slice(2); function Oa(o) { if (!o[Du]) { o[Du] = !0, r.forEach(function (d) { d !== "selectionchange" && (SA.has(d) || jd(d, !1, o), jd(d, !0, o)) }); var l = o.nodeType === 9 ? o : o.ownerDocument; l === null || l[Du] || (l[Du] = !0, jd("selectionchange", !1, l)) } } function Bg(o, l, d, p) { switch (og(l)) { case 1: var y = Nk; break; case 4: y = Bk; break; default: y = Sd }d = y.bind(null, l, d, o), y = void 0, !kt || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (y = !0), p ? y !== void 0 ? o.addEventListener(l, d, { capture: !0, passive: y }) : o.addEventListener(l, d, !0) : y !== void 0 ? o.addEventListener(l, d, { passive: y }) : o.addEventListener(l, d, !1) } function Id(o, l, d, p, y) { var w = p; if (!(l & 1) && !(l & 2) && p !== null) e: for (; ;) { if (p === null) return; var T = p.tag; if (T === 3 || T === 4) { var L = p.stateNode.containerInfo; if (L === y || L.nodeType === 8 && L.parentNode === y) break; if (T === 4) for (T = p.return; T !== null;) { var U = T.tag; if ((U === 3 || U === 4) && (U = T.stateNode.containerInfo, U === y || U.nodeType === 8 && U.parentNode === y)) return; T = T.return } for (; L !== null;) { if (T = To(L), T === null) return; if (U = T.tag, U === 5 || U === 6) { p = w = T; continue e } L = L.parentNode } } p = p.return } at(function () { var te = w, ve = ze(d), me = []; e: { var he = Og.get(o); if (he !== void 0) { var Te = Pd, Oe = o; switch (o) { case "keypress": if (Tu(d) === 0) break e; case "keydown": case "keyup": Te = Jk; break; case "focusin": Oe = "focus", Te = Ad; break; case "focusout": Oe = "blur", Te = Ad; break; case "beforeblur": case "afterblur": Te = Ad; break; case "click": if (d.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": Te = lg; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": Te = Ik; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": Te = eA; break; case Eg: case Fg: case Rg: Te = Wk; break; case Dg: Te = nA; break; case "scroll": Te = Lk; break; case "wheel": Te = iA; break; case "copy": case "cut": case "paste": Te = Hk; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": Te = cg }var Me = (l & 4) !== 0, Xt = !Me && o === "scroll", X = Me ? he !== null ? he + "Capture" : null : he; Me = []; for (var K = te, J; K !== null;) { J = K; var Se = J.stateNode; if (J.tag === 5 && Se !== null && (J = Se, X !== null && (Se = On(K, X), Se != null && Me.push(Ma(K, Se, J)))), Xt) break; K = K.return } 0 < Me.length && (he = new Te(he, Oe, null, d, ve), me.push({ event: he, listeners: Me })) } } if (!(l & 7)) { e: { if (he = o === "mouseover" || o === "pointerover", Te = o === "mouseout" || o === "pointerout", he && d !== fe && (Oe = d.relatedTarget || d.fromElement) && (To(Oe) || Oe[hi])) break e; if ((Te || he) && (he = ve.window === ve ? ve : (he = ve.ownerDocument) ? he.defaultView || he.parentWindow : window, Te ? (Oe = d.relatedTarget || d.toElement, Te = te, Oe = Oe ? To(Oe) : null, Oe !== null && (Xt = mn(Oe), Oe !== Xt || Oe.tag !== 5 && Oe.tag !== 6) && (Oe = null)) : (Te = null, Oe = te), Te !== Oe)) { if (Me = lg, Se = "onMouseLeave", X = "onMouseEnter", K = "mouse", (o === "pointerout" || o === "pointerover") && (Me = cg, Se = "onPointerLeave", X = "onPointerEnter", K = "pointer"), Xt = Te == null ? he : ms(Te), J = Oe == null ? he : ms(Oe), he = new Me(Se, K + "leave", Te, d, ve), he.target = Xt, he.relatedTarget = J, Se = null, To(ve) === te && (Me = new Me(X, K + "enter", Oe, d, ve), Me.target = J, Me.relatedTarget = Xt, Se = Me), Xt = Se, Te && Oe) t: { for (Me = Te, X = Oe, K = 0, J = Me; J; J = ps(J))K++; for (J = 0, Se = X; Se; Se = ps(Se))J++; for (; 0 < K - J;)Me = ps(Me), K--; for (; 0 < J - K;)X = ps(X), J--; for (; K--;) { if (Me === X || X !== null && Me === X.alternate) break t; Me = ps(Me), X = ps(X) } Me = null } else Me = null; Te !== null && Lg(me, he, Te, Me, !1), Oe !== null && Xt !== null && Lg(me, Xt, Oe, Me, !0) } } e: { if (he = te ? ms(te) : window, Te = he.nodeName && he.nodeName.toLowerCase(), Te === "select" || Te === "input" && he.type === "file") var Ne = fA; else if (mg(he)) if (yg) Ne = vA; else { Ne = hA; var Ue = dA } else (Te = he.nodeName) && Te.toLowerCase() === "input" && (he.type === "checkbox" || he.type === "radio") && (Ne = pA); if (Ne && (Ne = Ne(o, te))) { gg(me, Ne, d, ve); break e } Ue && Ue(o, he, te), o === "focusout" && (Ue = he._wrapperState) && Ue.controlled && he.type === "number" && Kt(he, "number", he.value) } switch (Ue = te ? ms(te) : window, o) { case "focusin": (mg(Ue) || Ue.contentEditable === "true") && (ds = Ue, Md = te, Ra = null); break; case "focusout": Ra = Md = ds = null; break; case "mousedown": Vd = !0; break; case "contextmenu": case "mouseup": case "dragend": Vd = !1, kg(me, d, ve); break; case "selectionchange": if (yA) break; case "keydown": case "keyup": kg(me, d, ve) }var We; if (Fd) e: { switch (o) { case "compositionstart": var Ye = "onCompositionStart"; break e; case "compositionend": Ye = "onCompositionEnd"; break e; case "compositionupdate": Ye = "onCompositionUpdate"; break e }Ye = void 0 } else fs ? pg(o, d) && (Ye = "onCompositionEnd") : o === "keydown" && d.keyCode === 229 && (Ye = "onCompositionStart"); Ye && (fg && d.locale !== "ko" && (fs || Ye !== "onCompositionStart" ? Ye === "onCompositionEnd" && fs && (We = sg()) : (Ui = ve, Cd = "value" in Ui ? Ui.value : Ui.textContent, fs = !0)), Ue = Ou(te, Ye), 0 < Ue.length && (Ye = new ug(Ye, o, null, d, ve), me.push({ event: Ye, listeners: Ue }), We ? Ye.data = We : (We = vg(d), We !== null && (Ye.data = We)))), (We = sA ? aA(o, d) : lA(o, d)) && (te = Ou(te, "onBeforeInput"), 0 < te.length && (ve = new ug("onBeforeInput", "beforeinput", null, d, ve), me.push({ event: ve, listeners: te }), ve.data = We)) } Ng(me, l) }) } function Ma(o, l, d) { return { instance: o, listener: l, currentTarget: d } } function Ou(o, l) { for (var d = l + "Capture", p = []; o !== null;) { var y = o, w = y.stateNode; y.tag === 5 && w !== null && (y = w, w = On(o, d), w != null && p.unshift(Ma(o, w, y)), w = On(o, l), w != null && p.push(Ma(o, w, y))), o = o.return } return p } function ps(o) { if (o === null) return null; do o = o.return; while (o && o.tag !== 5); return o || null } function Lg(o, l, d, p, y) { for (var w = l._reactName, T = []; d !== null && d !== p;) { var L = d, U = L.alternate, te = L.stateNode; if (U !== null && U === p) break; L.tag === 5 && te !== null && (L = te, y ? (U = On(d, w), U != null && T.unshift(Ma(d, U, L))) : y || (U = On(d, w), U != null && T.push(Ma(d, U, L)))), d = d.return } T.length !== 0 && o.push({ event: l, listeners: T }) } var bA = /\r\n?/g, CA = /\u0000|\uFFFD/g; function jg(o) {
    return (typeof o == "string" ? o : "" + o).replace(bA, `
`).replace(CA, "")
  } function Mu(o, l, d) { if (l = jg(l), jg(o) !== l && d) throw Error(n(425)) } function Vu() { } var zd = null, Ud = null; function Wd(o, l) { return o === "textarea" || o === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null } var Kd = typeof setTimeout == "function" ? setTimeout : void 0, PA = typeof clearTimeout == "function" ? clearTimeout : void 0, Ig = typeof Promise == "function" ? Promise : void 0, TA = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ig < "u" ? function (o) { return Ig.resolve(null).then(o).catch(kA) } : Kd; function kA(o) { setTimeout(function () { throw o }) } function Hd(o, l) { var d = l, p = 0; do { var y = d.nextSibling; if (o.removeChild(d), y && y.nodeType === 8) if (d = y.data, d === "/$") { if (p === 0) { o.removeChild(y), Ca(l); return } p-- } else d !== "$" && d !== "$?" && d !== "$!" || p++; d = y } while (d); Ca(l) } function Ki(o) { for (; o != null; o = o.nextSibling) { var l = o.nodeType; if (l === 1 || l === 3) break; if (l === 8) { if (l = o.data, l === "$" || l === "$!" || l === "$?") break; if (l === "/$") return null } } return o } function zg(o) { o = o.previousSibling; for (var l = 0; o;) { if (o.nodeType === 8) { var d = o.data; if (d === "$" || d === "$!" || d === "$?") { if (l === 0) return o; l-- } else d === "/$" && l++ } o = o.previousSibling } return null } var vs = Math.random().toString(36).slice(2), Yr = "__reactFiber$" + vs, Va = "__reactProps$" + vs, hi = "__reactContainer$" + vs, qd = "__reactEvents$" + vs, AA = "__reactListeners$" + vs, EA = "__reactHandles$" + vs; function To(o) { var l = o[Yr]; if (l) return l; for (var d = o.parentNode; d;) { if (l = d[hi] || d[Yr]) { if (d = l.alternate, l.child !== null || d !== null && d.child !== null) for (o = zg(o); o !== null;) { if (d = o[Yr]) return d; o = zg(o) } return l } o = d, d = o.parentNode } return null } function Na(o) { return o = o[Yr] || o[hi], !o || o.tag !== 5 && o.tag !== 6 && o.tag !== 13 && o.tag !== 3 ? null : o } function ms(o) { if (o.tag === 5 || o.tag === 6) return o.stateNode; throw Error(n(33)) } function Nu(o) { return o[Va] || null } var Gd = [], gs = -1; function Hi(o) { return { current: o } } function Rt(o) { 0 > gs || (o.current = Gd[gs], Gd[gs] = null, gs--) } function At(o, l) { gs++, Gd[gs] = o.current, o.current = l } var qi = {}, Cn = Hi(qi), Un = Hi(!1), ko = qi; function ys(o, l) { var d = o.type.contextTypes; if (!d) return qi; var p = o.stateNode; if (p && p.__reactInternalMemoizedUnmaskedChildContext === l) return p.__reactInternalMemoizedMaskedChildContext; var y = {}, w; for (w in d) y[w] = l[w]; return p && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = l, o.__reactInternalMemoizedMaskedChildContext = y), y } function Wn(o) { return o = o.childContextTypes, o != null } function Bu() { Rt(Un), Rt(Cn) } function Ug(o, l, d) { if (Cn.current !== qi) throw Error(n(168)); At(Cn, l), At(Un, d) } function Wg(o, l, d) { var p = o.stateNode; if (l = l.childContextTypes, typeof p.getChildContext != "function") return d; p = p.getChildContext(); for (var y in p) if (!(y in l)) throw Error(n(108, Ie(o) || "Unknown", y)); return ce({}, d, p) } function Lu(o) { return o = (o = o.stateNode) && o.__reactInternalMemoizedMergedChildContext || qi, ko = Cn.current, At(Cn, o), At(Un, Un.current), !0 } function Kg(o, l, d) { var p = o.stateNode; if (!p) throw Error(n(169)); d ? (o = Wg(o, l, ko), p.__reactInternalMemoizedMergedChildContext = o, Rt(Un), Rt(Cn), At(Cn, o)) : Rt(Un), At(Un, d) } var pi = null, ju = !1, Xd = !1; function Hg(o) { pi === null ? pi = [o] : pi.push(o) } function FA(o) { ju = !0, Hg(o) } function Gi() { if (!Xd && pi !== null) { Xd = !0; var o = 0, l = Pt; try { var d = pi; for (Pt = 1; o < d.length; o++) { var p = d[o]; do p = p(!0); while (p !== null) } pi = null, ju = !1 } catch (y) { throw pi !== null && (pi = pi.slice(o + 1)), Gm(vd, Gi), y } finally { Pt = l, Xd = !1 } } return null } var xs = [], ws = 0, Iu = null, zu = 0, hr = [], pr = 0, Ao = null, vi = 1, mi = ""; function Eo(o, l) { xs[ws++] = zu, xs[ws++] = Iu, Iu = o, zu = l } function qg(o, l, d) { hr[pr++] = vi, hr[pr++] = mi, hr[pr++] = Ao, Ao = o; var p = vi; o = mi; var y = 32 - Mr(p) - 1; p &= ~(1 << y), d += 1; var w = 32 - Mr(l) + y; if (30 < w) { var T = y - y % 5; w = (p & (1 << T) - 1).toString(32), p >>= T, y -= T, vi = 1 << 32 - Mr(l) + y | d << y | p, mi = w + o } else vi = 1 << w | d << y | p, mi = o } function Zd(o) { o.return !== null && (Eo(o, 1), qg(o, 1, 0)) } function Yd(o) { for (; o === Iu;)Iu = xs[--ws], xs[ws] = null, zu = xs[--ws], xs[ws] = null; for (; o === Ao;)Ao = hr[--pr], hr[pr] = null, mi = hr[--pr], hr[pr] = null, vi = hr[--pr], hr[pr] = null } var Jn = null, _n = null, Ot = !1, Nr = null; function Gg(o, l) { var d = yr(5, null, null, 0); d.elementType = "DELETED", d.stateNode = l, d.return = o, l = o.deletions, l === null ? (o.deletions = [d], o.flags |= 16) : l.push(d) } function Xg(o, l) { switch (o.tag) { case 5: var d = o.type; return l = l.nodeType !== 1 || d.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (o.stateNode = l, Jn = o, _n = Ki(l.firstChild), !0) : !1; case 6: return l = o.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (o.stateNode = l, Jn = o, _n = null, !0) : !1; case 13: return l = l.nodeType !== 8 ? null : l, l !== null ? (d = Ao !== null ? { id: vi, overflow: mi } : null, o.memoizedState = { dehydrated: l, treeContext: d, retryLane: 1073741824 }, d = yr(18, null, null, 0), d.stateNode = l, d.return = o, o.child = d, Jn = o, _n = null, !0) : !1; default: return !1 } } function Qd(o) { return (o.mode & 1) !== 0 && (o.flags & 128) === 0 } function Jd(o) { if (Ot) { var l = _n; if (l) { var d = l; if (!Xg(o, l)) { if (Qd(o)) throw Error(n(418)); l = Ki(d.nextSibling); var p = Jn; l && Xg(o, l) ? Gg(p, d) : (o.flags = o.flags & -4097 | 2, Ot = !1, Jn = o) } } else { if (Qd(o)) throw Error(n(418)); o.flags = o.flags & -4097 | 2, Ot = !1, Jn = o } } } function Zg(o) { for (o = o.return; o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13;)o = o.return; Jn = o } function Uu(o) { if (o !== Jn) return !1; if (!Ot) return Zg(o), Ot = !0, !1; var l; if ((l = o.tag !== 3) && !(l = o.tag !== 5) && (l = o.type, l = l !== "head" && l !== "body" && !Wd(o.type, o.memoizedProps)), l && (l = _n)) { if (Qd(o)) throw Yg(), Error(n(418)); for (; l;)Gg(o, l), l = Ki(l.nextSibling) } if (Zg(o), o.tag === 13) { if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(n(317)); e: { for (o = o.nextSibling, l = 0; o;) { if (o.nodeType === 8) { var d = o.data; if (d === "/$") { if (l === 0) { _n = Ki(o.nextSibling); break e } l-- } else d !== "$" && d !== "$!" && d !== "$?" || l++ } o = o.nextSibling } _n = null } } else _n = Jn ? Ki(o.stateNode.nextSibling) : null; return !0 } function Yg() { for (var o = _n; o;)o = Ki(o.nextSibling) } function Ss() { _n = Jn = null, Ot = !1 } function _d(o) { Nr === null ? Nr = [o] : Nr.push(o) } var RA = N.ReactCurrentBatchConfig; function Ba(o, l, d) { if (o = d.ref, o !== null && typeof o != "function" && typeof o != "object") { if (d._owner) { if (d = d._owner, d) { if (d.tag !== 1) throw Error(n(309)); var p = d.stateNode } if (!p) throw Error(n(147, o)); var y = p, w = "" + o; return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === w ? l.ref : (l = function (T) { var L = y.refs; T === null ? delete L[w] : L[w] = T }, l._stringRef = w, l) } if (typeof o != "string") throw Error(n(284)); if (!d._owner) throw Error(n(290, o)) } return o } function Wu(o, l) { throw o = Object.prototype.toString.call(l), Error(n(31, o === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : o)) } function Qg(o) { var l = o._init; return l(o._payload) } function Jg(o) { function l(X, K) { if (o) { var J = X.deletions; J === null ? (X.deletions = [K], X.flags |= 16) : J.push(K) } } function d(X, K) { if (!o) return null; for (; K !== null;)l(X, K), K = K.sibling; return null } function p(X, K) { for (X = new Map; K !== null;)K.key !== null ? X.set(K.key, K) : X.set(K.index, K), K = K.sibling; return X } function y(X, K) { return X = eo(X, K), X.index = 0, X.sibling = null, X } function w(X, K, J) { return X.index = J, o ? (J = X.alternate, J !== null ? (J = J.index, J < K ? (X.flags |= 2, K) : J) : (X.flags |= 2, K)) : (X.flags |= 1048576, K) } function T(X) { return o && X.alternate === null && (X.flags |= 2), X } function L(X, K, J, Se) { return K === null || K.tag !== 6 ? (K = Kh(J, X.mode, Se), K.return = X, K) : (K = y(K, J), K.return = X, K) } function U(X, K, J, Se) { var Ne = J.type; return Ne === B ? ve(X, K, J.props.children, Se, J.key) : K !== null && (K.elementType === Ne || typeof Ne == "object" && Ne !== null && Ne.$$typeof === ae && Qg(Ne) === K.type) ? (Se = y(K, J.props), Se.ref = Ba(X, K, J), Se.return = X, Se) : (Se = dc(J.type, J.key, J.props, null, X.mode, Se), Se.ref = Ba(X, K, J), Se.return = X, Se) } function te(X, K, J, Se) { return K === null || K.tag !== 4 || K.stateNode.containerInfo !== J.containerInfo || K.stateNode.implementation !== J.implementation ? (K = Hh(J, X.mode, Se), K.return = X, K) : (K = y(K, J.children || []), K.return = X, K) } function ve(X, K, J, Se, Ne) { return K === null || K.tag !== 7 ? (K = Bo(J, X.mode, Se, Ne), K.return = X, K) : (K = y(K, J), K.return = X, K) } function me(X, K, J) { if (typeof K == "string" && K !== "" || typeof K == "number") return K = Kh("" + K, X.mode, J), K.return = X, K; if (typeof K == "object" && K !== null) { switch (K.$$typeof) { case D: return J = dc(K.type, K.key, K.props, null, X.mode, J), J.ref = Ba(X, null, K), J.return = X, J; case V: return K = Hh(K, X.mode, J), K.return = X, K; case ae: var Se = K._init; return me(X, Se(K._payload), J) }if (cr(K) || le(K)) return K = Bo(K, X.mode, J, null), K.return = X, K; Wu(X, K) } return null } function he(X, K, J, Se) { var Ne = K !== null ? K.key : null; if (typeof J == "string" && J !== "" || typeof J == "number") return Ne !== null ? null : L(X, K, "" + J, Se); if (typeof J == "object" && J !== null) { switch (J.$$typeof) { case D: return J.key === Ne ? U(X, K, J, Se) : null; case V: return J.key === Ne ? te(X, K, J, Se) : null; case ae: return Ne = J._init, he(X, K, Ne(J._payload), Se) }if (cr(J) || le(J)) return Ne !== null ? null : ve(X, K, J, Se, null); Wu(X, J) } return null } function Te(X, K, J, Se, Ne) { if (typeof Se == "string" && Se !== "" || typeof Se == "number") return X = X.get(J) || null, L(K, X, "" + Se, Ne); if (typeof Se == "object" && Se !== null) { switch (Se.$$typeof) { case D: return X = X.get(Se.key === null ? J : Se.key) || null, U(K, X, Se, Ne); case V: return X = X.get(Se.key === null ? J : Se.key) || null, te(K, X, Se, Ne); case ae: var Ue = Se._init; return Te(X, K, J, Ue(Se._payload), Ne) }if (cr(Se) || le(Se)) return X = X.get(J) || null, ve(K, X, Se, Ne, null); Wu(K, Se) } return null } function Oe(X, K, J, Se) { for (var Ne = null, Ue = null, We = K, Ye = K = 0, dn = null; We !== null && Ye < J.length; Ye++) { We.index > Ye ? (dn = We, We = null) : dn = We.sibling; var gt = he(X, We, J[Ye], Se); if (gt === null) { We === null && (We = dn); break } o && We && gt.alternate === null && l(X, We), K = w(gt, K, Ye), Ue === null ? Ne = gt : Ue.sibling = gt, Ue = gt, We = dn } if (Ye === J.length) return d(X, We), Ot && Eo(X, Ye), Ne; if (We === null) { for (; Ye < J.length; Ye++)We = me(X, J[Ye], Se), We !== null && (K = w(We, K, Ye), Ue === null ? Ne = We : Ue.sibling = We, Ue = We); return Ot && Eo(X, Ye), Ne } for (We = p(X, We); Ye < J.length; Ye++)dn = Te(We, X, Ye, J[Ye], Se), dn !== null && (o && dn.alternate !== null && We.delete(dn.key === null ? Ye : dn.key), K = w(dn, K, Ye), Ue === null ? Ne = dn : Ue.sibling = dn, Ue = dn); return o && We.forEach(function (to) { return l(X, to) }), Ot && Eo(X, Ye), Ne } function Me(X, K, J, Se) { var Ne = le(J); if (typeof Ne != "function") throw Error(n(150)); if (J = Ne.call(J), J == null) throw Error(n(151)); for (var Ue = Ne = null, We = K, Ye = K = 0, dn = null, gt = J.next(); We !== null && !gt.done; Ye++, gt = J.next()) { We.index > Ye ? (dn = We, We = null) : dn = We.sibling; var to = he(X, We, gt.value, Se); if (to === null) { We === null && (We = dn); break } o && We && to.alternate === null && l(X, We), K = w(to, K, Ye), Ue === null ? Ne = to : Ue.sibling = to, Ue = to, We = dn } if (gt.done) return d(X, We), Ot && Eo(X, Ye), Ne; if (We === null) { for (; !gt.done; Ye++, gt = J.next())gt = me(X, gt.value, Se), gt !== null && (K = w(gt, K, Ye), Ue === null ? Ne = gt : Ue.sibling = gt, Ue = gt); return Ot && Eo(X, Ye), Ne } for (We = p(X, We); !gt.done; Ye++, gt = J.next())gt = Te(We, X, Ye, gt.value, Se), gt !== null && (o && gt.alternate !== null && We.delete(gt.key === null ? Ye : gt.key), K = w(gt, K, Ye), Ue === null ? Ne = gt : Ue.sibling = gt, Ue = gt); return o && We.forEach(function (lE) { return l(X, lE) }), Ot && Eo(X, Ye), Ne } function Xt(X, K, J, Se) { if (typeof J == "object" && J !== null && J.type === B && J.key === null && (J = J.props.children), typeof J == "object" && J !== null) { switch (J.$$typeof) { case D: e: { for (var Ne = J.key, Ue = K; Ue !== null;) { if (Ue.key === Ne) { if (Ne = J.type, Ne === B) { if (Ue.tag === 7) { d(X, Ue.sibling), K = y(Ue, J.props.children), K.return = X, X = K; break e } } else if (Ue.elementType === Ne || typeof Ne == "object" && Ne !== null && Ne.$$typeof === ae && Qg(Ne) === Ue.type) { d(X, Ue.sibling), K = y(Ue, J.props), K.ref = Ba(X, Ue, J), K.return = X, X = K; break e } d(X, Ue); break } else l(X, Ue); Ue = Ue.sibling } J.type === B ? (K = Bo(J.props.children, X.mode, Se, J.key), K.return = X, X = K) : (Se = dc(J.type, J.key, J.props, null, X.mode, Se), Se.ref = Ba(X, K, J), Se.return = X, X = Se) } return T(X); case V: e: { for (Ue = J.key; K !== null;) { if (K.key === Ue) if (K.tag === 4 && K.stateNode.containerInfo === J.containerInfo && K.stateNode.implementation === J.implementation) { d(X, K.sibling), K = y(K, J.children || []), K.return = X, X = K; break e } else { d(X, K); break } else l(X, K); K = K.sibling } K = Hh(J, X.mode, Se), K.return = X, X = K } return T(X); case ae: return Ue = J._init, Xt(X, K, Ue(J._payload), Se) }if (cr(J)) return Oe(X, K, J, Se); if (le(J)) return Me(X, K, J, Se); Wu(X, J) } return typeof J == "string" && J !== "" || typeof J == "number" ? (J = "" + J, K !== null && K.tag === 6 ? (d(X, K.sibling), K = y(K, J), K.return = X, X = K) : (d(X, K), K = Kh(J, X.mode, Se), K.return = X, X = K), T(X)) : d(X, K) } return Xt } var bs = Jg(!0), _g = Jg(!1), Ku = Hi(null), Hu = null, Cs = null, $d = null; function eh() { $d = Cs = Hu = null } function th(o) { var l = Ku.current; Rt(Ku), o._currentValue = l } function nh(o, l, d) { for (; o !== null;) { var p = o.alternate; if ((o.childLanes & l) !== l ? (o.childLanes |= l, p !== null && (p.childLanes |= l)) : p !== null && (p.childLanes & l) !== l && (p.childLanes |= l), o === d) break; o = o.return } } function Ps(o, l) { Hu = o, $d = Cs = null, o = o.dependencies, o !== null && o.firstContext !== null && (o.lanes & l && (Kn = !0), o.firstContext = null) } function vr(o) { var l = o._currentValue; if ($d !== o) if (o = { context: o, memoizedValue: l, next: null }, Cs === null) { if (Hu === null) throw Error(n(308)); Cs = o, Hu.dependencies = { lanes: 0, firstContext: o } } else Cs = Cs.next = o; return l } var Fo = null; function rh(o) { Fo === null ? Fo = [o] : Fo.push(o) } function $g(o, l, d, p) { var y = l.interleaved; return y === null ? (d.next = d, rh(l)) : (d.next = y.next, y.next = d), l.interleaved = d, gi(o, p) } function gi(o, l) { o.lanes |= l; var d = o.alternate; for (d !== null && (d.lanes |= l), d = o, o = o.return; o !== null;)o.childLanes |= l, d = o.alternate, d !== null && (d.childLanes |= l), d = o, o = o.return; return d.tag === 3 ? d.stateNode : null } var Xi = !1; function ih(o) { o.updateQueue = { baseState: o.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function ey(o, l) { o = o.updateQueue, l.updateQueue === o && (l.updateQueue = { baseState: o.baseState, firstBaseUpdate: o.firstBaseUpdate, lastBaseUpdate: o.lastBaseUpdate, shared: o.shared, effects: o.effects }) } function yi(o, l) { return { eventTime: o, lane: l, tag: 0, payload: null, callback: null, next: null } } function Zi(o, l, d) { var p = o.updateQueue; if (p === null) return null; if (p = p.shared, vt & 2) { var y = p.pending; return y === null ? l.next = l : (l.next = y.next, y.next = l), p.pending = l, gi(o, d) } return y = p.interleaved, y === null ? (l.next = l, rh(p)) : (l.next = y.next, y.next = l), p.interleaved = l, gi(o, d) } function qu(o, l, d) { if (l = l.updateQueue, l !== null && (l = l.shared, (d & 4194240) !== 0)) { var p = l.lanes; p &= o.pendingLanes, d |= p, l.lanes = d, yd(o, d) } } function ty(o, l) { var d = o.updateQueue, p = o.alternate; if (p !== null && (p = p.updateQueue, d === p)) { var y = null, w = null; if (d = d.firstBaseUpdate, d !== null) { do { var T = { eventTime: d.eventTime, lane: d.lane, tag: d.tag, payload: d.payload, callback: d.callback, next: null }; w === null ? y = w = T : w = w.next = T, d = d.next } while (d !== null); w === null ? y = w = l : w = w.next = l } else y = w = l; d = { baseState: p.baseState, firstBaseUpdate: y, lastBaseUpdate: w, shared: p.shared, effects: p.effects }, o.updateQueue = d; return } o = d.lastBaseUpdate, o === null ? d.firstBaseUpdate = l : o.next = l, d.lastBaseUpdate = l } function Gu(o, l, d, p) { var y = o.updateQueue; Xi = !1; var w = y.firstBaseUpdate, T = y.lastBaseUpdate, L = y.shared.pending; if (L !== null) { y.shared.pending = null; var U = L, te = U.next; U.next = null, T === null ? w = te : T.next = te, T = U; var ve = o.alternate; ve !== null && (ve = ve.updateQueue, L = ve.lastBaseUpdate, L !== T && (L === null ? ve.firstBaseUpdate = te : L.next = te, ve.lastBaseUpdate = U)) } if (w !== null) { var me = y.baseState; T = 0, ve = te = U = null, L = w; do { var he = L.lane, Te = L.eventTime; if ((p & he) === he) { ve !== null && (ve = ve.next = { eventTime: Te, lane: 0, tag: L.tag, payload: L.payload, callback: L.callback, next: null }); e: { var Oe = o, Me = L; switch (he = l, Te = d, Me.tag) { case 1: if (Oe = Me.payload, typeof Oe == "function") { me = Oe.call(Te, me, he); break e } me = Oe; break e; case 3: Oe.flags = Oe.flags & -65537 | 128; case 0: if (Oe = Me.payload, he = typeof Oe == "function" ? Oe.call(Te, me, he) : Oe, he == null) break e; me = ce({}, me, he); break e; case 2: Xi = !0 } } L.callback !== null && L.lane !== 0 && (o.flags |= 64, he = y.effects, he === null ? y.effects = [L] : he.push(L)) } else Te = { eventTime: Te, lane: he, tag: L.tag, payload: L.payload, callback: L.callback, next: null }, ve === null ? (te = ve = Te, U = me) : ve = ve.next = Te, T |= he; if (L = L.next, L === null) { if (L = y.shared.pending, L === null) break; he = L, L = he.next, he.next = null, y.lastBaseUpdate = he, y.shared.pending = null } } while (!0); if (ve === null && (U = me), y.baseState = U, y.firstBaseUpdate = te, y.lastBaseUpdate = ve, l = y.shared.interleaved, l !== null) { y = l; do T |= y.lane, y = y.next; while (y !== l) } else w === null && (y.shared.lanes = 0); Oo |= T, o.lanes = T, o.memoizedState = me } } function ny(o, l, d) { if (o = l.effects, l.effects = null, o !== null) for (l = 0; l < o.length; l++) { var p = o[l], y = p.callback; if (y !== null) { if (p.callback = null, p = d, typeof y != "function") throw Error(n(191, y)); y.call(p) } } } var La = {}, Qr = Hi(La), ja = Hi(La), Ia = Hi(La); function Ro(o) { if (o === La) throw Error(n(174)); return o } function oh(o, l) { switch (At(Ia, l), At(ja, o), At(Qr, La), o = l.nodeType, o) { case 9: case 11: l = (l = l.documentElement) ? l.namespaceURI : fr(null, ""); break; default: o = o === 8 ? l.parentNode : l, l = o.namespaceURI || null, o = o.tagName, l = fr(l, o) }Rt(Qr), At(Qr, l) } function Ts() { Rt(Qr), Rt(ja), Rt(Ia) } function ry(o) { Ro(Ia.current); var l = Ro(Qr.current), d = fr(l, o.type); l !== d && (At(ja, o), At(Qr, d)) } function sh(o) { ja.current === o && (Rt(Qr), Rt(ja)) } var Mt = Hi(0); function Xu(o) { for (var l = o; l !== null;) { if (l.tag === 13) { var d = l.memoizedState; if (d !== null && (d = d.dehydrated, d === null || d.data === "$?" || d.data === "$!")) return l } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) { if (l.flags & 128) return l } else if (l.child !== null) { l.child.return = l, l = l.child; continue } if (l === o) break; for (; l.sibling === null;) { if (l.return === null || l.return === o) return null; l = l.return } l.sibling.return = l.return, l = l.sibling } return null } var ah = []; function lh() { for (var o = 0; o < ah.length; o++)ah[o]._workInProgressVersionPrimary = null; ah.length = 0 } var Zu = N.ReactCurrentDispatcher, uh = N.ReactCurrentBatchConfig, Do = 0, Vt = null, tn = null, cn = null, Yu = !1, za = !1, Ua = 0, DA = 0; function Pn() { throw Error(n(321)) } function ch(o, l) { if (l === null) return !1; for (var d = 0; d < l.length && d < o.length; d++)if (!Vr(o[d], l[d])) return !1; return !0 } function fh(o, l, d, p, y, w) { if (Do = w, Vt = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, Zu.current = o === null || o.memoizedState === null ? NA : BA, o = d(p, y), za) { w = 0; do { if (za = !1, Ua = 0, 25 <= w) throw Error(n(301)); w += 1, cn = tn = null, l.updateQueue = null, Zu.current = LA, o = d(p, y) } while (za) } if (Zu.current = _u, l = tn !== null && tn.next !== null, Do = 0, cn = tn = Vt = null, Yu = !1, l) throw Error(n(300)); return o } function dh() { var o = Ua !== 0; return Ua = 0, o } function Jr() { var o = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return cn === null ? Vt.memoizedState = cn = o : cn = cn.next = o, cn } function mr() { if (tn === null) { var o = Vt.alternate; o = o !== null ? o.memoizedState : null } else o = tn.next; var l = cn === null ? Vt.memoizedState : cn.next; if (l !== null) cn = l, tn = o; else { if (o === null) throw Error(n(310)); tn = o, o = { memoizedState: tn.memoizedState, baseState: tn.baseState, baseQueue: tn.baseQueue, queue: tn.queue, next: null }, cn === null ? Vt.memoizedState = cn = o : cn = cn.next = o } return cn } function Wa(o, l) { return typeof l == "function" ? l(o) : l } function hh(o) { var l = mr(), d = l.queue; if (d === null) throw Error(n(311)); d.lastRenderedReducer = o; var p = tn, y = p.baseQueue, w = d.pending; if (w !== null) { if (y !== null) { var T = y.next; y.next = w.next, w.next = T } p.baseQueue = y = w, d.pending = null } if (y !== null) { w = y.next, p = p.baseState; var L = T = null, U = null, te = w; do { var ve = te.lane; if ((Do & ve) === ve) U !== null && (U = U.next = { lane: 0, action: te.action, hasEagerState: te.hasEagerState, eagerState: te.eagerState, next: null }), p = te.hasEagerState ? te.eagerState : o(p, te.action); else { var me = { lane: ve, action: te.action, hasEagerState: te.hasEagerState, eagerState: te.eagerState, next: null }; U === null ? (L = U = me, T = p) : U = U.next = me, Vt.lanes |= ve, Oo |= ve } te = te.next } while (te !== null && te !== w); U === null ? T = p : U.next = L, Vr(p, l.memoizedState) || (Kn = !0), l.memoizedState = p, l.baseState = T, l.baseQueue = U, d.lastRenderedState = p } if (o = d.interleaved, o !== null) { y = o; do w = y.lane, Vt.lanes |= w, Oo |= w, y = y.next; while (y !== o) } else y === null && (d.lanes = 0); return [l.memoizedState, d.dispatch] } function ph(o) { var l = mr(), d = l.queue; if (d === null) throw Error(n(311)); d.lastRenderedReducer = o; var p = d.dispatch, y = d.pending, w = l.memoizedState; if (y !== null) { d.pending = null; var T = y = y.next; do w = o(w, T.action), T = T.next; while (T !== y); Vr(w, l.memoizedState) || (Kn = !0), l.memoizedState = w, l.baseQueue === null && (l.baseState = w), d.lastRenderedState = w } return [w, p] } function iy() { } function oy(o, l) { var d = Vt, p = mr(), y = l(), w = !Vr(p.memoizedState, y); if (w && (p.memoizedState = y, Kn = !0), p = p.queue, vh(ly.bind(null, d, p, o), [o]), p.getSnapshot !== l || w || cn !== null && cn.memoizedState.tag & 1) { if (d.flags |= 2048, Ka(9, ay.bind(null, d, p, y, l), void 0, null), fn === null) throw Error(n(349)); Do & 30 || sy(d, l, y) } return y } function sy(o, l, d) { o.flags |= 16384, o = { getSnapshot: l, value: d }, l = Vt.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Vt.updateQueue = l, l.stores = [o]) : (d = l.stores, d === null ? l.stores = [o] : d.push(o)) } function ay(o, l, d, p) { l.value = d, l.getSnapshot = p, uy(l) && cy(o) } function ly(o, l, d) { return d(function () { uy(l) && cy(o) }) } function uy(o) { var l = o.getSnapshot; o = o.value; try { var d = l(); return !Vr(o, d) } catch { return !0 } } function cy(o) { var l = gi(o, 1); l !== null && Ir(l, o, 1, -1) } function fy(o) { var l = Jr(); return typeof o == "function" && (o = o()), l.memoizedState = l.baseState = o, o = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Wa, lastRenderedState: o }, l.queue = o, o = o.dispatch = VA.bind(null, Vt, o), [l.memoizedState, o] } function Ka(o, l, d, p) { return o = { tag: o, create: l, destroy: d, deps: p, next: null }, l = Vt.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Vt.updateQueue = l, l.lastEffect = o.next = o) : (d = l.lastEffect, d === null ? l.lastEffect = o.next = o : (p = d.next, d.next = o, o.next = p, l.lastEffect = o)), o } function dy() { return mr().memoizedState } function Qu(o, l, d, p) { var y = Jr(); Vt.flags |= o, y.memoizedState = Ka(1 | l, d, void 0, p === void 0 ? null : p) } function Ju(o, l, d, p) { var y = mr(); p = p === void 0 ? null : p; var w = void 0; if (tn !== null) { var T = tn.memoizedState; if (w = T.destroy, p !== null && ch(p, T.deps)) { y.memoizedState = Ka(l, d, w, p); return } } Vt.flags |= o, y.memoizedState = Ka(1 | l, d, w, p) } function hy(o, l) { return Qu(8390656, 8, o, l) } function vh(o, l) { return Ju(2048, 8, o, l) } function py(o, l) { return Ju(4, 2, o, l) } function vy(o, l) { return Ju(4, 4, o, l) } function my(o, l) { if (typeof l == "function") return o = o(), l(o), function () { l(null) }; if (l != null) return o = o(), l.current = o, function () { l.current = null } } function gy(o, l, d) { return d = d != null ? d.concat([o]) : null, Ju(4, 4, my.bind(null, l, o), d) } function mh() { } function yy(o, l) { var d = mr(); l = l === void 0 ? null : l; var p = d.memoizedState; return p !== null && l !== null && ch(l, p[1]) ? p[0] : (d.memoizedState = [o, l], o) } function xy(o, l) { var d = mr(); l = l === void 0 ? null : l; var p = d.memoizedState; return p !== null && l !== null && ch(l, p[1]) ? p[0] : (o = o(), d.memoizedState = [o, l], o) } function wy(o, l, d) { return Do & 21 ? (Vr(d, l) || (d = Qm(), Vt.lanes |= d, Oo |= d, o.baseState = !0), l) : (o.baseState && (o.baseState = !1, Kn = !0), o.memoizedState = d) } function OA(o, l) { var d = Pt; Pt = d !== 0 && 4 > d ? d : 4, o(!0); var p = uh.transition; uh.transition = {}; try { o(!1), l() } finally { Pt = d, uh.transition = p } } function Sy() { return mr().memoizedState } function MA(o, l, d) { var p = _i(o); if (d = { lane: p, action: d, hasEagerState: !1, eagerState: null, next: null }, by(o)) Cy(l, d); else if (d = $g(o, l, d, p), d !== null) { var y = Vn(); Ir(d, o, p, y), Py(d, l, p) } } function VA(o, l, d) { var p = _i(o), y = { lane: p, action: d, hasEagerState: !1, eagerState: null, next: null }; if (by(o)) Cy(l, y); else { var w = o.alternate; if (o.lanes === 0 && (w === null || w.lanes === 0) && (w = l.lastRenderedReducer, w !== null)) try { var T = l.lastRenderedState, L = w(T, d); if (y.hasEagerState = !0, y.eagerState = L, Vr(L, T)) { var U = l.interleaved; U === null ? (y.next = y, rh(l)) : (y.next = U.next, U.next = y), l.interleaved = y; return } } catch { } finally { } d = $g(o, l, y, p), d !== null && (y = Vn(), Ir(d, o, p, y), Py(d, l, p)) } } function by(o) { var l = o.alternate; return o === Vt || l !== null && l === Vt } function Cy(o, l) { za = Yu = !0; var d = o.pending; d === null ? l.next = l : (l.next = d.next, d.next = l), o.pending = l } function Py(o, l, d) { if (d & 4194240) { var p = l.lanes; p &= o.pendingLanes, d |= p, l.lanes = d, yd(o, d) } } var _u = { readContext: vr, useCallback: Pn, useContext: Pn, useEffect: Pn, useImperativeHandle: Pn, useInsertionEffect: Pn, useLayoutEffect: Pn, useMemo: Pn, useReducer: Pn, useRef: Pn, useState: Pn, useDebugValue: Pn, useDeferredValue: Pn, useTransition: Pn, useMutableSource: Pn, useSyncExternalStore: Pn, useId: Pn, unstable_isNewReconciler: !1 }, NA = { readContext: vr, useCallback: function (o, l) { return Jr().memoizedState = [o, l === void 0 ? null : l], o }, useContext: vr, useEffect: hy, useImperativeHandle: function (o, l, d) { return d = d != null ? d.concat([o]) : null, Qu(4194308, 4, my.bind(null, l, o), d) }, useLayoutEffect: function (o, l) { return Qu(4194308, 4, o, l) }, useInsertionEffect: function (o, l) { return Qu(4, 2, o, l) }, useMemo: function (o, l) { var d = Jr(); return l = l === void 0 ? null : l, o = o(), d.memoizedState = [o, l], o }, useReducer: function (o, l, d) { var p = Jr(); return l = d !== void 0 ? d(l) : l, p.memoizedState = p.baseState = l, o = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: o, lastRenderedState: l }, p.queue = o, o = o.dispatch = MA.bind(null, Vt, o), [p.memoizedState, o] }, useRef: function (o) { var l = Jr(); return o = { current: o }, l.memoizedState = o }, useState: fy, useDebugValue: mh, useDeferredValue: function (o) { return Jr().memoizedState = o }, useTransition: function () { var o = fy(!1), l = o[0]; return o = OA.bind(null, o[1]), Jr().memoizedState = o, [l, o] }, useMutableSource: function () { }, useSyncExternalStore: function (o, l, d) { var p = Vt, y = Jr(); if (Ot) { if (d === void 0) throw Error(n(407)); d = d() } else { if (d = l(), fn === null) throw Error(n(349)); Do & 30 || sy(p, l, d) } y.memoizedState = d; var w = { value: d, getSnapshot: l }; return y.queue = w, hy(ly.bind(null, p, w, o), [o]), p.flags |= 2048, Ka(9, ay.bind(null, p, w, d, l), void 0, null), d }, useId: function () { var o = Jr(), l = fn.identifierPrefix; if (Ot) { var d = mi, p = vi; d = (p & ~(1 << 32 - Mr(p) - 1)).toString(32) + d, l = ":" + l + "R" + d, d = Ua++, 0 < d && (l += "H" + d.toString(32)), l += ":" } else d = DA++, l = ":" + l + "r" + d.toString(32) + ":"; return o.memoizedState = l }, unstable_isNewReconciler: !1 }, BA = { readContext: vr, useCallback: yy, useContext: vr, useEffect: vh, useImperativeHandle: gy, useInsertionEffect: py, useLayoutEffect: vy, useMemo: xy, useReducer: hh, useRef: dy, useState: function () { return hh(Wa) }, useDebugValue: mh, useDeferredValue: function (o) { var l = mr(); return wy(l, tn.memoizedState, o) }, useTransition: function () { var o = hh(Wa)[0], l = mr().memoizedState; return [o, l] }, useMutableSource: iy, useSyncExternalStore: oy, useId: Sy, unstable_isNewReconciler: !1 }, LA = { readContext: vr, useCallback: yy, useContext: vr, useEffect: vh, useImperativeHandle: gy, useInsertionEffect: py, useLayoutEffect: vy, useMemo: xy, useReducer: ph, useRef: dy, useState: function () { return ph(Wa) }, useDebugValue: mh, useDeferredValue: function (o) { var l = mr(); return tn === null ? l.memoizedState = o : wy(l, tn.memoizedState, o) }, useTransition: function () { var o = ph(Wa)[0], l = mr().memoizedState; return [o, l] }, useMutableSource: iy, useSyncExternalStore: oy, useId: Sy, unstable_isNewReconciler: !1 }; function Br(o, l) { if (o && o.defaultProps) { l = ce({}, l), o = o.defaultProps; for (var d in o) l[d] === void 0 && (l[d] = o[d]); return l } return l } function gh(o, l, d, p) { l = o.memoizedState, d = d(p, l), d = d == null ? l : ce({}, l, d), o.memoizedState = d, o.lanes === 0 && (o.updateQueue.baseState = d) } var $u = { isMounted: function (o) { return (o = o._reactInternals) ? mn(o) === o : !1 }, enqueueSetState: function (o, l, d) { o = o._reactInternals; var p = Vn(), y = _i(o), w = yi(p, y); w.payload = l, d != null && (w.callback = d), l = Zi(o, w, y), l !== null && (Ir(l, o, y, p), qu(l, o, y)) }, enqueueReplaceState: function (o, l, d) { o = o._reactInternals; var p = Vn(), y = _i(o), w = yi(p, y); w.tag = 1, w.payload = l, d != null && (w.callback = d), l = Zi(o, w, y), l !== null && (Ir(l, o, y, p), qu(l, o, y)) }, enqueueForceUpdate: function (o, l) { o = o._reactInternals; var d = Vn(), p = _i(o), y = yi(d, p); y.tag = 2, l != null && (y.callback = l), l = Zi(o, y, p), l !== null && (Ir(l, o, p, d), qu(l, o, p)) } }; function Ty(o, l, d, p, y, w, T) { return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(p, w, T) : l.prototype && l.prototype.isPureReactComponent ? !Fa(d, p) || !Fa(y, w) : !0 } function ky(o, l, d) { var p = !1, y = qi, w = l.contextType; return typeof w == "object" && w !== null ? w = vr(w) : (y = Wn(l) ? ko : Cn.current, p = l.contextTypes, w = (p = p != null) ? ys(o, y) : qi), l = new l(d, w), o.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = $u, o.stateNode = l, l._reactInternals = o, p && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = y, o.__reactInternalMemoizedMaskedChildContext = w), l } function Ay(o, l, d, p) { o = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(d, p), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(d, p), l.state !== o && $u.enqueueReplaceState(l, l.state, null) } function yh(o, l, d, p) { var y = o.stateNode; y.props = d, y.state = o.memoizedState, y.refs = {}, ih(o); var w = l.contextType; typeof w == "object" && w !== null ? y.context = vr(w) : (w = Wn(l) ? ko : Cn.current, y.context = ys(o, w)), y.state = o.memoizedState, w = l.getDerivedStateFromProps, typeof w == "function" && (gh(o, l, w, d), y.state = o.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof y.getSnapshotBeforeUpdate == "function" || typeof y.UNSAFE_componentWillMount != "function" && typeof y.componentWillMount != "function" || (l = y.state, typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount(), l !== y.state && $u.enqueueReplaceState(y, y.state, null), Gu(o, d, y, p), y.state = o.memoizedState), typeof y.componentDidMount == "function" && (o.flags |= 4194308) } function ks(o, l) {
    try { var d = "", p = l; do d += Be(p), p = p.return; while (p); var y = d } catch (w) {
      y = `
Error generating stack: `+ w.message + `
`+ w.stack
    } return { value: o, source: l, stack: y, digest: null }
  } function xh(o, l, d) { return { value: o, source: null, stack: d ?? null, digest: l ?? null } } function wh(o, l) { try { console.error(l.value) } catch (d) { setTimeout(function () { throw d }) } } var jA = typeof WeakMap == "function" ? WeakMap : Map; function Ey(o, l, d) { d = yi(-1, d), d.tag = 3, d.payload = { element: null }; var p = l.value; return d.callback = function () { sc || (sc = !0, Nh = p), wh(o, l) }, d } function Fy(o, l, d) { d = yi(-1, d), d.tag = 3; var p = o.type.getDerivedStateFromError; if (typeof p == "function") { var y = l.value; d.payload = function () { return p(y) }, d.callback = function () { wh(o, l) } } var w = o.stateNode; return w !== null && typeof w.componentDidCatch == "function" && (d.callback = function () { wh(o, l), typeof p != "function" && (Qi === null ? Qi = new Set([this]) : Qi.add(this)); var T = l.stack; this.componentDidCatch(l.value, { componentStack: T !== null ? T : "" }) }), d } function Ry(o, l, d) { var p = o.pingCache; if (p === null) { p = o.pingCache = new jA; var y = new Set; p.set(l, y) } else y = p.get(l), y === void 0 && (y = new Set, p.set(l, y)); y.has(d) || (y.add(d), o = _A.bind(null, o, l, d), l.then(o, o)) } function Dy(o) { do { var l; if ((l = o.tag === 13) && (l = o.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l) return o; o = o.return } while (o !== null); return null } function Oy(o, l, d, p, y) { return o.mode & 1 ? (o.flags |= 65536, o.lanes = y, o) : (o === l ? o.flags |= 65536 : (o.flags |= 128, d.flags |= 131072, d.flags &= -52805, d.tag === 1 && (d.alternate === null ? d.tag = 17 : (l = yi(-1, 1), l.tag = 2, Zi(d, l, 1))), d.lanes |= 1), o) } var IA = N.ReactCurrentOwner, Kn = !1; function Mn(o, l, d, p) { l.child = o === null ? _g(l, null, d, p) : bs(l, o.child, d, p) } function My(o, l, d, p, y) { d = d.render; var w = l.ref; return Ps(l, y), p = fh(o, l, d, p, w, y), d = dh(), o !== null && !Kn ? (l.updateQueue = o.updateQueue, l.flags &= -2053, o.lanes &= ~y, xi(o, l, y)) : (Ot && d && Zd(l), l.flags |= 1, Mn(o, l, p, y), l.child) } function Vy(o, l, d, p, y) { if (o === null) { var w = d.type; return typeof w == "function" && !Wh(w) && w.defaultProps === void 0 && d.compare === null && d.defaultProps === void 0 ? (l.tag = 15, l.type = w, Ny(o, l, w, p, y)) : (o = dc(d.type, null, p, l, l.mode, y), o.ref = l.ref, o.return = l, l.child = o) } if (w = o.child, !(o.lanes & y)) { var T = w.memoizedProps; if (d = d.compare, d = d !== null ? d : Fa, d(T, p) && o.ref === l.ref) return xi(o, l, y) } return l.flags |= 1, o = eo(w, p), o.ref = l.ref, o.return = l, l.child = o } function Ny(o, l, d, p, y) { if (o !== null) { var w = o.memoizedProps; if (Fa(w, p) && o.ref === l.ref) if (Kn = !1, l.pendingProps = p = w, (o.lanes & y) !== 0) o.flags & 131072 && (Kn = !0); else return l.lanes = o.lanes, xi(o, l, y) } return Sh(o, l, d, p, y) } function By(o, l, d) { var p = l.pendingProps, y = p.children, w = o !== null ? o.memoizedState : null; if (p.mode === "hidden") if (!(l.mode & 1)) l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, At(Es, $n), $n |= d; else { if (!(d & 1073741824)) return o = w !== null ? w.baseLanes | d : d, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: o, cachePool: null, transitions: null }, l.updateQueue = null, At(Es, $n), $n |= o, null; l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, p = w !== null ? w.baseLanes : d, At(Es, $n), $n |= p } else w !== null ? (p = w.baseLanes | d, l.memoizedState = null) : p = d, At(Es, $n), $n |= p; return Mn(o, l, y, d), l.child } function Ly(o, l) { var d = l.ref; (o === null && d !== null || o !== null && o.ref !== d) && (l.flags |= 512, l.flags |= 2097152) } function Sh(o, l, d, p, y) { var w = Wn(d) ? ko : Cn.current; return w = ys(l, w), Ps(l, y), d = fh(o, l, d, p, w, y), p = dh(), o !== null && !Kn ? (l.updateQueue = o.updateQueue, l.flags &= -2053, o.lanes &= ~y, xi(o, l, y)) : (Ot && p && Zd(l), l.flags |= 1, Mn(o, l, d, y), l.child) } function jy(o, l, d, p, y) { if (Wn(d)) { var w = !0; Lu(l) } else w = !1; if (Ps(l, y), l.stateNode === null) tc(o, l), ky(l, d, p), yh(l, d, p, y), p = !0; else if (o === null) { var T = l.stateNode, L = l.memoizedProps; T.props = L; var U = T.context, te = d.contextType; typeof te == "object" && te !== null ? te = vr(te) : (te = Wn(d) ? ko : Cn.current, te = ys(l, te)); var ve = d.getDerivedStateFromProps, me = typeof ve == "function" || typeof T.getSnapshotBeforeUpdate == "function"; me || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (L !== p || U !== te) && Ay(l, T, p, te), Xi = !1; var he = l.memoizedState; T.state = he, Gu(l, p, T, y), U = l.memoizedState, L !== p || he !== U || Un.current || Xi ? (typeof ve == "function" && (gh(l, d, ve, p), U = l.memoizedState), (L = Xi || Ty(l, d, L, p, he, U, te)) ? (me || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount()), typeof T.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof T.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = p, l.memoizedState = U), T.props = p, T.state = U, T.context = te, p = L) : (typeof T.componentDidMount == "function" && (l.flags |= 4194308), p = !1) } else { T = l.stateNode, ey(o, l), L = l.memoizedProps, te = l.type === l.elementType ? L : Br(l.type, L), T.props = te, me = l.pendingProps, he = T.context, U = d.contextType, typeof U == "object" && U !== null ? U = vr(U) : (U = Wn(d) ? ko : Cn.current, U = ys(l, U)); var Te = d.getDerivedStateFromProps; (ve = typeof Te == "function" || typeof T.getSnapshotBeforeUpdate == "function") || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (L !== me || he !== U) && Ay(l, T, p, U), Xi = !1, he = l.memoizedState, T.state = he, Gu(l, p, T, y); var Oe = l.memoizedState; L !== me || he !== Oe || Un.current || Xi ? (typeof Te == "function" && (gh(l, d, Te, p), Oe = l.memoizedState), (te = Xi || Ty(l, d, te, p, he, Oe, U) || !1) ? (ve || typeof T.UNSAFE_componentWillUpdate != "function" && typeof T.componentWillUpdate != "function" || (typeof T.componentWillUpdate == "function" && T.componentWillUpdate(p, Oe, U), typeof T.UNSAFE_componentWillUpdate == "function" && T.UNSAFE_componentWillUpdate(p, Oe, U)), typeof T.componentDidUpdate == "function" && (l.flags |= 4), typeof T.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof T.componentDidUpdate != "function" || L === o.memoizedProps && he === o.memoizedState || (l.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || L === o.memoizedProps && he === o.memoizedState || (l.flags |= 1024), l.memoizedProps = p, l.memoizedState = Oe), T.props = p, T.state = Oe, T.context = U, p = te) : (typeof T.componentDidUpdate != "function" || L === o.memoizedProps && he === o.memoizedState || (l.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || L === o.memoizedProps && he === o.memoizedState || (l.flags |= 1024), p = !1) } return bh(o, l, d, p, w, y) } function bh(o, l, d, p, y, w) { Ly(o, l); var T = (l.flags & 128) !== 0; if (!p && !T) return y && Kg(l, d, !1), xi(o, l, w); p = l.stateNode, IA.current = l; var L = T && typeof d.getDerivedStateFromError != "function" ? null : p.render(); return l.flags |= 1, o !== null && T ? (l.child = bs(l, o.child, null, w), l.child = bs(l, null, L, w)) : Mn(o, l, L, w), l.memoizedState = p.state, y && Kg(l, d, !0), l.child } function Iy(o) { var l = o.stateNode; l.pendingContext ? Ug(o, l.pendingContext, l.pendingContext !== l.context) : l.context && Ug(o, l.context, !1), oh(o, l.containerInfo) } function zy(o, l, d, p, y) { return Ss(), _d(y), l.flags |= 256, Mn(o, l, d, p), l.child } var Ch = { dehydrated: null, treeContext: null, retryLane: 0 }; function Ph(o) { return { baseLanes: o, cachePool: null, transitions: null } } function Uy(o, l, d) { var p = l.pendingProps, y = Mt.current, w = !1, T = (l.flags & 128) !== 0, L; if ((L = T) || (L = o !== null && o.memoizedState === null ? !1 : (y & 2) !== 0), L ? (w = !0, l.flags &= -129) : (o === null || o.memoizedState !== null) && (y |= 1), At(Mt, y & 1), o === null) return Jd(l), o = l.memoizedState, o !== null && (o = o.dehydrated, o !== null) ? (l.mode & 1 ? o.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (T = p.children, o = p.fallback, w ? (p = l.mode, w = l.child, T = { mode: "hidden", children: T }, !(p & 1) && w !== null ? (w.childLanes = 0, w.pendingProps = T) : w = hc(T, p, 0, null), o = Bo(o, p, d, null), w.return = l, o.return = l, w.sibling = o, l.child = w, l.child.memoizedState = Ph(d), l.memoizedState = Ch, o) : Th(l, T)); if (y = o.memoizedState, y !== null && (L = y.dehydrated, L !== null)) return zA(o, l, T, p, L, y, d); if (w) { w = p.fallback, T = l.mode, y = o.child, L = y.sibling; var U = { mode: "hidden", children: p.children }; return !(T & 1) && l.child !== y ? (p = l.child, p.childLanes = 0, p.pendingProps = U, l.deletions = null) : (p = eo(y, U), p.subtreeFlags = y.subtreeFlags & 14680064), L !== null ? w = eo(L, w) : (w = Bo(w, T, d, null), w.flags |= 2), w.return = l, p.return = l, p.sibling = w, l.child = p, p = w, w = l.child, T = o.child.memoizedState, T = T === null ? Ph(d) : { baseLanes: T.baseLanes | d, cachePool: null, transitions: T.transitions }, w.memoizedState = T, w.childLanes = o.childLanes & ~d, l.memoizedState = Ch, p } return w = o.child, o = w.sibling, p = eo(w, { mode: "visible", children: p.children }), !(l.mode & 1) && (p.lanes = d), p.return = l, p.sibling = null, o !== null && (d = l.deletions, d === null ? (l.deletions = [o], l.flags |= 16) : d.push(o)), l.child = p, l.memoizedState = null, p } function Th(o, l) { return l = hc({ mode: "visible", children: l }, o.mode, 0, null), l.return = o, o.child = l } function ec(o, l, d, p) { return p !== null && _d(p), bs(l, o.child, null, d), o = Th(l, l.pendingProps.children), o.flags |= 2, l.memoizedState = null, o } function zA(o, l, d, p, y, w, T) { if (d) return l.flags & 256 ? (l.flags &= -257, p = xh(Error(n(422))), ec(o, l, T, p)) : l.memoizedState !== null ? (l.child = o.child, l.flags |= 128, null) : (w = p.fallback, y = l.mode, p = hc({ mode: "visible", children: p.children }, y, 0, null), w = Bo(w, y, T, null), w.flags |= 2, p.return = l, w.return = l, p.sibling = w, l.child = p, l.mode & 1 && bs(l, o.child, null, T), l.child.memoizedState = Ph(T), l.memoizedState = Ch, w); if (!(l.mode & 1)) return ec(o, l, T, null); if (y.data === "$!") { if (p = y.nextSibling && y.nextSibling.dataset, p) var L = p.dgst; return p = L, w = Error(n(419)), p = xh(w, p, void 0), ec(o, l, T, p) } if (L = (T & o.childLanes) !== 0, Kn || L) { if (p = fn, p !== null) { switch (T & -T) { case 4: y = 2; break; case 16: y = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: y = 32; break; case 536870912: y = 268435456; break; default: y = 0 }y = y & (p.suspendedLanes | T) ? 0 : y, y !== 0 && y !== w.retryLane && (w.retryLane = y, gi(o, y), Ir(p, o, y, -1)) } return Uh(), p = xh(Error(n(421))), ec(o, l, T, p) } return y.data === "$?" ? (l.flags |= 128, l.child = o.child, l = $A.bind(null, o), y._reactRetry = l, null) : (o = w.treeContext, _n = Ki(y.nextSibling), Jn = l, Ot = !0, Nr = null, o !== null && (hr[pr++] = vi, hr[pr++] = mi, hr[pr++] = Ao, vi = o.id, mi = o.overflow, Ao = l), l = Th(l, p.children), l.flags |= 4096, l) } function Wy(o, l, d) { o.lanes |= l; var p = o.alternate; p !== null && (p.lanes |= l), nh(o.return, l, d) } function kh(o, l, d, p, y) { var w = o.memoizedState; w === null ? o.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: p, tail: d, tailMode: y } : (w.isBackwards = l, w.rendering = null, w.renderingStartTime = 0, w.last = p, w.tail = d, w.tailMode = y) } function Ky(o, l, d) { var p = l.pendingProps, y = p.revealOrder, w = p.tail; if (Mn(o, l, p.children, d), p = Mt.current, p & 2) p = p & 1 | 2, l.flags |= 128; else { if (o !== null && o.flags & 128) e: for (o = l.child; o !== null;) { if (o.tag === 13) o.memoizedState !== null && Wy(o, d, l); else if (o.tag === 19) Wy(o, d, l); else if (o.child !== null) { o.child.return = o, o = o.child; continue } if (o === l) break e; for (; o.sibling === null;) { if (o.return === null || o.return === l) break e; o = o.return } o.sibling.return = o.return, o = o.sibling } p &= 1 } if (At(Mt, p), !(l.mode & 1)) l.memoizedState = null; else switch (y) { case "forwards": for (d = l.child, y = null; d !== null;)o = d.alternate, o !== null && Xu(o) === null && (y = d), d = d.sibling; d = y, d === null ? (y = l.child, l.child = null) : (y = d.sibling, d.sibling = null), kh(l, !1, y, d, w); break; case "backwards": for (d = null, y = l.child, l.child = null; y !== null;) { if (o = y.alternate, o !== null && Xu(o) === null) { l.child = y; break } o = y.sibling, y.sibling = d, d = y, y = o } kh(l, !0, d, null, w); break; case "together": kh(l, !1, null, null, void 0); break; default: l.memoizedState = null }return l.child } function tc(o, l) { !(l.mode & 1) && o !== null && (o.alternate = null, l.alternate = null, l.flags |= 2) } function xi(o, l, d) { if (o !== null && (l.dependencies = o.dependencies), Oo |= l.lanes, !(d & l.childLanes)) return null; if (o !== null && l.child !== o.child) throw Error(n(153)); if (l.child !== null) { for (o = l.child, d = eo(o, o.pendingProps), l.child = d, d.return = l; o.sibling !== null;)o = o.sibling, d = d.sibling = eo(o, o.pendingProps), d.return = l; d.sibling = null } return l.child } function UA(o, l, d) { switch (l.tag) { case 3: Iy(l), Ss(); break; case 5: ry(l); break; case 1: Wn(l.type) && Lu(l); break; case 4: oh(l, l.stateNode.containerInfo); break; case 10: var p = l.type._context, y = l.memoizedProps.value; At(Ku, p._currentValue), p._currentValue = y; break; case 13: if (p = l.memoizedState, p !== null) return p.dehydrated !== null ? (At(Mt, Mt.current & 1), l.flags |= 128, null) : d & l.child.childLanes ? Uy(o, l, d) : (At(Mt, Mt.current & 1), o = xi(o, l, d), o !== null ? o.sibling : null); At(Mt, Mt.current & 1); break; case 19: if (p = (d & l.childLanes) !== 0, o.flags & 128) { if (p) return Ky(o, l, d); l.flags |= 128 } if (y = l.memoizedState, y !== null && (y.rendering = null, y.tail = null, y.lastEffect = null), At(Mt, Mt.current), p) break; return null; case 22: case 23: return l.lanes = 0, By(o, l, d) }return xi(o, l, d) } var Hy, Ah, qy, Gy; Hy = function (o, l) { for (var d = l.child; d !== null;) { if (d.tag === 5 || d.tag === 6) o.appendChild(d.stateNode); else if (d.tag !== 4 && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === l) break; for (; d.sibling === null;) { if (d.return === null || d.return === l) return; d = d.return } d.sibling.return = d.return, d = d.sibling } }, Ah = function () { }, qy = function (o, l, d, p) { var y = o.memoizedProps; if (y !== p) { o = l.stateNode, Ro(Qr.current); var w = null; switch (d) { case "input": y = jn(o, y), p = jn(o, p), w = []; break; case "select": y = ce({}, y, { value: void 0 }), p = ce({}, p, { value: void 0 }), w = []; break; case "textarea": y = bn(o, y), p = bn(o, p), w = []; break; default: typeof y.onClick != "function" && typeof p.onClick == "function" && (o.onclick = Vu) }oe(d, p); var T; d = null; for (te in y) if (!p.hasOwnProperty(te) && y.hasOwnProperty(te) && y[te] != null) if (te === "style") { var L = y[te]; for (T in L) L.hasOwnProperty(T) && (d || (d = {}), d[T] = "") } else te !== "dangerouslySetInnerHTML" && te !== "children" && te !== "suppressContentEditableWarning" && te !== "suppressHydrationWarning" && te !== "autoFocus" && (i.hasOwnProperty(te) ? w || (w = []) : (w = w || []).push(te, null)); for (te in p) { var U = p[te]; if (L = y != null ? y[te] : void 0, p.hasOwnProperty(te) && U !== L && (U != null || L != null)) if (te === "style") if (L) { for (T in L) !L.hasOwnProperty(T) || U && U.hasOwnProperty(T) || (d || (d = {}), d[T] = ""); for (T in U) U.hasOwnProperty(T) && L[T] !== U[T] && (d || (d = {}), d[T] = U[T]) } else d || (w || (w = []), w.push(te, d)), d = U; else te === "dangerouslySetInnerHTML" ? (U = U ? U.__html : void 0, L = L ? L.__html : void 0, U != null && L !== U && (w = w || []).push(te, U)) : te === "children" ? typeof U != "string" && typeof U != "number" || (w = w || []).push(te, "" + U) : te !== "suppressContentEditableWarning" && te !== "suppressHydrationWarning" && (i.hasOwnProperty(te) ? (U != null && te === "onScroll" && Ft("scroll", o), w || L === U || (w = [])) : (w = w || []).push(te, U)) } d && (w = w || []).push("style", d); var te = w; (l.updateQueue = te) && (l.flags |= 4) } }, Gy = function (o, l, d, p) { d !== p && (l.flags |= 4) }; function Ha(o, l) { if (!Ot) switch (o.tailMode) { case "hidden": l = o.tail; for (var d = null; l !== null;)l.alternate !== null && (d = l), l = l.sibling; d === null ? o.tail = null : d.sibling = null; break; case "collapsed": d = o.tail; for (var p = null; d !== null;)d.alternate !== null && (p = d), d = d.sibling; p === null ? l || o.tail === null ? o.tail = null : o.tail.sibling = null : p.sibling = null } } function Tn(o) { var l = o.alternate !== null && o.alternate.child === o.child, d = 0, p = 0; if (l) for (var y = o.child; y !== null;)d |= y.lanes | y.childLanes, p |= y.subtreeFlags & 14680064, p |= y.flags & 14680064, y.return = o, y = y.sibling; else for (y = o.child; y !== null;)d |= y.lanes | y.childLanes, p |= y.subtreeFlags, p |= y.flags, y.return = o, y = y.sibling; return o.subtreeFlags |= p, o.childLanes = d, l } function WA(o, l, d) { var p = l.pendingProps; switch (Yd(l), l.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Tn(l), null; case 1: return Wn(l.type) && Bu(), Tn(l), null; case 3: return p = l.stateNode, Ts(), Rt(Un), Rt(Cn), lh(), p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null), (o === null || o.child === null) && (Uu(l) ? l.flags |= 4 : o === null || o.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, Nr !== null && (jh(Nr), Nr = null))), Ah(o, l), Tn(l), null; case 5: sh(l); var y = Ro(Ia.current); if (d = l.type, o !== null && l.stateNode != null) qy(o, l, d, p, y), o.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152); else { if (!p) { if (l.stateNode === null) throw Error(n(166)); return Tn(l), null } if (o = Ro(Qr.current), Uu(l)) { p = l.stateNode, d = l.type; var w = l.memoizedProps; switch (p[Yr] = l, p[Va] = w, o = (l.mode & 1) !== 0, d) { case "dialog": Ft("cancel", p), Ft("close", p); break; case "iframe": case "object": case "embed": Ft("load", p); break; case "video": case "audio": for (y = 0; y < Da.length; y++)Ft(Da[y], p); break; case "source": Ft("error", p); break; case "img": case "image": case "link": Ft("error", p), Ft("load", p); break; case "details": Ft("toggle", p); break; case "input": vn(p, w), Ft("invalid", p); break; case "select": p._wrapperState = { wasMultiple: !!w.multiple }, Ft("invalid", p); break; case "textarea": ci(p, w), Ft("invalid", p) }oe(d, w), y = null; for (var T in w) if (w.hasOwnProperty(T)) { var L = w[T]; T === "children" ? typeof L == "string" ? p.textContent !== L && (w.suppressHydrationWarning !== !0 && Mu(p.textContent, L, o), y = ["children", L]) : typeof L == "number" && p.textContent !== "" + L && (w.suppressHydrationWarning !== !0 && Mu(p.textContent, L, o), y = ["children", "" + L]) : i.hasOwnProperty(T) && L != null && T === "onScroll" && Ft("scroll", p) } switch (d) { case "input": Qt(p), it(p, w, !0); break; case "textarea": Qt(p), In(p); break; case "select": case "option": break; default: typeof w.onClick == "function" && (p.onclick = Vu) }p = y, l.updateQueue = p, p !== null && (l.flags |= 4) } else { T = y.nodeType === 9 ? y : y.ownerDocument, o === "http://www.w3.org/1999/xhtml" && (o = fi(d)), o === "http://www.w3.org/1999/xhtml" ? d === "script" ? (o = T.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild)) : typeof p.is == "string" ? o = T.createElement(d, { is: p.is }) : (o = T.createElement(d), d === "select" && (T = o, p.multiple ? T.multiple = !0 : p.size && (T.size = p.size))) : o = T.createElementNS(o, d), o[Yr] = l, o[Va] = p, Hy(o, l, !1, !1), l.stateNode = o; e: { switch (T = k(d, p), d) { case "dialog": Ft("cancel", o), Ft("close", o), y = p; break; case "iframe": case "object": case "embed": Ft("load", o), y = p; break; case "video": case "audio": for (y = 0; y < Da.length; y++)Ft(Da[y], o); y = p; break; case "source": Ft("error", o), y = p; break; case "img": case "image": case "link": Ft("error", o), Ft("load", o), y = p; break; case "details": Ft("toggle", o), y = p; break; case "input": vn(o, p), y = jn(o, p), Ft("invalid", o); break; case "option": y = p; break; case "select": o._wrapperState = { wasMultiple: !!p.multiple }, y = ce({}, p, { value: void 0 }), Ft("invalid", o); break; case "textarea": ci(o, p), y = bn(o, p), Ft("invalid", o); break; default: y = p }oe(d, y), L = y; for (w in L) if (L.hasOwnProperty(w)) { var U = L[w]; w === "style" ? ke(o, U) : w === "dangerouslySetInnerHTML" ? (U = U ? U.__html : void 0, U != null && Zn(o, U)) : w === "children" ? typeof U == "string" ? (d !== "textarea" || U !== "") && dr(o, U) : typeof U == "number" && dr(o, "" + U) : w !== "suppressContentEditableWarning" && w !== "suppressHydrationWarning" && w !== "autoFocus" && (i.hasOwnProperty(w) ? U != null && w === "onScroll" && Ft("scroll", o) : U != null && A(o, w, U, T)) } switch (d) { case "input": Qt(o), it(o, p, !1); break; case "textarea": Qt(o), In(o); break; case "option": p.value != null && o.setAttribute("value", "" + be(p.value)); break; case "select": o.multiple = !!p.multiple, w = p.value, w != null ? Dn(o, !!p.multiple, w, !1) : p.defaultValue != null && Dn(o, !!p.multiple, p.defaultValue, !0); break; default: typeof y.onClick == "function" && (o.onclick = Vu) }switch (d) { case "button": case "input": case "select": case "textarea": p = !!p.autoFocus; break e; case "img": p = !0; break e; default: p = !1 } } p && (l.flags |= 4) } l.ref !== null && (l.flags |= 512, l.flags |= 2097152) } return Tn(l), null; case 6: if (o && l.stateNode != null) Gy(o, l, o.memoizedProps, p); else { if (typeof p != "string" && l.stateNode === null) throw Error(n(166)); if (d = Ro(Ia.current), Ro(Qr.current), Uu(l)) { if (p = l.stateNode, d = l.memoizedProps, p[Yr] = l, (w = p.nodeValue !== d) && (o = Jn, o !== null)) switch (o.tag) { case 3: Mu(p.nodeValue, d, (o.mode & 1) !== 0); break; case 5: o.memoizedProps.suppressHydrationWarning !== !0 && Mu(p.nodeValue, d, (o.mode & 1) !== 0) }w && (l.flags |= 4) } else p = (d.nodeType === 9 ? d : d.ownerDocument).createTextNode(p), p[Yr] = l, l.stateNode = p } return Tn(l), null; case 13: if (Rt(Mt), p = l.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) { if (Ot && _n !== null && l.mode & 1 && !(l.flags & 128)) Yg(), Ss(), l.flags |= 98560, w = !1; else if (w = Uu(l), p !== null && p.dehydrated !== null) { if (o === null) { if (!w) throw Error(n(318)); if (w = l.memoizedState, w = w !== null ? w.dehydrated : null, !w) throw Error(n(317)); w[Yr] = l } else Ss(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4; Tn(l), w = !1 } else Nr !== null && (jh(Nr), Nr = null), w = !0; if (!w) return l.flags & 65536 ? l : null } return l.flags & 128 ? (l.lanes = d, l) : (p = p !== null, p !== (o !== null && o.memoizedState !== null) && p && (l.child.flags |= 8192, l.mode & 1 && (o === null || Mt.current & 1 ? nn === 0 && (nn = 3) : Uh())), l.updateQueue !== null && (l.flags |= 4), Tn(l), null); case 4: return Ts(), Ah(o, l), o === null && Oa(l.stateNode.containerInfo), Tn(l), null; case 10: return th(l.type._context), Tn(l), null; case 17: return Wn(l.type) && Bu(), Tn(l), null; case 19: if (Rt(Mt), w = l.memoizedState, w === null) return Tn(l), null; if (p = (l.flags & 128) !== 0, T = w.rendering, T === null) if (p) Ha(w, !1); else { if (nn !== 0 || o !== null && o.flags & 128) for (o = l.child; o !== null;) { if (T = Xu(o), T !== null) { for (l.flags |= 128, Ha(w, !1), p = T.updateQueue, p !== null && (l.updateQueue = p, l.flags |= 4), l.subtreeFlags = 0, p = d, d = l.child; d !== null;)w = d, o = p, w.flags &= 14680066, T = w.alternate, T === null ? (w.childLanes = 0, w.lanes = o, w.child = null, w.subtreeFlags = 0, w.memoizedProps = null, w.memoizedState = null, w.updateQueue = null, w.dependencies = null, w.stateNode = null) : (w.childLanes = T.childLanes, w.lanes = T.lanes, w.child = T.child, w.subtreeFlags = 0, w.deletions = null, w.memoizedProps = T.memoizedProps, w.memoizedState = T.memoizedState, w.updateQueue = T.updateQueue, w.type = T.type, o = T.dependencies, w.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }), d = d.sibling; return At(Mt, Mt.current & 1 | 2), l.child } o = o.sibling } w.tail !== null && Gt() > Fs && (l.flags |= 128, p = !0, Ha(w, !1), l.lanes = 4194304) } else { if (!p) if (o = Xu(T), o !== null) { if (l.flags |= 128, p = !0, d = o.updateQueue, d !== null && (l.updateQueue = d, l.flags |= 4), Ha(w, !0), w.tail === null && w.tailMode === "hidden" && !T.alternate && !Ot) return Tn(l), null } else 2 * Gt() - w.renderingStartTime > Fs && d !== 1073741824 && (l.flags |= 128, p = !0, Ha(w, !1), l.lanes = 4194304); w.isBackwards ? (T.sibling = l.child, l.child = T) : (d = w.last, d !== null ? d.sibling = T : l.child = T, w.last = T) } return w.tail !== null ? (l = w.tail, w.rendering = l, w.tail = l.sibling, w.renderingStartTime = Gt(), l.sibling = null, d = Mt.current, At(Mt, p ? d & 1 | 2 : d & 1), l) : (Tn(l), null); case 22: case 23: return zh(), p = l.memoizedState !== null, o !== null && o.memoizedState !== null !== p && (l.flags |= 8192), p && l.mode & 1 ? $n & 1073741824 && (Tn(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : Tn(l), null; case 24: return null; case 25: return null }throw Error(n(156, l.tag)) } function KA(o, l) { switch (Yd(l), l.tag) { case 1: return Wn(l.type) && Bu(), o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null; case 3: return Ts(), Rt(Un), Rt(Cn), lh(), o = l.flags, o & 65536 && !(o & 128) ? (l.flags = o & -65537 | 128, l) : null; case 5: return sh(l), null; case 13: if (Rt(Mt), o = l.memoizedState, o !== null && o.dehydrated !== null) { if (l.alternate === null) throw Error(n(340)); Ss() } return o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null; case 19: return Rt(Mt), null; case 4: return Ts(), null; case 10: return th(l.type._context), null; case 22: case 23: return zh(), null; case 24: return null; default: return null } } var nc = !1, kn = !1, HA = typeof WeakSet == "function" ? WeakSet : Set, Re = null; function As(o, l) { var d = o.ref; if (d !== null) if (typeof d == "function") try { d(null) } catch (p) { zt(o, l, p) } else d.current = null } function Eh(o, l, d) { try { d() } catch (p) { zt(o, l, p) } } var Xy = !1; function qA(o, l) { if (zd = bu, o = Tg(), Od(o)) { if ("selectionStart" in o) var d = { start: o.selectionStart, end: o.selectionEnd }; else e: { d = (d = o.ownerDocument) && d.defaultView || window; var p = d.getSelection && d.getSelection(); if (p && p.rangeCount !== 0) { d = p.anchorNode; var y = p.anchorOffset, w = p.focusNode; p = p.focusOffset; try { d.nodeType, w.nodeType } catch { d = null; break e } var T = 0, L = -1, U = -1, te = 0, ve = 0, me = o, he = null; t: for (; ;) { for (var Te; me !== d || y !== 0 && me.nodeType !== 3 || (L = T + y), me !== w || p !== 0 && me.nodeType !== 3 || (U = T + p), me.nodeType === 3 && (T += me.nodeValue.length), (Te = me.firstChild) !== null;)he = me, me = Te; for (; ;) { if (me === o) break t; if (he === d && ++te === y && (L = T), he === w && ++ve === p && (U = T), (Te = me.nextSibling) !== null) break; me = he, he = me.parentNode } me = Te } d = L === -1 || U === -1 ? null : { start: L, end: U } } else d = null } d = d || { start: 0, end: 0 } } else d = null; for (Ud = { focusedElem: o, selectionRange: d }, bu = !1, Re = l; Re !== null;)if (l = Re, o = l.child, (l.subtreeFlags & 1028) !== 0 && o !== null) o.return = l, Re = o; else for (; Re !== null;) { l = Re; try { var Oe = l.alternate; if (l.flags & 1024) switch (l.tag) { case 0: case 11: case 15: break; case 1: if (Oe !== null) { var Me = Oe.memoizedProps, Xt = Oe.memoizedState, X = l.stateNode, K = X.getSnapshotBeforeUpdate(l.elementType === l.type ? Me : Br(l.type, Me), Xt); X.__reactInternalSnapshotBeforeUpdate = K } break; case 3: var J = l.stateNode.containerInfo; J.nodeType === 1 ? J.textContent = "" : J.nodeType === 9 && J.documentElement && J.removeChild(J.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(n(163)) } } catch (Se) { zt(l, l.return, Se) } if (o = l.sibling, o !== null) { o.return = l.return, Re = o; break } Re = l.return } return Oe = Xy, Xy = !1, Oe } function qa(o, l, d) { var p = l.updateQueue; if (p = p !== null ? p.lastEffect : null, p !== null) { var y = p = p.next; do { if ((y.tag & o) === o) { var w = y.destroy; y.destroy = void 0, w !== void 0 && Eh(l, d, w) } y = y.next } while (y !== p) } } function rc(o, l) { if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) { var d = l = l.next; do { if ((d.tag & o) === o) { var p = d.create; d.destroy = p() } d = d.next } while (d !== l) } } function Fh(o) { var l = o.ref; if (l !== null) { var d = o.stateNode; switch (o.tag) { case 5: o = d; break; default: o = d }typeof l == "function" ? l(o) : l.current = o } } function Zy(o) { var l = o.alternate; l !== null && (o.alternate = null, Zy(l)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (l = o.stateNode, l !== null && (delete l[Yr], delete l[Va], delete l[qd], delete l[AA], delete l[EA])), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null } function Yy(o) { return o.tag === 5 || o.tag === 3 || o.tag === 4 } function Qy(o) { e: for (; ;) { for (; o.sibling === null;) { if (o.return === null || Yy(o.return)) return null; o = o.return } for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18;) { if (o.flags & 2 || o.child === null || o.tag === 4) continue e; o.child.return = o, o = o.child } if (!(o.flags & 2)) return o.stateNode } } function Rh(o, l, d) { var p = o.tag; if (p === 5 || p === 6) o = o.stateNode, l ? d.nodeType === 8 ? d.parentNode.insertBefore(o, l) : d.insertBefore(o, l) : (d.nodeType === 8 ? (l = d.parentNode, l.insertBefore(o, d)) : (l = d, l.appendChild(o)), d = d._reactRootContainer, d != null || l.onclick !== null || (l.onclick = Vu)); else if (p !== 4 && (o = o.child, o !== null)) for (Rh(o, l, d), o = o.sibling; o !== null;)Rh(o, l, d), o = o.sibling } function Dh(o, l, d) { var p = o.tag; if (p === 5 || p === 6) o = o.stateNode, l ? d.insertBefore(o, l) : d.appendChild(o); else if (p !== 4 && (o = o.child, o !== null)) for (Dh(o, l, d), o = o.sibling; o !== null;)Dh(o, l, d), o = o.sibling } var gn = null, Lr = !1; function Yi(o, l, d) { for (d = d.child; d !== null;)Jy(o, l, d), d = d.sibling } function Jy(o, l, d) { if (Zr && typeof Zr.onCommitFiberUnmount == "function") try { Zr.onCommitFiberUnmount(mu, d) } catch { } switch (d.tag) { case 5: kn || As(d, l); case 6: var p = gn, y = Lr; gn = null, Yi(o, l, d), gn = p, Lr = y, gn !== null && (Lr ? (o = gn, d = d.stateNode, o.nodeType === 8 ? o.parentNode.removeChild(d) : o.removeChild(d)) : gn.removeChild(d.stateNode)); break; case 18: gn !== null && (Lr ? (o = gn, d = d.stateNode, o.nodeType === 8 ? Hd(o.parentNode, d) : o.nodeType === 1 && Hd(o, d), Ca(o)) : Hd(gn, d.stateNode)); break; case 4: p = gn, y = Lr, gn = d.stateNode.containerInfo, Lr = !0, Yi(o, l, d), gn = p, Lr = y; break; case 0: case 11: case 14: case 15: if (!kn && (p = d.updateQueue, p !== null && (p = p.lastEffect, p !== null))) { y = p = p.next; do { var w = y, T = w.destroy; w = w.tag, T !== void 0 && (w & 2 || w & 4) && Eh(d, l, T), y = y.next } while (y !== p) } Yi(o, l, d); break; case 1: if (!kn && (As(d, l), p = d.stateNode, typeof p.componentWillUnmount == "function")) try { p.props = d.memoizedProps, p.state = d.memoizedState, p.componentWillUnmount() } catch (L) { zt(d, l, L) } Yi(o, l, d); break; case 21: Yi(o, l, d); break; case 22: d.mode & 1 ? (kn = (p = kn) || d.memoizedState !== null, Yi(o, l, d), kn = p) : Yi(o, l, d); break; default: Yi(o, l, d) } } function _y(o) { var l = o.updateQueue; if (l !== null) { o.updateQueue = null; var d = o.stateNode; d === null && (d = o.stateNode = new HA), l.forEach(function (p) { var y = eE.bind(null, o, p); d.has(p) || (d.add(p), p.then(y, y)) }) } } function jr(o, l) { var d = l.deletions; if (d !== null) for (var p = 0; p < d.length; p++) { var y = d[p]; try { var w = o, T = l, L = T; e: for (; L !== null;) { switch (L.tag) { case 5: gn = L.stateNode, Lr = !1; break e; case 3: gn = L.stateNode.containerInfo, Lr = !0; break e; case 4: gn = L.stateNode.containerInfo, Lr = !0; break e }L = L.return } if (gn === null) throw Error(n(160)); Jy(w, T, y), gn = null, Lr = !1; var U = y.alternate; U !== null && (U.return = null), y.return = null } catch (te) { zt(y, l, te) } } if (l.subtreeFlags & 12854) for (l = l.child; l !== null;)$y(l, o), l = l.sibling } function $y(o, l) { var d = o.alternate, p = o.flags; switch (o.tag) { case 0: case 11: case 14: case 15: if (jr(l, o), _r(o), p & 4) { try { qa(3, o, o.return), rc(3, o) } catch (Me) { zt(o, o.return, Me) } try { qa(5, o, o.return) } catch (Me) { zt(o, o.return, Me) } } break; case 1: jr(l, o), _r(o), p & 512 && d !== null && As(d, d.return); break; case 5: if (jr(l, o), _r(o), p & 512 && d !== null && As(d, d.return), o.flags & 32) { var y = o.stateNode; try { dr(y, "") } catch (Me) { zt(o, o.return, Me) } } if (p & 4 && (y = o.stateNode, y != null)) { var w = o.memoizedProps, T = d !== null ? d.memoizedProps : w, L = o.type, U = o.updateQueue; if (o.updateQueue = null, U !== null) try { L === "input" && w.type === "radio" && w.name != null && un(y, w), k(L, T); var te = k(L, w); for (T = 0; T < U.length; T += 2) { var ve = U[T], me = U[T + 1]; ve === "style" ? ke(y, me) : ve === "dangerouslySetInnerHTML" ? Zn(y, me) : ve === "children" ? dr(y, me) : A(y, ve, me, te) } switch (L) { case "input": Ct(y, w); break; case "textarea": Or(y, w); break; case "select": var he = y._wrapperState.wasMultiple; y._wrapperState.wasMultiple = !!w.multiple; var Te = w.value; Te != null ? Dn(y, !!w.multiple, Te, !1) : he !== !!w.multiple && (w.defaultValue != null ? Dn(y, !!w.multiple, w.defaultValue, !0) : Dn(y, !!w.multiple, w.multiple ? [] : "", !1)) }y[Va] = w } catch (Me) { zt(o, o.return, Me) } } break; case 6: if (jr(l, o), _r(o), p & 4) { if (o.stateNode === null) throw Error(n(162)); y = o.stateNode, w = o.memoizedProps; try { y.nodeValue = w } catch (Me) { zt(o, o.return, Me) } } break; case 3: if (jr(l, o), _r(o), p & 4 && d !== null && d.memoizedState.isDehydrated) try { Ca(l.containerInfo) } catch (Me) { zt(o, o.return, Me) } break; case 4: jr(l, o), _r(o); break; case 13: jr(l, o), _r(o), y = o.child, y.flags & 8192 && (w = y.memoizedState !== null, y.stateNode.isHidden = w, !w || y.alternate !== null && y.alternate.memoizedState !== null || (Vh = Gt())), p & 4 && _y(o); break; case 22: if (ve = d !== null && d.memoizedState !== null, o.mode & 1 ? (kn = (te = kn) || ve, jr(l, o), kn = te) : jr(l, o), _r(o), p & 8192) { if (te = o.memoizedState !== null, (o.stateNode.isHidden = te) && !ve && o.mode & 1) for (Re = o, ve = o.child; ve !== null;) { for (me = Re = ve; Re !== null;) { switch (he = Re, Te = he.child, he.tag) { case 0: case 11: case 14: case 15: qa(4, he, he.return); break; case 1: As(he, he.return); var Oe = he.stateNode; if (typeof Oe.componentWillUnmount == "function") { p = he, d = he.return; try { l = p, Oe.props = l.memoizedProps, Oe.state = l.memoizedState, Oe.componentWillUnmount() } catch (Me) { zt(p, d, Me) } } break; case 5: As(he, he.return); break; case 22: if (he.memoizedState !== null) { n1(me); continue } }Te !== null ? (Te.return = he, Re = Te) : n1(me) } ve = ve.sibling } e: for (ve = null, me = o; ;) { if (me.tag === 5) { if (ve === null) { ve = me; try { y = me.stateNode, te ? (w = y.style, typeof w.setProperty == "function" ? w.setProperty("display", "none", "important") : w.display = "none") : (L = me.stateNode, U = me.memoizedProps.style, T = U != null && U.hasOwnProperty("display") ? U.display : null, L.style.display = ge("display", T)) } catch (Me) { zt(o, o.return, Me) } } } else if (me.tag === 6) { if (ve === null) try { me.stateNode.nodeValue = te ? "" : me.memoizedProps } catch (Me) { zt(o, o.return, Me) } } else if ((me.tag !== 22 && me.tag !== 23 || me.memoizedState === null || me === o) && me.child !== null) { me.child.return = me, me = me.child; continue } if (me === o) break e; for (; me.sibling === null;) { if (me.return === null || me.return === o) break e; ve === me && (ve = null), me = me.return } ve === me && (ve = null), me.sibling.return = me.return, me = me.sibling } } break; case 19: jr(l, o), _r(o), p & 4 && _y(o); break; case 21: break; default: jr(l, o), _r(o) } } function _r(o) { var l = o.flags; if (l & 2) { try { e: { for (var d = o.return; d !== null;) { if (Yy(d)) { var p = d; break e } d = d.return } throw Error(n(160)) } switch (p.tag) { case 5: var y = p.stateNode; p.flags & 32 && (dr(y, ""), p.flags &= -33); var w = Qy(o); Dh(o, w, y); break; case 3: case 4: var T = p.stateNode.containerInfo, L = Qy(o); Rh(o, L, T); break; default: throw Error(n(161)) } } catch (U) { zt(o, o.return, U) } o.flags &= -3 } l & 4096 && (o.flags &= -4097) } function GA(o, l, d) { Re = o, e1(o) } function e1(o, l, d) { for (var p = (o.mode & 1) !== 0; Re !== null;) { var y = Re, w = y.child; if (y.tag === 22 && p) { var T = y.memoizedState !== null || nc; if (!T) { var L = y.alternate, U = L !== null && L.memoizedState !== null || kn; L = nc; var te = kn; if (nc = T, (kn = U) && !te) for (Re = y; Re !== null;)T = Re, U = T.child, T.tag === 22 && T.memoizedState !== null ? r1(y) : U !== null ? (U.return = T, Re = U) : r1(y); for (; w !== null;)Re = w, e1(w), w = w.sibling; Re = y, nc = L, kn = te } t1(o) } else y.subtreeFlags & 8772 && w !== null ? (w.return = y, Re = w) : t1(o) } } function t1(o) { for (; Re !== null;) { var l = Re; if (l.flags & 8772) { var d = l.alternate; try { if (l.flags & 8772) switch (l.tag) { case 0: case 11: case 15: kn || rc(5, l); break; case 1: var p = l.stateNode; if (l.flags & 4 && !kn) if (d === null) p.componentDidMount(); else { var y = l.elementType === l.type ? d.memoizedProps : Br(l.type, d.memoizedProps); p.componentDidUpdate(y, d.memoizedState, p.__reactInternalSnapshotBeforeUpdate) } var w = l.updateQueue; w !== null && ny(l, w, p); break; case 3: var T = l.updateQueue; if (T !== null) { if (d = null, l.child !== null) switch (l.child.tag) { case 5: d = l.child.stateNode; break; case 1: d = l.child.stateNode }ny(l, T, d) } break; case 5: var L = l.stateNode; if (d === null && l.flags & 4) { d = L; var U = l.memoizedProps; switch (l.type) { case "button": case "input": case "select": case "textarea": U.autoFocus && d.focus(); break; case "img": U.src && (d.src = U.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (l.memoizedState === null) { var te = l.alternate; if (te !== null) { var ve = te.memoizedState; if (ve !== null) { var me = ve.dehydrated; me !== null && Ca(me) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(n(163)) }kn || l.flags & 512 && Fh(l) } catch (he) { zt(l, l.return, he) } } if (l === o) { Re = null; break } if (d = l.sibling, d !== null) { d.return = l.return, Re = d; break } Re = l.return } } function n1(o) { for (; Re !== null;) { var l = Re; if (l === o) { Re = null; break } var d = l.sibling; if (d !== null) { d.return = l.return, Re = d; break } Re = l.return } } function r1(o) { for (; Re !== null;) { var l = Re; try { switch (l.tag) { case 0: case 11: case 15: var d = l.return; try { rc(4, l) } catch (U) { zt(l, d, U) } break; case 1: var p = l.stateNode; if (typeof p.componentDidMount == "function") { var y = l.return; try { p.componentDidMount() } catch (U) { zt(l, y, U) } } var w = l.return; try { Fh(l) } catch (U) { zt(l, w, U) } break; case 5: var T = l.return; try { Fh(l) } catch (U) { zt(l, T, U) } } } catch (U) { zt(l, l.return, U) } if (l === o) { Re = null; break } var L = l.sibling; if (L !== null) { L.return = l.return, Re = L; break } Re = l.return } } var XA = Math.ceil, ic = N.ReactCurrentDispatcher, Oh = N.ReactCurrentOwner, gr = N.ReactCurrentBatchConfig, vt = 0, fn = null, Jt = null, yn = 0, $n = 0, Es = Hi(0), nn = 0, Ga = null, Oo = 0, oc = 0, Mh = 0, Xa = null, Hn = null, Vh = 0, Fs = 1 / 0, wi = null, sc = !1, Nh = null, Qi = null, ac = !1, Ji = null, lc = 0, Za = 0, Bh = null, uc = -1, cc = 0; function Vn() { return vt & 6 ? Gt() : uc !== -1 ? uc : uc = Gt() } function _i(o) { return o.mode & 1 ? vt & 2 && yn !== 0 ? yn & -yn : RA.transition !== null ? (cc === 0 && (cc = Qm()), cc) : (o = Pt, o !== 0 || (o = window.event, o = o === void 0 ? 16 : og(o.type)), o) : 1 } function Ir(o, l, d, p) { if (50 < Za) throw Za = 0, Bh = null, Error(n(185)); ya(o, d, p), (!(vt & 2) || o !== fn) && (o === fn && (!(vt & 2) && (oc |= d), nn === 4 && $i(o, yn)), qn(o, p), d === 1 && vt === 0 && !(l.mode & 1) && (Fs = Gt() + 500, ju && Gi())) } function qn(o, l) { var d = o.callbackNode; Rk(o, l); var p = xu(o, o === fn ? yn : 0); if (p === 0) d !== null && Xm(d), o.callbackNode = null, o.callbackPriority = 0; else if (l = p & -p, o.callbackPriority !== l) { if (d != null && Xm(d), l === 1) o.tag === 0 ? FA(o1.bind(null, o)) : Hg(o1.bind(null, o)), TA(function () { !(vt & 6) && Gi() }), d = null; else { switch (Jm(p)) { case 1: d = vd; break; case 4: d = Zm; break; case 16: d = vu; break; case 536870912: d = Ym; break; default: d = vu }d = h1(d, i1.bind(null, o)) } o.callbackPriority = l, o.callbackNode = d } } function i1(o, l) { if (uc = -1, cc = 0, vt & 6) throw Error(n(327)); var d = o.callbackNode; if (Rs() && o.callbackNode !== d) return null; var p = xu(o, o === fn ? yn : 0); if (p === 0) return null; if (p & 30 || p & o.expiredLanes || l) l = fc(o, p); else { l = p; var y = vt; vt |= 2; var w = a1(); (fn !== o || yn !== l) && (wi = null, Fs = Gt() + 500, Vo(o, l)); do try { QA(); break } catch (L) { s1(o, L) } while (!0); eh(), ic.current = w, vt = y, Jt !== null ? l = 0 : (fn = null, yn = 0, l = nn) } if (l !== 0) { if (l === 2 && (y = md(o), y !== 0 && (p = y, l = Lh(o, y))), l === 1) throw d = Ga, Vo(o, 0), $i(o, p), qn(o, Gt()), d; if (l === 6) $i(o, p); else { if (y = o.current.alternate, !(p & 30) && !ZA(y) && (l = fc(o, p), l === 2 && (w = md(o), w !== 0 && (p = w, l = Lh(o, w))), l === 1)) throw d = Ga, Vo(o, 0), $i(o, p), qn(o, Gt()), d; switch (o.finishedWork = y, o.finishedLanes = p, l) { case 0: case 1: throw Error(n(345)); case 2: No(o, Hn, wi); break; case 3: if ($i(o, p), (p & 130023424) === p && (l = Vh + 500 - Gt(), 10 < l)) { if (xu(o, 0) !== 0) break; if (y = o.suspendedLanes, (y & p) !== p) { Vn(), o.pingedLanes |= o.suspendedLanes & y; break } o.timeoutHandle = Kd(No.bind(null, o, Hn, wi), l); break } No(o, Hn, wi); break; case 4: if ($i(o, p), (p & 4194240) === p) break; for (l = o.eventTimes, y = -1; 0 < p;) { var T = 31 - Mr(p); w = 1 << T, T = l[T], T > y && (y = T), p &= ~w } if (p = y, p = Gt() - p, p = (120 > p ? 120 : 480 > p ? 480 : 1080 > p ? 1080 : 1920 > p ? 1920 : 3e3 > p ? 3e3 : 4320 > p ? 4320 : 1960 * XA(p / 1960)) - p, 10 < p) { o.timeoutHandle = Kd(No.bind(null, o, Hn, wi), p); break } No(o, Hn, wi); break; case 5: No(o, Hn, wi); break; default: throw Error(n(329)) } } } return qn(o, Gt()), o.callbackNode === d ? i1.bind(null, o) : null } function Lh(o, l) { var d = Xa; return o.current.memoizedState.isDehydrated && (Vo(o, l).flags |= 256), o = fc(o, l), o !== 2 && (l = Hn, Hn = d, l !== null && jh(l)), o } function jh(o) { Hn === null ? Hn = o : Hn.push.apply(Hn, o) } function ZA(o) { for (var l = o; ;) { if (l.flags & 16384) { var d = l.updateQueue; if (d !== null && (d = d.stores, d !== null)) for (var p = 0; p < d.length; p++) { var y = d[p], w = y.getSnapshot; y = y.value; try { if (!Vr(w(), y)) return !1 } catch { return !1 } } } if (d = l.child, l.subtreeFlags & 16384 && d !== null) d.return = l, l = d; else { if (l === o) break; for (; l.sibling === null;) { if (l.return === null || l.return === o) return !0; l = l.return } l.sibling.return = l.return, l = l.sibling } } return !0 } function $i(o, l) { for (l &= ~Mh, l &= ~oc, o.suspendedLanes |= l, o.pingedLanes &= ~l, o = o.expirationTimes; 0 < l;) { var d = 31 - Mr(l), p = 1 << d; o[d] = -1, l &= ~p } } function o1(o) { if (vt & 6) throw Error(n(327)); Rs(); var l = xu(o, 0); if (!(l & 1)) return qn(o, Gt()), null; var d = fc(o, l); if (o.tag !== 0 && d === 2) { var p = md(o); p !== 0 && (l = p, d = Lh(o, p)) } if (d === 1) throw d = Ga, Vo(o, 0), $i(o, l), qn(o, Gt()), d; if (d === 6) throw Error(n(345)); return o.finishedWork = o.current.alternate, o.finishedLanes = l, No(o, Hn, wi), qn(o, Gt()), null } function Ih(o, l) { var d = vt; vt |= 1; try { return o(l) } finally { vt = d, vt === 0 && (Fs = Gt() + 500, ju && Gi()) } } function Mo(o) { Ji !== null && Ji.tag === 0 && !(vt & 6) && Rs(); var l = vt; vt |= 1; var d = gr.transition, p = Pt; try { if (gr.transition = null, Pt = 1, o) return o() } finally { Pt = p, gr.transition = d, vt = l, !(vt & 6) && Gi() } } function zh() { $n = Es.current, Rt(Es) } function Vo(o, l) { o.finishedWork = null, o.finishedLanes = 0; var d = o.timeoutHandle; if (d !== -1 && (o.timeoutHandle = -1, PA(d)), Jt !== null) for (d = Jt.return; d !== null;) { var p = d; switch (Yd(p), p.tag) { case 1: p = p.type.childContextTypes, p != null && Bu(); break; case 3: Ts(), Rt(Un), Rt(Cn), lh(); break; case 5: sh(p); break; case 4: Ts(); break; case 13: Rt(Mt); break; case 19: Rt(Mt); break; case 10: th(p.type._context); break; case 22: case 23: zh() }d = d.return } if (fn = o, Jt = o = eo(o.current, null), yn = $n = l, nn = 0, Ga = null, Mh = oc = Oo = 0, Hn = Xa = null, Fo !== null) { for (l = 0; l < Fo.length; l++)if (d = Fo[l], p = d.interleaved, p !== null) { d.interleaved = null; var y = p.next, w = d.pending; if (w !== null) { var T = w.next; w.next = y, p.next = T } d.pending = p } Fo = null } return o } function s1(o, l) { do { var d = Jt; try { if (eh(), Zu.current = _u, Yu) { for (var p = Vt.memoizedState; p !== null;) { var y = p.queue; y !== null && (y.pending = null), p = p.next } Yu = !1 } if (Do = 0, cn = tn = Vt = null, za = !1, Ua = 0, Oh.current = null, d === null || d.return === null) { nn = 1, Ga = l, Jt = null; break } e: { var w = o, T = d.return, L = d, U = l; if (l = yn, L.flags |= 32768, U !== null && typeof U == "object" && typeof U.then == "function") { var te = U, ve = L, me = ve.tag; if (!(ve.mode & 1) && (me === 0 || me === 11 || me === 15)) { var he = ve.alternate; he ? (ve.updateQueue = he.updateQueue, ve.memoizedState = he.memoizedState, ve.lanes = he.lanes) : (ve.updateQueue = null, ve.memoizedState = null) } var Te = Dy(T); if (Te !== null) { Te.flags &= -257, Oy(Te, T, L, w, l), Te.mode & 1 && Ry(w, te, l), l = Te, U = te; var Oe = l.updateQueue; if (Oe === null) { var Me = new Set; Me.add(U), l.updateQueue = Me } else Oe.add(U); break e } else { if (!(l & 1)) { Ry(w, te, l), Uh(); break e } U = Error(n(426)) } } else if (Ot && L.mode & 1) { var Xt = Dy(T); if (Xt !== null) { !(Xt.flags & 65536) && (Xt.flags |= 256), Oy(Xt, T, L, w, l), _d(ks(U, L)); break e } } w = U = ks(U, L), nn !== 4 && (nn = 2), Xa === null ? Xa = [w] : Xa.push(w), w = T; do { switch (w.tag) { case 3: w.flags |= 65536, l &= -l, w.lanes |= l; var X = Ey(w, U, l); ty(w, X); break e; case 1: L = U; var K = w.type, J = w.stateNode; if (!(w.flags & 128) && (typeof K.getDerivedStateFromError == "function" || J !== null && typeof J.componentDidCatch == "function" && (Qi === null || !Qi.has(J)))) { w.flags |= 65536, l &= -l, w.lanes |= l; var Se = Fy(w, L, l); ty(w, Se); break e } }w = w.return } while (w !== null) } u1(d) } catch (Ne) { l = Ne, Jt === d && d !== null && (Jt = d = d.return); continue } break } while (!0) } function a1() { var o = ic.current; return ic.current = _u, o === null ? _u : o } function Uh() { (nn === 0 || nn === 3 || nn === 2) && (nn = 4), fn === null || !(Oo & 268435455) && !(oc & 268435455) || $i(fn, yn) } function fc(o, l) { var d = vt; vt |= 2; var p = a1(); (fn !== o || yn !== l) && (wi = null, Vo(o, l)); do try { YA(); break } catch (y) { s1(o, y) } while (!0); if (eh(), vt = d, ic.current = p, Jt !== null) throw Error(n(261)); return fn = null, yn = 0, nn } function YA() { for (; Jt !== null;)l1(Jt) } function QA() { for (; Jt !== null && !Sk();)l1(Jt) } function l1(o) { var l = d1(o.alternate, o, $n); o.memoizedProps = o.pendingProps, l === null ? u1(o) : Jt = l, Oh.current = null } function u1(o) { var l = o; do { var d = l.alternate; if (o = l.return, l.flags & 32768) { if (d = KA(d, l), d !== null) { d.flags &= 32767, Jt = d; return } if (o !== null) o.flags |= 32768, o.subtreeFlags = 0, o.deletions = null; else { nn = 6, Jt = null; return } } else if (d = WA(d, l, $n), d !== null) { Jt = d; return } if (l = l.sibling, l !== null) { Jt = l; return } Jt = l = o } while (l !== null); nn === 0 && (nn = 5) } function No(o, l, d) { var p = Pt, y = gr.transition; try { gr.transition = null, Pt = 1, JA(o, l, d, p) } finally { gr.transition = y, Pt = p } return null } function JA(o, l, d, p) { do Rs(); while (Ji !== null); if (vt & 6) throw Error(n(327)); d = o.finishedWork; var y = o.finishedLanes; if (d === null) return null; if (o.finishedWork = null, o.finishedLanes = 0, d === o.current) throw Error(n(177)); o.callbackNode = null, o.callbackPriority = 0; var w = d.lanes | d.childLanes; if (Dk(o, w), o === fn && (Jt = fn = null, yn = 0), !(d.subtreeFlags & 2064) && !(d.flags & 2064) || ac || (ac = !0, h1(vu, function () { return Rs(), null })), w = (d.flags & 15990) !== 0, d.subtreeFlags & 15990 || w) { w = gr.transition, gr.transition = null; var T = Pt; Pt = 1; var L = vt; vt |= 4, Oh.current = null, qA(o, d), $y(d, o), gA(Ud), bu = !!zd, Ud = zd = null, o.current = d, GA(d), bk(), vt = L, Pt = T, gr.transition = w } else o.current = d; if (ac && (ac = !1, Ji = o, lc = y), w = o.pendingLanes, w === 0 && (Qi = null), Tk(d.stateNode), qn(o, Gt()), l !== null) for (p = o.onRecoverableError, d = 0; d < l.length; d++)y = l[d], p(y.value, { componentStack: y.stack, digest: y.digest }); if (sc) throw sc = !1, o = Nh, Nh = null, o; return lc & 1 && o.tag !== 0 && Rs(), w = o.pendingLanes, w & 1 ? o === Bh ? Za++ : (Za = 0, Bh = o) : Za = 0, Gi(), null } function Rs() { if (Ji !== null) { var o = Jm(lc), l = gr.transition, d = Pt; try { if (gr.transition = null, Pt = 16 > o ? 16 : o, Ji === null) var p = !1; else { if (o = Ji, Ji = null, lc = 0, vt & 6) throw Error(n(331)); var y = vt; for (vt |= 4, Re = o.current; Re !== null;) { var w = Re, T = w.child; if (Re.flags & 16) { var L = w.deletions; if (L !== null) { for (var U = 0; U < L.length; U++) { var te = L[U]; for (Re = te; Re !== null;) { var ve = Re; switch (ve.tag) { case 0: case 11: case 15: qa(8, ve, w) }var me = ve.child; if (me !== null) me.return = ve, Re = me; else for (; Re !== null;) { ve = Re; var he = ve.sibling, Te = ve.return; if (Zy(ve), ve === te) { Re = null; break } if (he !== null) { he.return = Te, Re = he; break } Re = Te } } } var Oe = w.alternate; if (Oe !== null) { var Me = Oe.child; if (Me !== null) { Oe.child = null; do { var Xt = Me.sibling; Me.sibling = null, Me = Xt } while (Me !== null) } } Re = w } } if (w.subtreeFlags & 2064 && T !== null) T.return = w, Re = T; else e: for (; Re !== null;) { if (w = Re, w.flags & 2048) switch (w.tag) { case 0: case 11: case 15: qa(9, w, w.return) }var X = w.sibling; if (X !== null) { X.return = w.return, Re = X; break e } Re = w.return } } var K = o.current; for (Re = K; Re !== null;) { T = Re; var J = T.child; if (T.subtreeFlags & 2064 && J !== null) J.return = T, Re = J; else e: for (T = K; Re !== null;) { if (L = Re, L.flags & 2048) try { switch (L.tag) { case 0: case 11: case 15: rc(9, L) } } catch (Ne) { zt(L, L.return, Ne) } if (L === T) { Re = null; break e } var Se = L.sibling; if (Se !== null) { Se.return = L.return, Re = Se; break e } Re = L.return } } if (vt = y, Gi(), Zr && typeof Zr.onPostCommitFiberRoot == "function") try { Zr.onPostCommitFiberRoot(mu, o) } catch { } p = !0 } return p } finally { Pt = d, gr.transition = l } } return !1 } function c1(o, l, d) { l = ks(d, l), l = Ey(o, l, 1), o = Zi(o, l, 1), l = Vn(), o !== null && (ya(o, 1, l), qn(o, l)) } function zt(o, l, d) { if (o.tag === 3) c1(o, o, d); else for (; l !== null;) { if (l.tag === 3) { c1(l, o, d); break } else if (l.tag === 1) { var p = l.stateNode; if (typeof l.type.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && (Qi === null || !Qi.has(p))) { o = ks(d, o), o = Fy(l, o, 1), l = Zi(l, o, 1), o = Vn(), l !== null && (ya(l, 1, o), qn(l, o)); break } } l = l.return } } function _A(o, l, d) { var p = o.pingCache; p !== null && p.delete(l), l = Vn(), o.pingedLanes |= o.suspendedLanes & d, fn === o && (yn & d) === d && (nn === 4 || nn === 3 && (yn & 130023424) === yn && 500 > Gt() - Vh ? Vo(o, 0) : Mh |= d), qn(o, l) } function f1(o, l) { l === 0 && (o.mode & 1 ? (l = yu, yu <<= 1, !(yu & 130023424) && (yu = 4194304)) : l = 1); var d = Vn(); o = gi(o, l), o !== null && (ya(o, l, d), qn(o, d)) } function $A(o) { var l = o.memoizedState, d = 0; l !== null && (d = l.retryLane), f1(o, d) } function eE(o, l) { var d = 0; switch (o.tag) { case 13: var p = o.stateNode, y = o.memoizedState; y !== null && (d = y.retryLane); break; case 19: p = o.stateNode; break; default: throw Error(n(314)) }p !== null && p.delete(l), f1(o, d) } var d1; d1 = function (o, l, d) { if (o !== null) if (o.memoizedProps !== l.pendingProps || Un.current) Kn = !0; else { if (!(o.lanes & d) && !(l.flags & 128)) return Kn = !1, UA(o, l, d); Kn = !!(o.flags & 131072) } else Kn = !1, Ot && l.flags & 1048576 && qg(l, zu, l.index); switch (l.lanes = 0, l.tag) { case 2: var p = l.type; tc(o, l), o = l.pendingProps; var y = ys(l, Cn.current); Ps(l, d), y = fh(null, l, p, o, y, d); var w = dh(); return l.flags |= 1, typeof y == "object" && y !== null && typeof y.render == "function" && y.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, Wn(p) ? (w = !0, Lu(l)) : w = !1, l.memoizedState = y.state !== null && y.state !== void 0 ? y.state : null, ih(l), y.updater = $u, l.stateNode = y, y._reactInternals = l, yh(l, p, o, d), l = bh(null, l, p, !0, w, d)) : (l.tag = 0, Ot && w && Zd(l), Mn(null, l, y, d), l = l.child), l; case 16: p = l.elementType; e: { switch (tc(o, l), o = l.pendingProps, y = p._init, p = y(p._payload), l.type = p, y = l.tag = nE(p), o = Br(p, o), y) { case 0: l = Sh(null, l, p, o, d); break e; case 1: l = jy(null, l, p, o, d); break e; case 11: l = My(null, l, p, o, d); break e; case 14: l = Vy(null, l, p, Br(p.type, o), d); break e }throw Error(n(306, p, "")) } return l; case 0: return p = l.type, y = l.pendingProps, y = l.elementType === p ? y : Br(p, y), Sh(o, l, p, y, d); case 1: return p = l.type, y = l.pendingProps, y = l.elementType === p ? y : Br(p, y), jy(o, l, p, y, d); case 3: e: { if (Iy(l), o === null) throw Error(n(387)); p = l.pendingProps, w = l.memoizedState, y = w.element, ey(o, l), Gu(l, p, null, d); var T = l.memoizedState; if (p = T.element, w.isDehydrated) if (w = { element: p, isDehydrated: !1, cache: T.cache, pendingSuspenseBoundaries: T.pendingSuspenseBoundaries, transitions: T.transitions }, l.updateQueue.baseState = w, l.memoizedState = w, l.flags & 256) { y = ks(Error(n(423)), l), l = zy(o, l, p, d, y); break e } else if (p !== y) { y = ks(Error(n(424)), l), l = zy(o, l, p, d, y); break e } else for (_n = Ki(l.stateNode.containerInfo.firstChild), Jn = l, Ot = !0, Nr = null, d = _g(l, null, p, d), l.child = d; d;)d.flags = d.flags & -3 | 4096, d = d.sibling; else { if (Ss(), p === y) { l = xi(o, l, d); break e } Mn(o, l, p, d) } l = l.child } return l; case 5: return ry(l), o === null && Jd(l), p = l.type, y = l.pendingProps, w = o !== null ? o.memoizedProps : null, T = y.children, Wd(p, y) ? T = null : w !== null && Wd(p, w) && (l.flags |= 32), Ly(o, l), Mn(o, l, T, d), l.child; case 6: return o === null && Jd(l), null; case 13: return Uy(o, l, d); case 4: return oh(l, l.stateNode.containerInfo), p = l.pendingProps, o === null ? l.child = bs(l, null, p, d) : Mn(o, l, p, d), l.child; case 11: return p = l.type, y = l.pendingProps, y = l.elementType === p ? y : Br(p, y), My(o, l, p, y, d); case 7: return Mn(o, l, l.pendingProps, d), l.child; case 8: return Mn(o, l, l.pendingProps.children, d), l.child; case 12: return Mn(o, l, l.pendingProps.children, d), l.child; case 10: e: { if (p = l.type._context, y = l.pendingProps, w = l.memoizedProps, T = y.value, At(Ku, p._currentValue), p._currentValue = T, w !== null) if (Vr(w.value, T)) { if (w.children === y.children && !Un.current) { l = xi(o, l, d); break e } } else for (w = l.child, w !== null && (w.return = l); w !== null;) { var L = w.dependencies; if (L !== null) { T = w.child; for (var U = L.firstContext; U !== null;) { if (U.context === p) { if (w.tag === 1) { U = yi(-1, d & -d), U.tag = 2; var te = w.updateQueue; if (te !== null) { te = te.shared; var ve = te.pending; ve === null ? U.next = U : (U.next = ve.next, ve.next = U), te.pending = U } } w.lanes |= d, U = w.alternate, U !== null && (U.lanes |= d), nh(w.return, d, l), L.lanes |= d; break } U = U.next } } else if (w.tag === 10) T = w.type === l.type ? null : w.child; else if (w.tag === 18) { if (T = w.return, T === null) throw Error(n(341)); T.lanes |= d, L = T.alternate, L !== null && (L.lanes |= d), nh(T, d, l), T = w.sibling } else T = w.child; if (T !== null) T.return = w; else for (T = w; T !== null;) { if (T === l) { T = null; break } if (w = T.sibling, w !== null) { w.return = T.return, T = w; break } T = T.return } w = T } Mn(o, l, y.children, d), l = l.child } return l; case 9: return y = l.type, p = l.pendingProps.children, Ps(l, d), y = vr(y), p = p(y), l.flags |= 1, Mn(o, l, p, d), l.child; case 14: return p = l.type, y = Br(p, l.pendingProps), y = Br(p.type, y), Vy(o, l, p, y, d); case 15: return Ny(o, l, l.type, l.pendingProps, d); case 17: return p = l.type, y = l.pendingProps, y = l.elementType === p ? y : Br(p, y), tc(o, l), l.tag = 1, Wn(p) ? (o = !0, Lu(l)) : o = !1, Ps(l, d), ky(l, p, y), yh(l, p, y, d), bh(null, l, p, !0, o, d); case 19: return Ky(o, l, d); case 22: return By(o, l, d) }throw Error(n(156, l.tag)) }; function h1(o, l) { return Gm(o, l) } function tE(o, l, d, p) { this.tag = o, this.key = d, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = p, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function yr(o, l, d, p) { return new tE(o, l, d, p) } function Wh(o) { return o = o.prototype, !(!o || !o.isReactComponent) } function nE(o) { if (typeof o == "function") return Wh(o) ? 1 : 0; if (o != null) { if (o = o.$$typeof, o === se) return 11; if (o === ye) return 14 } return 2 } function eo(o, l) { var d = o.alternate; return d === null ? (d = yr(o.tag, l, o.key, o.mode), d.elementType = o.elementType, d.type = o.type, d.stateNode = o.stateNode, d.alternate = o, o.alternate = d) : (d.pendingProps = l, d.type = o.type, d.flags = 0, d.subtreeFlags = 0, d.deletions = null), d.flags = o.flags & 14680064, d.childLanes = o.childLanes, d.lanes = o.lanes, d.child = o.child, d.memoizedProps = o.memoizedProps, d.memoizedState = o.memoizedState, d.updateQueue = o.updateQueue, l = o.dependencies, d.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, d.sibling = o.sibling, d.index = o.index, d.ref = o.ref, d } function dc(o, l, d, p, y, w) { var T = 2; if (p = o, typeof o == "function") Wh(o) && (T = 1); else if (typeof o == "string") T = 5; else e: switch (o) { case B: return Bo(d.children, y, w, l); case I: T = 8, y |= 8; break; case Y: return o = yr(12, d, l, y | 2), o.elementType = Y, o.lanes = w, o; case q: return o = yr(13, d, l, y), o.elementType = q, o.lanes = w, o; case ue: return o = yr(19, d, l, y), o.elementType = ue, o.lanes = w, o; case _: return hc(d, y, w, l); default: if (typeof o == "object" && o !== null) switch (o.$$typeof) { case Z: T = 10; break e; case ie: T = 9; break e; case se: T = 11; break e; case ye: T = 14; break e; case ae: T = 16, p = null; break e }throw Error(n(130, o == null ? o : typeof o, "")) }return l = yr(T, d, l, y), l.elementType = o, l.type = p, l.lanes = w, l } function Bo(o, l, d, p) { return o = yr(7, o, p, l), o.lanes = d, o } function hc(o, l, d, p) { return o = yr(22, o, p, l), o.elementType = _, o.lanes = d, o.stateNode = { isHidden: !1 }, o } function Kh(o, l, d) { return o = yr(6, o, null, l), o.lanes = d, o } function Hh(o, l, d) { return l = yr(4, o.children !== null ? o.children : [], o.key, l), l.lanes = d, l.stateNode = { containerInfo: o.containerInfo, pendingChildren: null, implementation: o.implementation }, l } function rE(o, l, d, p, y) { this.tag = l, this.containerInfo = o, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gd(0), this.expirationTimes = gd(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gd(0), this.identifierPrefix = p, this.onRecoverableError = y, this.mutableSourceEagerHydrationData = null } function qh(o, l, d, p, y, w, T, L, U) { return o = new rE(o, l, d, L, U), l === 1 ? (l = 1, w === !0 && (l |= 8)) : l = 0, w = yr(3, null, null, l), o.current = w, w.stateNode = o, w.memoizedState = { element: p, isDehydrated: d, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ih(w), o } function iE(o, l, d) { var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: V, key: p == null ? null : "" + p, children: o, containerInfo: l, implementation: d } } function p1(o) { if (!o) return qi; o = o._reactInternals; e: { if (mn(o) !== o || o.tag !== 1) throw Error(n(170)); var l = o; do { switch (l.tag) { case 3: l = l.stateNode.context; break e; case 1: if (Wn(l.type)) { l = l.stateNode.__reactInternalMemoizedMergedChildContext; break e } }l = l.return } while (l !== null); throw Error(n(171)) } if (o.tag === 1) { var d = o.type; if (Wn(d)) return Wg(o, d, l) } return l } function v1(o, l, d, p, y, w, T, L, U) { return o = qh(d, p, !0, o, y, w, T, L, U), o.context = p1(null), d = o.current, p = Vn(), y = _i(d), w = yi(p, y), w.callback = l ?? null, Zi(d, w, y), o.current.lanes = y, ya(o, y, p), qn(o, p), o } function pc(o, l, d, p) { var y = l.current, w = Vn(), T = _i(y); return d = p1(d), l.context === null ? l.context = d : l.pendingContext = d, l = yi(w, T), l.payload = { element: o }, p = p === void 0 ? null : p, p !== null && (l.callback = p), o = Zi(y, l, T), o !== null && (Ir(o, y, T, w), qu(o, y, T)), T } function vc(o) { if (o = o.current, !o.child) return null; switch (o.child.tag) { case 5: return o.child.stateNode; default: return o.child.stateNode } } function m1(o, l) { if (o = o.memoizedState, o !== null && o.dehydrated !== null) { var d = o.retryLane; o.retryLane = d !== 0 && d < l ? d : l } } function Gh(o, l) { m1(o, l), (o = o.alternate) && m1(o, l) } var g1 = typeof reportError == "function" ? reportError : function (o) { console.error(o) }; function Xh(o) { this._internalRoot = o } mc.prototype.render = Xh.prototype.render = function (o) { var l = this._internalRoot; if (l === null) throw Error(n(409)); pc(o, l, null, null) }, mc.prototype.unmount = Xh.prototype.unmount = function () { var o = this._internalRoot; if (o !== null) { this._internalRoot = null; var l = o.containerInfo; Mo(function () { pc(null, o, null, null) }), l[hi] = null } }; function mc(o) { this._internalRoot = o } mc.prototype.unstable_scheduleHydration = function (o) { if (o) { var l = eg(); o = { blockedOn: null, target: o, priority: l }; for (var d = 0; d < zi.length && l !== 0 && l < zi[d].priority; d++); zi.splice(d, 0, o), d === 0 && rg(o) } }; function Zh(o) { return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11) } function gc(o) { return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11 && (o.nodeType !== 8 || o.nodeValue !== " react-mount-point-unstable ")) } function y1() { } function oE(o, l, d, p, y) { if (y) { if (typeof p == "function") { var w = p; p = function () { var te = vc(T); w.call(te) } } var T = v1(l, p, o, 0, null, !1, !1, "", y1); return o._reactRootContainer = T, o[hi] = T.current, Oa(o.nodeType === 8 ? o.parentNode : o), Mo(), T } for (; y = o.lastChild;)o.removeChild(y); if (typeof p == "function") { var L = p; p = function () { var te = vc(U); L.call(te) } } var U = qh(o, 0, !1, null, null, !1, !1, "", y1); return o._reactRootContainer = U, o[hi] = U.current, Oa(o.nodeType === 8 ? o.parentNode : o), Mo(function () { pc(l, U, d, p) }), U } function yc(o, l, d, p, y) { var w = d._reactRootContainer; if (w) { var T = w; if (typeof y == "function") { var L = y; y = function () { var U = vc(T); L.call(U) } } pc(l, T, o, y) } else T = oE(d, l, o, y, p); return vc(T) } _m = function (o) { switch (o.tag) { case 3: var l = o.stateNode; if (l.current.memoizedState.isDehydrated) { var d = ga(l.pendingLanes); d !== 0 && (yd(l, d | 1), qn(l, Gt()), !(vt & 6) && (Fs = Gt() + 500, Gi())) } break; case 13: Mo(function () { var p = gi(o, 1); if (p !== null) { var y = Vn(); Ir(p, o, 1, y) } }), Gh(o, 1) } }, xd = function (o) { if (o.tag === 13) { var l = gi(o, 134217728); if (l !== null) { var d = Vn(); Ir(l, o, 134217728, d) } Gh(o, 134217728) } }, $m = function (o) { if (o.tag === 13) { var l = _i(o), d = gi(o, l); if (d !== null) { var p = Vn(); Ir(d, o, l, p) } Gh(o, l) } }, eg = function () { return Pt }, tg = function (o, l) { var d = Pt; try { return Pt = o, l() } finally { Pt = d } }, x = function (o, l, d) { switch (l) { case "input": if (Ct(o, d), l = d.name, d.type === "radio" && l != null) { for (d = o; d.parentNode;)d = d.parentNode; for (d = d.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < d.length; l++) { var p = d[l]; if (p !== o && p.form === o.form) { var y = Nu(p); if (!y) throw Error(n(90)); ht(p), Ct(p, y) } } } break; case "textarea": Or(o, d); break; case "select": l = d.value, l != null && Dn(o, !!d.multiple, l, !1) } }, Ve = Ih, Ce = Mo; var sE = { usingClientEntryPoint: !1, Events: [Na, ms, Nu, z, $, Ih] }, Ya = { findFiberByHostInstance: To, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, aE = { bundleType: Ya.bundleType, version: Ya.version, rendererPackageName: Ya.rendererPackageName, rendererConfig: Ya.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: N.ReactCurrentDispatcher, findHostInstanceByFiber: function (o) { return o = Hm(o), o === null ? null : o.stateNode }, findFiberByHostInstance: Ya.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var xc = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!xc.isDisabled && xc.supportsFiber) try { mu = xc.inject(aE), Zr = xc } catch { } } return Gn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sE, Gn.createPortal = function (o, l) { var d = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Zh(l)) throw Error(n(200)); return iE(o, l, null, d) }, Gn.createRoot = function (o, l) { if (!Zh(o)) throw Error(n(299)); var d = !1, p = "", y = g1; return l != null && (l.unstable_strictMode === !0 && (d = !0), l.identifierPrefix !== void 0 && (p = l.identifierPrefix), l.onRecoverableError !== void 0 && (y = l.onRecoverableError)), l = qh(o, 1, !1, null, null, d, !1, p, y), o[hi] = l.current, Oa(o.nodeType === 8 ? o.parentNode : o), new Xh(l) }, Gn.findDOMNode = function (o) { if (o == null) return null; if (o.nodeType === 1) return o; var l = o._reactInternals; if (l === void 0) throw typeof o.render == "function" ? Error(n(188)) : (o = Object.keys(o).join(","), Error(n(268, o))); return o = Hm(l), o = o === null ? null : o.stateNode, o }, Gn.flushSync = function (o) { return Mo(o) }, Gn.hydrate = function (o, l, d) { if (!gc(l)) throw Error(n(200)); return yc(null, o, l, !0, d) }, Gn.hydrateRoot = function (o, l, d) { if (!Zh(o)) throw Error(n(405)); var p = d != null && d.hydratedSources || null, y = !1, w = "", T = g1; if (d != null && (d.unstable_strictMode === !0 && (y = !0), d.identifierPrefix !== void 0 && (w = d.identifierPrefix), d.onRecoverableError !== void 0 && (T = d.onRecoverableError)), l = v1(l, null, o, 1, d ?? null, y, !1, w, T), o[hi] = l.current, Oa(o), p) for (o = 0; o < p.length; o++)d = p[o], y = d._getVersion, y = y(d._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [d, y] : l.mutableSourceEagerHydrationData.push(d, y); return new mc(l) }, Gn.render = function (o, l, d) { if (!gc(l)) throw Error(n(200)); return yc(null, o, l, !1, d) }, Gn.unmountComponentAtNode = function (o) { if (!gc(o)) throw Error(n(40)); return o._reactRootContainer ? (Mo(function () { yc(null, null, o, !1, function () { o._reactRootContainer = null, o[hi] = null }) }), !0) : !1 }, Gn.unstable_batchedUpdates = Ih, Gn.unstable_renderSubtreeIntoContainer = function (o, l, d, p) { if (!gc(d)) throw Error(n(200)); if (o == null || o._reactInternals === void 0) throw Error(n(38)); return yc(o, l, d, !1, p) }, Gn.version = "18.3.1-next-f1338f8080-20240426", Gn
} var k1; function wb() { if (k1) return _h.exports; k1 = 1; function t() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t) } catch (e) { console.error(e) } } return t(), _h.exports = pE(), _h.exports } var A1; function vE() { if (A1) return wc; A1 = 1; var t = wb(); return wc.createRoot = t.createRoot, wc.hydrateRoot = t.hydrateRoot, wc } var mE = vE(); function gE(t) { if (typeof Proxy > "u") return t; const e = new Map, n = (...r) => t(...r); return new Proxy(n, { get: (r, i) => i === "create" ? t : (e.has(i) || e.set(i, t(i)), e.get(i)) }) } function Mf(t) { return t !== null && typeof t == "object" && typeof t.start == "function" } const Xp = t => Array.isArray(t); function Sb(t, e) { if (!Array.isArray(e)) return !1; const n = e.length; if (n !== t.length) return !1; for (let r = 0; r < n; r++)if (e[r] !== t[r]) return !1; return !0 } function Vl(t) { return typeof t == "string" || Array.isArray(t) } function E1(t) { const e = [{}, {}]; return t == null || t.values.forEach((n, r) => { e[0][r] = n.get(), e[1][r] = n.getVelocity() }), e } function J0(t, e, n, r) { if (typeof e == "function") { const [i, s] = E1(r); e = e(n !== void 0 ? n : t.custom, i, s) } if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") { const [i, s] = E1(r); e = e(n !== void 0 ? n : t.custom, i, s) } return e } function Vf(t, e, n) { const r = t.getProps(); return J0(r, e, n !== void 0 ? n : r.custom, t) } const _0 = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], $0 = ["initial", ..._0], Jl = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], ts = new Set(Jl), Ci = t => t * 1e3, Pi = t => t / 1e3, yE = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, xE = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), wE = { type: "keyframes", duration: .8 }, SE = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, bE = (t, { keyframes: e }) => e.length > 2 ? wE : ts.has(t) ? t.startsWith("scale") ? xE(e[1]) : yE : SE; function ev(t, e) { return t ? t[e] || t.default || t : void 0 } const CE = { skipAnimations: !1, useManualTiming: !1 }, PE = t => t !== null; function Nf(t, { repeat: e, repeatType: n = "loop" }, r) { const i = t.filter(PE), s = e && n !== "loop" && e % 2 === 1 ? 0 : i.length - 1; return !s || r === void 0 ? i[s] : r } const ir = t => t; let Zp = ir; function TE(t) { let e = new Set, n = new Set, r = !1, i = !1; const s = new WeakSet; let a = { delta: 0, timestamp: 0, isProcessing: !1 }; function u(f) { s.has(f) && (c.schedule(f), t()), f(a) } const c = { schedule: (f, h = !1, v = !1) => { const g = v && r ? e : n; return h && s.add(f), g.has(f) || g.add(f), f }, cancel: f => { n.delete(f), s.delete(f) }, process: f => { if (a = f, r) { i = !0; return } r = !0, [e, n] = [n, e], e.forEach(u), e.clear(), r = !1, i && (i = !1, c.process(f)) } }; return c } const Sc = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], kE = 40; function bb(t, e) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, s = () => n = !0, a = Sc.reduce((C, F) => (C[F] = TE(s), C), {}), { read: u, resolveKeyframes: c, update: f, preRender: h, render: v, postRender: m } = a, g = () => { const C = performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(C - i.timestamp, kE), 1), i.timestamp = C, i.isProcessing = !0, u.process(i), c.process(i), f.process(i), h.process(i), v.process(i), m.process(i), i.isProcessing = !1, n && e && (r = !1, t(g)) }, S = () => { n = !0, r = !0, i.isProcessing || t(g) }; return { schedule: Sc.reduce((C, F) => { const A = a[F]; return C[F] = (N, D = !1, V = !1) => (n || S(), A.schedule(N, D, V)), C }, {}), cancel: C => { for (let F = 0; F < Sc.length; F++)a[Sc[F]].cancel(C) }, state: i, steps: a } } const { schedule: Dt, cancel: co, state: xn, steps: tp } = bb(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ir, !0), Cb = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, AE = 1e-7, EE = 12; function FE(t, e, n, r, i) { let s, a, u = 0; do a = e + (n - e) / 2, s = Cb(a, r, i) - t, s > 0 ? n = a : e = a; while (Math.abs(s) > AE && ++u < EE); return a } function _l(t, e, n, r) { if (t === e && n === r) return ir; const i = s => FE(s, 0, 1, t, n); return s => s === 0 || s === 1 ? s : Cb(i(s), e, r) } const Pb = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, Tb = t => e => 1 - t(1 - e), kb = _l(.33, 1.53, .69, .99), tv = Tb(kb), Ab = Pb(tv), Eb = t => (t *= 2) < 1 ? .5 * tv(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), nv = t => 1 - Math.sin(Math.acos(t)), Fb = Tb(nv), Rb = Pb(nv), Db = t => /^0[^.\s]+$/u.test(t); function RE(t) { return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || Db(t) : !0 } const Ob = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), Mb = t => e => typeof e == "string" && e.startsWith(t), Vb = Mb("--"), DE = Mb("var(--"), rv = t => DE(t) ? OE.test(t.split("/*")[0].trim()) : !1, OE = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, ME = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function VE(t) { const e = ME.exec(t); if (!e) return [,]; const [, n, r, i] = e; return [`--${n ?? r}`, i] } function Nb(t, e, n = 1) { const [r, i] = VE(t); if (!r) return; const s = window.getComputedStyle(e).getPropertyValue(r); if (s) { const a = s.trim(); return Ob(a) ? parseFloat(a) : a } return rv(i) ? Nb(i, e, n + 1) : i } const Ri = (t, e, n) => n > e ? e : n < t ? t : n, la = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, Nl = { ...la, transform: t => Ri(0, 1, t) }, bc = { ...la, default: 1 }, $l = t => ({ test: e => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1, parse: parseFloat, transform: e => `${e}${t}` }), ro = $l("deg"), ti = $l("%"), Ke = $l("px"), NE = $l("vh"), BE = $l("vw"), F1 = { ...ti, parse: t => ti.parse(t) / 100, transform: t => ti.transform(t * 100) }, LE = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), R1 = t => t === la || t === Ke, D1 = (t, e) => parseFloat(t.split(", ")[e]), O1 = (t, e) => (n, { transform: r }) => { if (r === "none" || !r) return 0; const i = r.match(/^matrix3d\((.+)\)$/u); if (i) return D1(i[1], e); { const s = r.match(/^matrix\((.+)\)$/u); return s ? D1(s[1], t) : 0 } }, jE = new Set(["x", "y", "z"]), IE = Jl.filter(t => !jE.has(t)); function zE(t) { const e = []; return IE.forEach(n => { const r = t.getValue(n); r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), e } const $s = { width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), top: (t, { top: e }) => parseFloat(e), left: (t, { left: e }) => parseFloat(e), bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min), right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min), x: O1(4, 13), y: O1(5, 14) }; $s.translateX = $s.x; $s.translateY = $s.y; const Bb = t => e => e.test(t), UE = { test: t => t === "auto", parse: t => t }, Lb = [la, Ke, ti, ro, BE, NE, UE], M1 = t => Lb.find(Bb(t)), Qo = new Set; let Yp = !1, Qp = !1; function jb() { if (Qp) { const t = Array.from(Qo).filter(r => r.needsMeasurement), e = new Set(t.map(r => r.element)), n = new Map; e.forEach(r => { const i = zE(r); i.length && (n.set(r, i), r.render()) }), t.forEach(r => r.measureInitialState()), e.forEach(r => { r.render(); const i = n.get(r); i && i.forEach(([s, a]) => { var u; (u = r.getValue(s)) === null || u === void 0 || u.set(a) }) }), t.forEach(r => r.measureEndState()), t.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } Qp = !1, Yp = !1, Qo.forEach(t => t.complete()), Qo.clear() } function Ib() { Qo.forEach(t => { t.readKeyframes(), t.needsMeasurement && (Qp = !0) }) } function WE() { Ib(), jb() } let iv = class { constructor(e, n, r, i, s, a = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = r, this.motionValue = i, this.element = s, this.isAsync = a } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (Qo.add(this), Yp || (Yp = !0, Dt.read(Ib), Dt.resolveKeyframes(jb))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: e, name: n, element: r, motionValue: i } = this; for (let s = 0; s < e.length; s++)if (e[s] === null) if (s === 0) { const a = i == null ? void 0 : i.get(), u = e[e.length - 1]; if (a !== void 0) e[0] = a; else if (r && n) { const c = r.readValue(n, u); c != null && (e[0] = c) } e[0] === void 0 && (e[0] = u), i && a === void 0 && i.set(e[0]) } else e[s] = e[s - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Qo.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, Qo.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } }; const xl = t => Math.round(t * 1e5) / 1e5, ov = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function KE(t) { return t == null } const HE = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, sv = (t, e) => n => !!(typeof n == "string" && HE.test(n) && n.startsWith(t) || e && !KE(n) && Object.prototype.hasOwnProperty.call(n, e)), zb = (t, e, n) => r => { if (typeof r != "string") return r; const [i, s, a, u] = r.match(ov); return { [t]: parseFloat(i), [e]: parseFloat(s), [n]: parseFloat(a), alpha: u !== void 0 ? parseFloat(u) : 1 } }, qE = t => Ri(0, 255, t), np = { ...la, transform: t => Math.round(qE(t)) }, Zo = { test: sv("rgb", "red"), parse: zb("red", "green", "blue"), transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + np.transform(t) + ", " + np.transform(e) + ", " + np.transform(n) + ", " + xl(Nl.transform(r)) + ")" }; function GE(t) { let e = "", n = "", r = "", i = ""; return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), i = t.substring(4, 5), e += e, n += n, r += r, i += i), { red: parseInt(e, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } const Jp = { test: sv("#"), parse: GE, transform: Zo.transform }, js = { test: sv("hsl", "hue"), parse: zb("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + ti.transform(xl(e)) + ", " + ti.transform(xl(n)) + ", " + xl(Nl.transform(r)) + ")" }, An = { test: t => Zo.test(t) || Jp.test(t) || js.test(t), parse: t => Zo.test(t) ? Zo.parse(t) : js.test(t) ? js.parse(t) : Jp.parse(t), transform: t => typeof t == "string" ? t : t.hasOwnProperty("red") ? Zo.transform(t) : js.transform(t) }, XE = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function ZE(t) { var e, n; return isNaN(t) && typeof t == "string" && (((e = t.match(ov)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(XE)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } const Ub = "number", Wb = "color", YE = "var", QE = "var(", V1 = "${}", JE = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Bl(t) { const e = t.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let s = 0; const u = e.replace(JE, c => (An.test(c) ? (r.color.push(s), i.push(Wb), n.push(An.parse(c))) : c.startsWith(QE) ? (r.var.push(s), i.push(YE), n.push(c)) : (r.number.push(s), i.push(Ub), n.push(parseFloat(c))), ++s, V1)).split(V1); return { values: n, split: u, indexes: r, types: i } } function Kb(t) { return Bl(t).values } function Hb(t) { const { split: e, types: n } = Bl(t), r = e.length; return i => { let s = ""; for (let a = 0; a < r; a++)if (s += e[a], i[a] !== void 0) { const u = n[a]; u === Ub ? s += xl(i[a]) : u === Wb ? s += An.transform(i[a]) : s += i[a] } return s } } const _E = t => typeof t == "number" ? 0 : t; function $E(t) { const e = Kb(t); return Hb(t)(e.map(_E)) } const fo = { test: ZE, parse: Kb, createTransformer: Hb, getAnimatableNone: $E }, eF = new Set(["brightness", "contrast", "saturate", "opacity"]); function tF(t) { const [e, n] = t.slice(0, -1).split("("); if (e === "drop-shadow") return t; const [r] = n.match(ov) || []; if (!r) return t; const i = n.replace(r, ""); let s = eF.has(e) ? 1 : 0; return r !== n && (s *= 100), e + "(" + s + i + ")" } const nF = /\b([a-z-]*)\(.*?\)/gu, _p = { ...fo, getAnimatableNone: t => { const e = t.match(nF); return e ? e.map(tF).join(" ") : t } }, rF = { borderWidth: Ke, borderTopWidth: Ke, borderRightWidth: Ke, borderBottomWidth: Ke, borderLeftWidth: Ke, borderRadius: Ke, radius: Ke, borderTopLeftRadius: Ke, borderTopRightRadius: Ke, borderBottomRightRadius: Ke, borderBottomLeftRadius: Ke, width: Ke, maxWidth: Ke, height: Ke, maxHeight: Ke, top: Ke, right: Ke, bottom: Ke, left: Ke, padding: Ke, paddingTop: Ke, paddingRight: Ke, paddingBottom: Ke, paddingLeft: Ke, margin: Ke, marginTop: Ke, marginRight: Ke, marginBottom: Ke, marginLeft: Ke, backgroundPositionX: Ke, backgroundPositionY: Ke }, iF = { rotate: ro, rotateX: ro, rotateY: ro, rotateZ: ro, scale: bc, scaleX: bc, scaleY: bc, scaleZ: bc, skew: ro, skewX: ro, skewY: ro, distance: Ke, translateX: Ke, translateY: Ke, translateZ: Ke, x: Ke, y: Ke, z: Ke, perspective: Ke, transformPerspective: Ke, opacity: Nl, originX: F1, originY: F1, originZ: Ke }, N1 = { ...la, transform: Math.round }, av = { ...rF, ...iF, zIndex: N1, size: Ke, fillOpacity: Nl, strokeOpacity: Nl, numOctaves: N1 }, oF = { ...av, color: An, backgroundColor: An, outlineColor: An, fill: An, stroke: An, borderColor: An, borderTopColor: An, borderRightColor: An, borderBottomColor: An, borderLeftColor: An, filter: _p, WebkitFilter: _p }, lv = t => oF[t]; function qb(t, e) { let n = lv(t); return n !== _p && (n = fo), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0 } const sF = new Set(["auto", "none", "0"]); function aF(t, e, n) { let r = 0, i; for (; r < t.length && !i;) { const s = t[r]; typeof s == "string" && !sF.has(s) && Bl(s).values.length && (i = t[r]), r++ } if (i && n) for (const s of e) t[s] = qb(n, i) } let Gb = class extends iv { constructor(e, n, r, i, s) { super(e, n, r, i, s, !0) } readKeyframes() { const { unresolvedKeyframes: e, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let c = 0; c < e.length; c++) { let f = e[c]; if (typeof f == "string" && (f = f.trim(), rv(f))) { const h = Nb(f, n.current); h !== void 0 && (e[c] = h), c === e.length - 1 && (this.finalKeyframe = f) } } if (this.resolveNoneKeyframes(), !LE.has(r) || e.length !== 2) return; const [i, s] = e, a = M1(i), u = M1(s); if (a !== u) if (R1(a) && R1(u)) for (let c = 0; c < e.length; c++) { const f = e[c]; typeof f == "string" && (e[c] = parseFloat(f)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: e, name: n } = this, r = []; for (let i = 0; i < e.length; i++)RE(e[i]) && r.push(i); r.length && aF(e, r, n) } measureInitialState() { const { element: e, unresolvedKeyframes: n, name: r } = this; if (!e || !e.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = $s[r](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin; const i = n[n.length - 1]; i !== void 0 && e.getValue(r, i).jump(i, !1) } measureEndState() { var e; const { element: n, name: r, unresolvedKeyframes: i } = this; if (!n || !n.current) return; const s = n.getValue(r); s && s.jump(this.measuredOrigin, !1); const a = i.length - 1, u = i[a]; i[a] = $s[r](n.measureViewportBox(), window.getComputedStyle(n.current)), u !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = u), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([c, f]) => { n.getValue(c).set(f) }), this.resolveNoneKeyframes() } }; function uv(t) { return typeof t == "function" } let zc; function lF() { zc = void 0 } const ni = { now: () => (zc === void 0 && ni.set(xn.isProcessing || CE.useManualTiming ? xn.timestamp : performance.now()), zc), set: t => { zc = t, queueMicrotask(lF) } }, B1 = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (fo.test(t) || t === "0") && !t.startsWith("url(")); function uF(t) { const e = t[0]; if (t.length === 1) return !0; for (let n = 0; n < t.length; n++)if (t[n] !== e) return !0 } function cF(t, e, n, r) { const i = t[0]; if (i === null) return !1; if (e === "display" || e === "visibility") return !0; const s = t[t.length - 1], a = B1(i, e), u = B1(s, e); return !a || !u ? !1 : uF(t) || (n === "spring" || uv(n)) && r } const fF = 40; let Xb = class { constructor({ autoplay: e = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: a = "loop", ...u }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = ni.now(), this.options = { autoplay: e, delay: n, type: r, repeat: i, repeatDelay: s, repeatType: a, ...u }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > fF ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && WE(), this._resolved } onKeyframesResolved(e, n) { this.resolvedAt = ni.now(), this.hasAttemptedResolve = !0; const { name: r, type: i, velocity: s, delay: a, onComplete: u, onUpdate: c, isGenerator: f } = this.options; if (!f && !cF(e, r, i, s)) if (a) this.options.duration = 0; else { c == null || c(Nf(e, this.options, n)), u == null || u(), this.resolveFinishedPromise(); return } const h = this.initPlayback(e, n); h !== !1 && (this._resolved = { keyframes: e, finalKeyframe: n, ...h }, this.onPostResolved()) } onPostResolved() { } then(e, n) { return this.currentFinishedPromise.then(e, n) } flatten() { this.options.type = "keyframes", this.options.ease = "linear" } updateFinishedPromise() { this.currentFinishedPromise = new Promise(e => { this.resolveFinishedPromise = e }) } }; const ea = (t, e, n) => { const r = e - t; return r === 0 ? 1 : (n - t) / r }, Zb = (t, e, n = 10) => { let r = ""; const i = Math.max(Math.round(e / n), 2); for (let s = 0; s < i; s++)r += t(ea(0, i - 1, s)) + ", "; return `linear(${r.substring(0, r.length - 2)})` }; function Yb(t, e) { return e ? t * (1e3 / e) : 0 } const dF = 5; function Qb(t, e, n) { const r = Math.max(e - dF, 0); return Yb(n - t(r), e - r) } const Ut = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, rp = .001; function hF({ duration: t = Ut.duration, bounce: e = Ut.bounce, velocity: n = Ut.velocity, mass: r = Ut.mass }) { let i, s, a = 1 - e; a = Ri(Ut.minDamping, Ut.maxDamping, a), t = Ri(Ut.minDuration, Ut.maxDuration, Pi(t)), a < 1 ? (i = f => { const h = f * a, v = h * t, m = h - n, g = $p(f, a), S = Math.exp(-v); return rp - m / g * S }, s = f => { const v = f * a * t, m = v * n + n, g = Math.pow(a, 2) * Math.pow(f, 2) * t, S = Math.exp(-v), b = $p(Math.pow(f, 2), a); return (-i(f) + rp > 0 ? -1 : 1) * ((m - g) * S) / b }) : (i = f => { const h = Math.exp(-f * t), v = (f - n) * t + 1; return -rp + h * v }, s = f => { const h = Math.exp(-f * t), v = (n - f) * (t * t); return h * v }); const u = 5 / t, c = vF(i, s, u); if (t = Ci(t), isNaN(c)) return { stiffness: Ut.stiffness, damping: Ut.damping, duration: t }; { const f = Math.pow(c, 2) * r; return { stiffness: f, damping: a * 2 * Math.sqrt(r * f), duration: t } } } const pF = 12; function vF(t, e, n) { let r = n; for (let i = 1; i < pF; i++)r = r - t(r) / e(r); return r } function $p(t, e) { return t * Math.sqrt(1 - e * e) } const e0 = 2e4; function Jb(t) { let e = 0; const n = 50; let r = t.next(e); for (; !r.done && e < e0;)e += n, r = t.next(e); return e >= e0 ? 1 / 0 : e } const mF = ["duration", "bounce"], gF = ["stiffness", "damping", "mass"]; function L1(t, e) { return e.some(n => t[n] !== void 0) } function yF(t) { let e = { velocity: Ut.velocity, stiffness: Ut.stiffness, damping: Ut.damping, mass: Ut.mass, isResolvedFromDuration: !1, ...t }; if (!L1(t, gF) && L1(t, mF)) if (t.visualDuration) { const n = t.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, s = 2 * Ri(.05, 1, 1 - t.bounce) * Math.sqrt(i); e = { ...e, mass: Ut.mass, stiffness: i, damping: s } } else { const n = hF(t); e = { ...e, ...n, mass: Ut.mass }, e.isResolvedFromDuration = !0 } return e } function _b(t = Ut.visualDuration, e = Ut.bounce) { const n = typeof t != "object" ? { visualDuration: t, keyframes: [0, 1], bounce: e } : t; let { restSpeed: r, restDelta: i } = n; const s = n.keyframes[0], a = n.keyframes[n.keyframes.length - 1], u = { done: !1, value: s }, { stiffness: c, damping: f, mass: h, duration: v, velocity: m, isResolvedFromDuration: g } = yF({ ...n, velocity: -Pi(n.velocity || 0) }), S = m || 0, b = f / (2 * Math.sqrt(c * h)), P = a - s, C = Pi(Math.sqrt(c / h)), F = Math.abs(P) < 5; r || (r = F ? Ut.restSpeed.granular : Ut.restSpeed.default), i || (i = F ? Ut.restDelta.granular : Ut.restDelta.default); let A; if (b < 1) { const D = $p(C, b); A = V => { const B = Math.exp(-b * C * V); return a - B * ((S + b * C * P) / D * Math.sin(D * V) + P * Math.cos(D * V)) } } else if (b === 1) A = D => a - Math.exp(-C * D) * (P + (S + C * P) * D); else { const D = C * Math.sqrt(b * b - 1); A = V => { const B = Math.exp(-b * C * V), I = Math.min(D * V, 300); return a - B * ((S + b * C * P) * Math.sinh(I) + D * P * Math.cosh(I)) / D } } const N = { calculatedDuration: g && v || null, next: D => { const V = A(D); if (g) u.done = D >= v; else { let B = 0; b < 1 && (B = D === 0 ? Ci(S) : Qb(A, D, V)); const I = Math.abs(B) <= r, Y = Math.abs(a - V) <= i; u.done = I && Y } return u.value = u.done ? a : V, u }, toString: () => { const D = Math.min(Jb(N), e0), V = Zb(B => N.next(D * B).value, D, 30); return D + "ms " + V } }; return N } function j1({ keyframes: t, velocity: e = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: a, min: u, max: c, restDelta: f = .5, restSpeed: h }) { const v = t[0], m = { done: !1, value: v }, g = I => u !== void 0 && I < u || c !== void 0 && I > c, S = I => u === void 0 ? c : c === void 0 || Math.abs(u - I) < Math.abs(c - I) ? u : c; let b = n * e; const P = v + b, C = a === void 0 ? P : a(P); C !== P && (b = C - v); const F = I => -b * Math.exp(-I / r), A = I => C + F(I), N = I => { const Y = F(I), Z = A(I); m.done = Math.abs(Y) <= f, m.value = m.done ? C : Z }; let D, V; const B = I => { g(m.value) && (D = I, V = _b({ keyframes: [m.value, S(m.value)], velocity: Qb(A, I, m.value), damping: i, stiffness: s, restDelta: f, restSpeed: h })) }; return B(0), { calculatedDuration: null, next: I => { let Y = !1; return !V && D === void 0 && (Y = !0, N(I), B(I)), D !== void 0 && I >= D ? V.next(I - D) : (!Y && N(I), m) } } } const xF = _l(.42, 0, 1, 1), wF = _l(0, 0, .58, 1), $b = _l(.42, 0, .58, 1), SF = t => Array.isArray(t) && typeof t[0] != "number", cv = t => Array.isArray(t) && typeof t[0] == "number", I1 = { linear: ir, easeIn: xF, easeInOut: $b, easeOut: wF, circIn: nv, circInOut: Rb, circOut: Fb, backIn: tv, backInOut: Ab, backOut: kb, anticipate: Eb }, z1 = t => { if (cv(t)) { Zp(t.length === 4); const [e, n, r, i] = t; return _l(e, n, r, i) } else if (typeof t == "string") return Zp(I1[t] !== void 0), I1[t]; return t }, bF = (t, e) => n => e(t(n)), eu = (...t) => t.reduce(bF), Bt = (t, e, n) => t + (e - t) * n; function ip(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } function CF({ hue: t, saturation: e, lightness: n, alpha: r }) { t /= 360, e /= 100, n /= 100; let i = 0, s = 0, a = 0; if (!e) i = s = a = n; else { const u = n < .5 ? n * (1 + e) : n + e - n * e, c = 2 * n - u; i = ip(c, u, t + 1 / 3), s = ip(c, u, t), a = ip(c, u, t - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(s * 255), blue: Math.round(a * 255), alpha: r } } function tf(t, e) { return n => n > 0 ? e : t } const op = (t, e, n) => { const r = t * t, i = n * (e * e - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, PF = [Jp, Zo, js], TF = t => PF.find(e => e.test(t)); function U1(t) { const e = TF(t); if (!e) return !1; let n = e.parse(t); return e === js && (n = CF(n)), n } const W1 = (t, e) => { const n = U1(t), r = U1(e); if (!n || !r) return tf(t, e); const i = { ...n }; return s => (i.red = op(n.red, r.red, s), i.green = op(n.green, r.green, s), i.blue = op(n.blue, r.blue, s), i.alpha = Bt(n.alpha, r.alpha, s), Zo.transform(i)) }, t0 = new Set(["none", "hidden"]); function kF(t, e) { return t0.has(t) ? n => n <= 0 ? t : e : n => n >= 1 ? e : t } function AF(t, e) { return n => Bt(t, e, n) } function fv(t) { return typeof t == "number" ? AF : typeof t == "string" ? rv(t) ? tf : An.test(t) ? W1 : RF : Array.isArray(t) ? eC : typeof t == "object" ? An.test(t) ? W1 : EF : tf } function eC(t, e) { const n = [...t], r = n.length, i = t.map((s, a) => fv(s)(s, e[a])); return s => { for (let a = 0; a < r; a++)n[a] = i[a](s); return n } } function EF(t, e) { const n = { ...t, ...e }, r = {}; for (const i in n) t[i] !== void 0 && e[i] !== void 0 && (r[i] = fv(t[i])(t[i], e[i])); return i => { for (const s in r) n[s] = r[s](i); return n } } function FF(t, e) { var n; const r = [], i = { color: 0, var: 0, number: 0 }; for (let s = 0; s < e.values.length; s++) { const a = e.types[s], u = t.indexes[a][i[a]], c = (n = t.values[u]) !== null && n !== void 0 ? n : 0; r[s] = c, i[a]++ } return r } const RF = (t, e) => { const n = fo.createTransformer(e), r = Bl(t), i = Bl(e); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? t0.has(t) && !i.values.length || t0.has(e) && !r.values.length ? kF(t, e) : eu(eC(FF(r, i), i.values), n) : tf(t, e) }; function tC(t, e, n) { return typeof t == "number" && typeof e == "number" && typeof n == "number" ? Bt(t, e, n) : fv(t)(t, e) } function DF(t, e, n) { const r = [], i = n || tC, s = t.length - 1; for (let a = 0; a < s; a++) { let u = i(t[a], t[a + 1]); if (e) { const c = Array.isArray(e) ? e[a] || ir : e; u = eu(c, u) } r.push(u) } return r } function OF(t, e, { clamp: n = !0, ease: r, mixer: i } = {}) { const s = t.length; if (Zp(s === e.length), s === 1) return () => e[0]; if (s === 2 && t[0] === t[1]) return () => e[1]; t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse()); const a = DF(e, r, i), u = a.length, c = f => { let h = 0; if (u > 1) for (; h < t.length - 2 && !(f < t[h + 1]); h++); const v = ea(t[h], t[h + 1], f); return a[h](v) }; return n ? f => c(Ri(t[0], t[s - 1], f)) : c } function MF(t, e) { const n = t[t.length - 1]; for (let r = 1; r <= e; r++) { const i = ea(0, e, r); t.push(Bt(n, 1, i)) } } function VF(t) { const e = [0]; return MF(e, t.length - 1), e } function NF(t, e) { return t.map(n => n * e) } function BF(t, e) { return t.map(() => e || $b).splice(0, t.length - 1) } function nf({ duration: t = 300, keyframes: e, times: n, ease: r = "easeInOut" }) { const i = SF(r) ? r.map(z1) : z1(r), s = { done: !1, value: e[0] }, a = NF(n && n.length === e.length ? n : VF(e), t), u = OF(a, e, { ease: Array.isArray(i) ? i : BF(e, i) }); return { calculatedDuration: t, next: c => (s.value = u(c), s.done = c >= t, s) } } const LF = t => { const e = ({ timestamp: n }) => t(n); return { start: () => Dt.update(e, !0), stop: () => co(e), now: () => xn.isProcessing ? xn.timestamp : ni.now() } }, jF = { decay: j1, inertia: j1, tween: nf, keyframes: nf, spring: _b }, IF = t => t / 100; let dv = class extends Xb { constructor(e) { super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: c } = this.options; c && c() }; const { name: n, motionValue: r, element: i, keyframes: s } = this.options, a = (i == null ? void 0 : i.KeyframeResolver) || iv, u = (c, f) => this.onKeyframesResolved(c, f); this.resolver = new a(s, u, n, r, i), this.resolver.scheduleResolve() } flatten() { super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)) } initPlayback(e) { const { type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: s, velocity: a = 0 } = this.options, u = uv(n) ? n : jF[n] || nf; let c, f; u !== nf && typeof e[0] != "number" && (c = eu(IF, tC(e[0], e[1])), e = [0, 100]); const h = u({ ...this.options, keyframes: e }); s === "mirror" && (f = u({ ...this.options, keyframes: [...e].reverse(), velocity: -a })), h.calculatedDuration === null && (h.calculatedDuration = Jb(h)); const { calculatedDuration: v } = h, m = v + i, g = m * (r + 1) - i; return { generator: h, mirroredGenerator: f, mapPercentToKeyframes: c, calculatedDuration: v, resolvedDuration: m, totalDuration: g } } onPostResolved() { const { autoplay: e = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState } tick(e, n = !1) { const { resolved: r } = this; if (!r) { const { keyframes: I } = this.options; return { done: !0, value: I[I.length - 1] } } const { finalKeyframe: i, generator: s, mirroredGenerator: a, mapPercentToKeyframes: u, keyframes: c, calculatedDuration: f, totalDuration: h, resolvedDuration: v } = r; if (this.startTime === null) return s.next(0); const { delay: m, repeat: g, repeatType: S, repeatDelay: b, onUpdate: P } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - h / this.speed, this.startTime)), n ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed; const C = this.currentTime - m * (this.speed >= 0 ? 1 : -1), F = this.speed >= 0 ? C < 0 : C > h; this.currentTime = Math.max(C, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = h); let A = this.currentTime, N = s; if (g) { const I = Math.min(this.currentTime, h) / v; let Y = Math.floor(I), Z = I % 1; !Z && I >= 1 && (Z = 1), Z === 1 && Y--, Y = Math.min(Y, g + 1), !!(Y % 2) && (S === "reverse" ? (Z = 1 - Z, b && (Z -= b / v)) : S === "mirror" && (N = a)), A = Ri(0, 1, Z) * v } const D = F ? { done: !1, value: c[0] } : N.next(A); u && (D.value = u(D.value)); let { done: V } = D; !F && f !== null && (V = this.speed >= 0 ? this.currentTime >= h : this.currentTime <= 0); const B = this.holdTime === null && (this.state === "finished" || this.state === "running" && V); return B && i !== void 0 && (D.value = Nf(c, this.options, i)), P && P(D.value), B && this.finish(), D } get duration() { const { resolved: e } = this; return e ? Pi(e.calculatedDuration) : 0 } get time() { return Pi(this.currentTime) } set time(e) { e = Ci(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed) } get speed() { return this.playbackSpeed } set speed(e) { const n = this.playbackSpeed !== e; this.playbackSpeed = e, n && (this.time = Pi(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: e = LF, onPlay: n, startTime: r } = this.options; this.driver || (this.driver = e(s => this.tick(s))), n && n(); const i = this.driver.now(); this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var e; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: e } = this.options; e && e() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } }; const zF = new Set(["opacity", "clipPath", "filter", "transform"]); function hv(t) { let e; return () => (e === void 0 && (e = t()), e) } const UF = { linearEasing: void 0 }; function WF(t, e) { const n = hv(t); return () => { var r; return (r = UF[e]) !== null && r !== void 0 ? r : n() } } const rf = WF(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"); function nC(t) { return !!(typeof t == "function" && rf() || !t || typeof t == "string" && (t in n0 || rf()) || cv(t) || Array.isArray(t) && t.every(nC)) } const al = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`, n0 = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: al([0, .65, .55, 1]), circOut: al([.55, 0, 1, .45]), backIn: al([.31, .01, .66, -.59]), backOut: al([.33, 1.53, .69, .99]) }; function rC(t, e) { if (t) return typeof t == "function" && rf() ? Zb(t, e) : cv(t) ? al(t) : Array.isArray(t) ? t.map(n => rC(n, e) || n0.easeOut) : n0[t] } function KF(t, e, n, { delay: r = 0, duration: i = 300, repeat: s = 0, repeatType: a = "loop", ease: u = "easeInOut", times: c } = {}) { const f = { [e]: n }; c && (f.offset = c); const h = rC(u, i); return Array.isArray(h) && (f.easing = h), t.animate(f, { delay: r, duration: i, easing: Array.isArray(h) ? "linear" : h, fill: "both", iterations: s + 1, direction: a === "reverse" ? "alternate" : "normal" }) } function K1(t, e) { t.timeline = e, t.onfinish = null } const HF = hv(() => Object.hasOwnProperty.call(Element.prototype, "animate")), of = 10, qF = 2e4; function GF(t) { return uv(t.type) || t.type === "spring" || !nC(t.ease) } function XF(t, e) { const n = new dv({ ...e, keyframes: t, repeat: 0, delay: 0, isGenerator: !0 }); let r = { done: !1, value: t[0] }; const i = []; let s = 0; for (; !r.done && s < qF;)r = n.sample(s), i.push(r.value), s += of; return { times: void 0, keyframes: i, duration: s - of, ease: "linear" } } const iC = { anticipate: Eb, backInOut: Ab, circInOut: Rb }; function ZF(t) { return t in iC } let H1 = class extends Xb { constructor(e) { super(e); const { name: n, motionValue: r, element: i, keyframes: s } = this.options; this.resolver = new Gb(s, (a, u) => this.onKeyframesResolved(a, u), n, r, i), this.resolver.scheduleResolve() } initPlayback(e, n) { var r; let { duration: i = 300, times: s, ease: a, type: u, motionValue: c, name: f, startTime: h } = this.options; if (!(!((r = c.owner) === null || r === void 0) && r.current)) return !1; if (typeof a == "string" && rf() && ZF(a) && (a = iC[a]), GF(this.options)) { const { onComplete: m, onUpdate: g, motionValue: S, element: b, ...P } = this.options, C = XF(e, P); e = C.keyframes, e.length === 1 && (e[1] = e[0]), i = C.duration, s = C.times, a = C.ease, u = "keyframes" } const v = KF(c.owner.current, f, e, { ...this.options, duration: i, times: s, ease: a }); return v.startTime = h ?? this.calcStartTime(), this.pendingTimeline ? (K1(v, this.pendingTimeline), this.pendingTimeline = void 0) : v.onfinish = () => { const { onComplete: m } = this.options; c.set(Nf(e, this.options, n)), m && m(), this.cancel(), this.resolveFinishedPromise() }, { animation: v, duration: i, times: s, type: u, ease: a, keyframes: e } } get duration() { const { resolved: e } = this; if (!e) return 0; const { duration: n } = e; return Pi(n) } get time() { const { resolved: e } = this; if (!e) return 0; const { animation: n } = e; return Pi(n.currentTime || 0) } set time(e) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.currentTime = Ci(e) } get speed() { const { resolved: e } = this; if (!e) return 1; const { animation: n } = e; return n.playbackRate } set speed(e) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.playbackRate = e } get state() { const { resolved: e } = this; if (!e) return "idle"; const { animation: n } = e; return n.playState } get startTime() { const { resolved: e } = this; if (!e) return null; const { animation: n } = e; return n.startTime } attachTimeline(e) { if (!this._resolved) this.pendingTimeline = e; else { const { resolved: n } = this; if (!n) return ir; const { animation: r } = n; K1(r, e) } return ir } play() { if (this.isStopped) return; const { resolved: e } = this; if (!e) return; const { animation: n } = e; n.playState === "finished" && this.updateFinishedPromise(), n.play() } pause() { const { resolved: e } = this; if (!e) return; const { animation: n } = e; n.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); const { resolved: e } = this; if (!e) return; const { animation: n, keyframes: r, duration: i, type: s, ease: a, times: u } = e; if (n.playState === "idle" || n.playState === "finished") return; if (this.time) { const { motionValue: f, onUpdate: h, onComplete: v, element: m, ...g } = this.options, S = new dv({ ...g, keyframes: r, duration: i, type: s, ease: a, times: u, isGenerator: !0 }), b = Ci(this.time); f.setWithVelocity(S.sample(b - of).value, S.sample(b).value, of) } const { onStop: c } = this.options; c && c(), this.cancel() } complete() { const { resolved: e } = this; e && e.animation.finish() } cancel() { const { resolved: e } = this; e && e.animation.cancel() } static supports(e) { const { motionValue: n, name: r, repeatDelay: i, repeatType: s, damping: a, type: u } = e; return HF() && r && zF.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && !n.owner.getProps().onUpdate && !i && s !== "mirror" && a !== 0 && u !== "inertia" } }; const YF = hv(() => window.ScrollTimeline !== void 0); let QF = class { constructor(e) { this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean) } then(e, n) { return Promise.all(this.animations).then(e).catch(n) } getAll(e) { return this.animations[0][e] } setAll(e, n) { for (let r = 0; r < this.animations.length; r++)this.animations[r][e] = n } attachTimeline(e, n) { const r = this.animations.map(i => YF() && i.attachTimeline ? i.attachTimeline(e) : n(i)); return () => { r.forEach((i, s) => { i && i(), this.animations[s].stop() }) } } get time() { return this.getAll("time") } set time(e) { this.setAll("time", e) } get speed() { return this.getAll("speed") } set speed(e) { this.setAll("speed", e) } get startTime() { return this.getAll("startTime") } get duration() { let e = 0; for (let n = 0; n < this.animations.length; n++)e = Math.max(e, this.animations[n].duration); return e } runAll(e) { this.animations.forEach(n => n[e]()) } flatten() { this.runAll("flatten") } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } }; function JF({ when: t, delay: e, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: a, repeatDelay: u, from: c, elapsed: f, ...h }) { return !!Object.keys(h).length } const pv = (t, e, n, r = {}, i, s) => a => { const u = ev(r, t) || {}, c = u.delay || r.delay || 0; let { elapsed: f = 0 } = r; f = f - Ci(c); let h = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: e.getVelocity(), ...u, delay: -f, onUpdate: m => { e.set(m), u.onUpdate && u.onUpdate(m) }, onComplete: () => { a(), u.onComplete && u.onComplete() }, name: t, motionValue: e, element: s ? void 0 : i }; JF(u) || (h = { ...h, ...bE(t, h) }), h.duration && (h.duration = Ci(h.duration)), h.repeatDelay && (h.repeatDelay = Ci(h.repeatDelay)), h.from !== void 0 && (h.keyframes[0] = h.from); let v = !1; if ((h.type === !1 || h.duration === 0 && !h.repeatDelay) && (h.duration = 0, h.delay === 0 && (v = !0)), v && !s && e.get() !== void 0) { const m = Nf(h.keyframes, u); if (m !== void 0) return Dt.update(() => { h.onUpdate(m), h.onComplete() }), new QF([]) } return !s && H1.supports(h) ? new H1(h) : new dv(h) }, _F = t => !!(t && typeof t == "object" && t.mix && t.toValue), $F = t => Xp(t) ? t[t.length - 1] || 0 : t; function vv(t, e) { t.indexOf(e) === -1 && t.push(e) } function mv(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } let gv = class { constructor() { this.subscriptions = [] } add(e) { return vv(this.subscriptions, e), () => mv(this.subscriptions, e) } notify(e, n, r) { const i = this.subscriptions.length; if (i) if (i === 1) this.subscriptions[0](e, n, r); else for (let s = 0; s < i; s++) { const a = this.subscriptions[s]; a && a(e, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } }; const q1 = 30, eR = t => !isNaN(parseFloat(t)); let tR = class { constructor(e, n = {}) { this.version = "11.15.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, i = !0) => { const s = ni.now(); this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner } setCurrent(e) { this.current = e, this.updatedAt = ni.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = eR(this.current)) } setPrevFrameValue(e = this.current) { this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, n) { this.events[e] || (this.events[e] = new gv); const r = this.events[e].add(n); return e === "change" ? () => { r(), Dt.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, n) { this.passiveEffect = e, this.stopPassiveEffect = n } set(e, n = !0) { !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - r } jump(e, n = !0) { this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const e = ni.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > q1) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, q1); return Yb(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(e) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } }; function Ll(t, e) { return new tR(t, e) } function nR(t, e, n) { t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Ll(n)) } function rR(t, e) { const n = Vf(t, e); let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {}; s = { ...s, ...r }; for (const a in s) { const u = $F(s[a]); nR(t, a, u) } } const yv = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), iR = "framerAppearId", oC = "data-" + yv(iR); function sC(t) { return t.props[oC] } const Fn = t => !!(t && t.getVelocity); function oR(t) { return !!(Fn(t) && t.add) } function r0(t, e) { const n = t.getValue("willChange"); if (oR(n)) return n.add(e) } function sR({ protectedKeys: t, needsAnimating: e }, n) { const r = t.hasOwnProperty(n) && e[n] !== !0; return e[n] = !1, r } function aC(t, e, { delay: n = 0, transitionOverride: r, type: i } = {}) { var s; let { transition: a = t.getDefaultTransition(), transitionEnd: u, ...c } = e; r && (a = r); const f = [], h = i && t.animationState && t.animationState.getState()[i]; for (const v in c) { const m = t.getValue(v, (s = t.latestValues[v]) !== null && s !== void 0 ? s : null), g = c[v]; if (g === void 0 || h && sR(h, v)) continue; const S = { delay: n, ...ev(a || {}, v) }; let b = !1; if (window.MotionHandoffAnimation) { const C = sC(t); if (C) { const F = window.MotionHandoffAnimation(C, v, Dt); F !== null && (S.startTime = F, b = !0) } } r0(t, v), m.start(pv(v, m, g, t.shouldReduceMotion && ts.has(v) ? { type: !1 } : S, t, b)); const P = m.animation; P && f.push(P) } return u && Promise.all(f).then(() => { Dt.update(() => { u && rR(t, u) }) }), f } function i0(t, e, n = {}) { var r; const i = Vf(t, e, n.type === "exit" ? (r = t.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0); let { transition: s = t.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (s = n.transitionOverride); const a = i ? () => Promise.all(aC(t, i, n)) : () => Promise.resolve(), u = t.variantChildren && t.variantChildren.size ? (f = 0) => { const { delayChildren: h = 0, staggerChildren: v, staggerDirection: m } = s; return aR(t, e, h + f, v, m, n) } : () => Promise.resolve(), { when: c } = s; if (c) { const [f, h] = c === "beforeChildren" ? [a, u] : [u, a]; return f().then(() => h()) } else return Promise.all([a(), u(n.delay)]) } function aR(t, e, n = 0, r = 0, i = 1, s) { const a = [], u = (t.variantChildren.size - 1) * r, c = i === 1 ? (f = 0) => f * r : (f = 0) => u - f * r; return Array.from(t.variantChildren).sort(lR).forEach((f, h) => { f.notify("AnimationStart", e), a.push(i0(f, e, { ...s, delay: n + c(h) }).then(() => f.notify("AnimationComplete", e))) }), Promise.all(a) } function lR(t, e) { return t.sortNodePosition(e) } function uR(t, e, n = {}) { t.notify("AnimationStart", e); let r; if (Array.isArray(e)) { const i = e.map(s => i0(t, s, n)); r = Promise.all(i) } else if (typeof e == "string") r = i0(t, e, n); else { const i = typeof e == "function" ? Vf(t, e, n.custom) : e; r = Promise.all(aC(t, i, n)) } return r.then(() => { t.notify("AnimationComplete", e) }) } const cR = $0.length; function lC(t) { if (!t) return; if (!t.isControllingVariants) { const n = t.parent ? lC(t.parent) || {} : {}; return t.props.initial !== void 0 && (n.initial = t.props.initial), n } const e = {}; for (let n = 0; n < cR; n++) { const r = $0[n], i = t.props[r]; (Vl(i) || i === !1) && (e[r] = i) } return e } const fR = [..._0].reverse(), dR = _0.length; function hR(t) { return e => Promise.all(e.map(({ animation: n, options: r }) => uR(t, n, r))) } function pR(t) { let e = hR(t), n = G1(), r = !0; const i = c => (f, h) => { var v; const m = Vf(t, h, c === "exit" ? (v = t.presenceContext) === null || v === void 0 ? void 0 : v.custom : void 0); if (m) { const { transition: g, transitionEnd: S, ...b } = m; f = { ...f, ...b, ...S } } return f }; function s(c) { e = c(t) } function a(c) { const { props: f } = t, h = lC(t.parent) || {}, v = [], m = new Set; let g = {}, S = 1 / 0; for (let P = 0; P < dR; P++) { const C = fR[P], F = n[C], A = f[C] !== void 0 ? f[C] : h[C], N = Vl(A), D = C === c ? F.isActive : null; D === !1 && (S = P); let V = A === h[C] && A !== f[C] && N; if (V && r && t.manuallyAnimateOnMount && (V = !1), F.protectedKeys = { ...g }, !F.isActive && D === null || !A && !F.prevProp || Mf(A) || typeof A == "boolean") continue; const B = vR(F.prevProp, A); let I = B || C === c && F.isActive && !V && N || P > S && N, Y = !1; const Z = Array.isArray(A) ? A : [A]; let ie = Z.reduce(i(C), {}); D === !1 && (ie = {}); const { prevResolvedValues: se = {} } = F, q = { ...se, ...ie }, ue = _ => { I = !0, m.has(_) && (Y = !0, m.delete(_)), F.needsAnimating[_] = !0; const Q = t.getValue(_); Q && (Q.liveStyle = !1) }; for (const _ in q) { const Q = ie[_], le = se[_]; if (g.hasOwnProperty(_)) continue; let ce = !1; Xp(Q) && Xp(le) ? ce = !Sb(Q, le) : ce = Q !== le, ce ? Q != null ? ue(_) : m.add(_) : Q !== void 0 && m.has(_) ? ue(_) : F.protectedKeys[_] = !0 } F.prevProp = A, F.prevResolvedValues = ie, F.isActive && (g = { ...g, ...ie }), r && t.blockInitialAnimation && (I = !1), I && (!(V && B) || Y) && v.push(...Z.map(_ => ({ animation: _, options: { type: C } }))) } if (m.size) { const P = {}; m.forEach(C => { const F = t.getBaseTarget(C), A = t.getValue(C); A && (A.liveStyle = !0), P[C] = F ?? null }), v.push({ animation: P }) } let b = !!v.length; return r && (f.initial === !1 || f.initial === f.animate) && !t.manuallyAnimateOnMount && (b = !1), r = !1, b ? e(v) : Promise.resolve() } function u(c, f) { var h; if (n[c].isActive === f) return Promise.resolve(); (h = t.variantChildren) === null || h === void 0 || h.forEach(m => { var g; return (g = m.animationState) === null || g === void 0 ? void 0 : g.setActive(c, f) }), n[c].isActive = f; const v = a(c); for (const m in n) n[m].protectedKeys = {}; return v } return { animateChanges: a, setActive: u, setAnimateFunction: s, getState: () => n, reset: () => { n = G1(), r = !0 } } } function vR(t, e) { return typeof e == "string" ? e !== t : Array.isArray(e) ? !Sb(e, t) : !1 } function Lo(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function G1() { return { animate: Lo(!0), whileInView: Lo(), whileHover: Lo(), whileTap: Lo(), whileDrag: Lo(), whileFocus: Lo(), exit: Lo() } } let wo = class { constructor(e) { this.isMounted = !1, this.node = e } update() { } }, mR = class extends wo { constructor(e) { super(e), e.animationState || (e.animationState = pR(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); Mf(e) && (this.unmountControls = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; e !== n && this.updateAnimationControlsSubscription() } unmount() { var e; this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this) } }, gR = 0, yR = class extends wo { constructor() { super(...arguments), this.id = gR++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === r) return; const i = this.node.animationState.setActive("exit", !e); n && !e && i.then(() => n(this.id)) } mount() { const { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } }; const xR = { animation: { Feature: mR }, exit: { Feature: yR } }, Wr = { x: !1, y: !1 }; function uC() { return Wr.x || Wr.y } function wR(t, e, n) { var r; if (t instanceof Element) return [t]; if (typeof t == "string") { let i = document; const s = (r = void 0) !== null && r !== void 0 ? r : i.querySelectorAll(t); return s ? Array.from(s) : [] } return Array.from(t) } function cC(t, e) { const n = wR(t), r = new AbortController, i = { passive: !0, ...e, signal: r.signal }; return [n, i, () => r.abort()] } function X1(t) { return e => { e.pointerType === "touch" || uC() || t(e) } } function SR(t, e, n = {}) { const [r, i, s] = cC(t, n), a = X1(u => { const { target: c } = u, f = e(u); if (!f || !c) return; const h = X1(v => { f(v), c.removeEventListener("pointerleave", h) }); c.addEventListener("pointerleave", h, i) }); return r.forEach(u => { u.addEventListener("pointerenter", a, i) }), s } const xv = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1, ll = new WeakSet; function Z1(t) { return e => { e.key === "Enter" && t(e) } } function sp(t, e) { t.dispatchEvent(new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 })) } const bR = (t, e) => { const n = t.currentTarget; if (!n) return; const r = Z1(() => { if (ll.has(n)) return; sp(n, "down"); const i = Z1(() => { sp(n, "up") }), s = () => sp(n, "cancel"); n.addEventListener("keyup", i, e), n.addEventListener("blur", s, e) }); n.addEventListener("keydown", r, e), n.addEventListener("blur", () => n.removeEventListener("keydown", r), e) }, CR = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function PR(t) { return CR.has(t.tagName) || t.tabIndex !== -1 } const fC = (t, e) => e ? t === e ? !0 : fC(t, e.parentElement) : !1; function Y1(t) { return xv(t) && !uC() } function TR(t, e, n = {}) { const [r, i, s] = cC(t, n), a = u => { const c = u.currentTarget; if (!Y1(u) || ll.has(c)) return; ll.add(c); const f = e(u), h = (g, S) => { window.removeEventListener("pointerup", v), window.removeEventListener("pointercancel", m), !(!Y1(g) || !ll.has(c)) && (ll.delete(c), f && f(g, { success: S })) }, v = g => { h(g, n.useGlobalTarget || fC(c, g.target)) }, m = g => { h(g, !1) }; window.addEventListener("pointerup", v, i), window.addEventListener("pointercancel", m, i) }; return r.forEach(u => { PR(u) || (u.tabIndex = 0), (n.useGlobalTarget ? window : u).addEventListener("pointerdown", a, i), u.addEventListener("focus", f => bR(f, i), i) }), s } function kR(t) { return t === "x" || t === "y" ? Wr[t] ? null : (Wr[t] = !0, () => { Wr[t] = !1 }) : Wr.x || Wr.y ? null : (Wr.x = Wr.y = !0, () => { Wr.x = Wr.y = !1 }) } function tu(t) { return { point: { x: t.pageX, y: t.pageY } } } const AR = t => e => xv(e) && t(e, tu(e)); function jl(t, e, n, r = { passive: !0 }) { return t.addEventListener(e, n, r), () => t.removeEventListener(e, n) } function wl(t, e, n, r) { return jl(t, e, AR(n), r) } const Q1 = (t, e) => Math.abs(t - e); function ER(t, e) { const n = Q1(t.x, e.x), r = Q1(t.y, e.y); return Math.sqrt(n ** 2 + r ** 2) } let dC = class { constructor(e, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: s = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const v = lp(this.lastMoveEventInfo, this.history), m = this.startEvent !== null, g = ER(v.offset, { x: 0, y: 0 }) >= 3; if (!m && !g) return; const { point: S } = v, { timestamp: b } = xn; this.history.push({ ...S, timestamp: b }); const { onStart: P, onMove: C } = this.handlers; m || (P && P(this.lastMoveEvent, v), this.startEvent = this.lastMoveEvent), C && C(this.lastMoveEvent, v) }, this.handlePointerMove = (v, m) => { this.lastMoveEvent = v, this.lastMoveEventInfo = ap(m, this.transformPagePoint), Dt.update(this.updatePoint, !0) }, this.handlePointerUp = (v, m) => { this.end(); const { onEnd: g, onSessionEnd: S, resumeAnimation: b } = this.handlers; if (this.dragSnapToOrigin && b && b(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const P = lp(v.type === "pointercancel" ? this.lastMoveEventInfo : ap(m, this.transformPagePoint), this.history); this.startEvent && g && g(v, P), S && S(v, P) }, !xv(e)) return; this.dragSnapToOrigin = s, this.handlers = n, this.transformPagePoint = r, this.contextWindow = i || window; const a = tu(e), u = ap(a, this.transformPagePoint), { point: c } = u, { timestamp: f } = xn; this.history = [{ ...c, timestamp: f }]; const { onSessionStart: h } = n; h && h(e, lp(u, this.history)), this.removeListeners = eu(wl(this.contextWindow, "pointermove", this.handlePointerMove), wl(this.contextWindow, "pointerup", this.handlePointerUp), wl(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), co(this.updatePoint) } }; function ap(t, e) { return e ? { point: e(t.point) } : t } function J1(t, e) { return { x: t.x - e.x, y: t.y - e.y } } function lp({ point: t }, e) { return { point: t, delta: J1(t, hC(e)), offset: J1(t, FR(e)), velocity: RR(e, .1) } } function FR(t) { return t[0] } function hC(t) { return t[t.length - 1] } function RR(t, e) { if (t.length < 2) return { x: 0, y: 0 }; let n = t.length - 1, r = null; const i = hC(t); for (; n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > Ci(e)));)n--; if (!r) return { x: 0, y: 0 }; const s = Pi(i.timestamp - r.timestamp); if (s === 0) return { x: 0, y: 0 }; const a = { x: (i.x - r.x) / s, y: (i.y - r.y) / s }; return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a } function Is(t) { return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } const pC = 1e-4, DR = 1 - pC, OR = 1 + pC, vC = .01, MR = 0 - vC, VR = 0 + vC; function ar(t) { return t.max - t.min } function NR(t, e, n) { return Math.abs(t - e) <= n } function _1(t, e, n, r = .5) { t.origin = r, t.originPoint = Bt(e.min, e.max, t.origin), t.scale = ar(n) / ar(e), t.translate = Bt(n.min, n.max, t.origin) - t.originPoint, (t.scale >= DR && t.scale <= OR || isNaN(t.scale)) && (t.scale = 1), (t.translate >= MR && t.translate <= VR || isNaN(t.translate)) && (t.translate = 0) } function Sl(t, e, n, r) { _1(t.x, e.x, n.x, r ? r.originX : void 0), _1(t.y, e.y, n.y, r ? r.originY : void 0) } function $1(t, e, n) { t.min = n.min + e.min, t.max = t.min + ar(e) } function BR(t, e, n) { $1(t.x, e.x, n.x), $1(t.y, e.y, n.y) } function ex(t, e, n) { t.min = e.min - n.min, t.max = t.min + ar(e) } function bl(t, e, n) { ex(t.x, e.x, n.x), ex(t.y, e.y, n.y) } function LR(t, { min: e, max: n }, r) { return e !== void 0 && t < e ? t = r ? Bt(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? Bt(n, t, r.max) : Math.min(t, n)), t } function tx(t, e, n) { return { min: e !== void 0 ? t.min + e : void 0, max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0 } } function jR(t, { top: e, left: n, bottom: r, right: i }) { return { x: tx(t.x, n, i), y: tx(t.y, e, r) } } function nx(t, e) { let n = e.min - t.min, r = e.max - t.max; return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), { min: n, max: r } } function IR(t, e) { return { x: nx(t.x, e.x), y: nx(t.y, e.y) } } function zR(t, e) { let n = .5; const r = ar(t), i = ar(e); return i > r ? n = ea(e.min, e.max - r, t.min) : r > i && (n = ea(t.min, t.max - i, e.min)), Ri(0, 1, n) } function UR(t, e) { const n = {}; return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n } const o0 = .35; function WR(t = o0) { return t === !1 ? t = 0 : t === !0 && (t = o0), { x: rx(t, "left", "right"), y: rx(t, "top", "bottom") } } function rx(t, e, n) { return { min: ix(t, e), max: ix(t, n) } } function ix(t, e) { return typeof t == "number" ? t : t[e] || 0 } const ox = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), zs = () => ({ x: ox(), y: ox() }), sx = () => ({ min: 0, max: 0 }), Zt = () => ({ x: sx(), y: sx() }); function Cr(t) { return [t("x"), t("y")] } function mC({ top: t, left: e, right: n, bottom: r }) { return { x: { min: e, max: n }, y: { min: t, max: r } } } function KR({ x: t, y: e }) { return { top: e.min, right: t.max, bottom: e.max, left: t.min } } function HR(t, e) { if (!e) return t; const n = e({ x: t.left, y: t.top }), r = e({ x: t.right, y: t.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function up(t) { return t === void 0 || t === 1 } function s0({ scale: t, scaleX: e, scaleY: n }) { return !up(t) || !up(e) || !up(n) } function Ko(t) { return s0(t) || gC(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function gC(t) { return ax(t.x) || ax(t.y) } function ax(t) { return t && t !== "0%" } function sf(t, e, n) { const r = t - n, i = e * r; return n + i } function lx(t, e, n, r, i) { return i !== void 0 && (t = sf(t, i, r)), sf(t, n, r) + e } function a0(t, e = 0, n = 1, r, i) { t.min = lx(t.min, e, n, r, i), t.max = lx(t.max, e, n, r, i) } function yC(t, { x: e, y: n }) { a0(t.x, e.translate, e.scale, e.originPoint), a0(t.y, n.translate, n.scale, n.originPoint) } const ux = .999999999999, cx = 1.0000000000001; function qR(t, e, n, r = !1) { const i = n.length; if (!i) return; e.x = e.y = 1; let s, a; for (let u = 0; u < i; u++) { s = n[u], a = s.projectionDelta; const { visualElement: c } = s.options; c && c.props.style && c.props.style.display === "contents" || (r && s.options.layoutScroll && s.scroll && s !== s.root && Ws(t, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), a && (e.x *= a.x.scale, e.y *= a.y.scale, yC(t, a)), r && Ko(s.latestValues) && Ws(t, s.latestValues)) } e.x < cx && e.x > ux && (e.x = 1), e.y < cx && e.y > ux && (e.y = 1) } function Us(t, e) { t.min = t.min + e, t.max = t.max + e } function fx(t, e, n, r, i = .5) { const s = Bt(t.min, t.max, i); a0(t, e, n, s, r) } function Ws(t, e) { fx(t.x, e.x, e.scaleX, e.scale, e.originX), fx(t.y, e.y, e.scaleY, e.scale, e.originY) } function xC(t, e) { return mC(HR(t.getBoundingClientRect(), e)) } function GR(t, e, n) { const r = xC(t, n), { scroll: i } = e; return i && (Us(r.x, i.offset.x), Us(r.y, i.offset.y)), r } const wC = ({ current: t }) => t ? t.ownerDocument.defaultView : null, XR = new WeakMap; let ZR = class { constructor(e) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Zt(), this.visualElement = e } start(e, { snapToCursor: n = !1 } = {}) { const { presenceContext: r } = this.visualElement; if (r && r.isPresent === !1) return; const i = h => { const { dragSnapToOrigin: v } = this.getProps(); v ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(tu(h).point) }, s = (h, v) => { const { drag: m, dragPropagation: g, onDragStart: S } = this.getProps(); if (m && !g && (this.openDragLock && this.openDragLock(), this.openDragLock = kR(m), !this.openDragLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Cr(P => { let C = this.getAxisMotionValue(P).get() || 0; if (ti.test(C)) { const { projection: F } = this.visualElement; if (F && F.layout) { const A = F.layout.layoutBox[P]; A && (C = ar(A) * (parseFloat(C) / 100)) } } this.originPoint[P] = C }), S && Dt.postRender(() => S(h, v)), r0(this.visualElement, "transform"); const { animationState: b } = this.visualElement; b && b.setActive("whileDrag", !0) }, a = (h, v) => { const { dragPropagation: m, dragDirectionLock: g, onDirectionLock: S, onDrag: b } = this.getProps(); if (!m && !this.openDragLock) return; const { offset: P } = v; if (g && this.currentDirection === null) { this.currentDirection = YR(P), this.currentDirection !== null && S && S(this.currentDirection); return } this.updateAxis("x", v.point, P), this.updateAxis("y", v.point, P), this.visualElement.render(), b && b(h, v) }, u = (h, v) => this.stop(h, v), c = () => Cr(h => { var v; return this.getAnimationState(h) === "paused" && ((v = this.getAxisMotionValue(h).animation) === null || v === void 0 ? void 0 : v.play()) }), { dragSnapToOrigin: f } = this.getProps(); this.panSession = new dC(e, { onSessionStart: i, onStart: s, onMove: a, onSessionEnd: u, resumeAnimation: c }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: f, contextWindow: wC(this.visualElement) }) } stop(e, n) { const r = this.isDragging; if (this.cancel(), !r) return; const { velocity: i } = n; this.startAnimation(i); const { onDragEnd: s } = this.getProps(); s && Dt.postRender(() => s(e, n)) } cancel() { this.isDragging = !1; const { projection: e, animationState: n } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } updateAxis(e, n, r) { const { drag: i } = this.getProps(); if (!r || !Cc(e, i, this.currentDirection)) return; const s = this.getAxisMotionValue(e); let a = this.originPoint[e] + r[e]; this.constraints && this.constraints[e] && (a = LR(a, this.constraints[e], this.elastic[e])), s.set(a) } resolveConstraints() { var e; const { dragConstraints: n, dragElastic: r } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s = this.constraints; n && Is(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = jR(i.layoutBox, n) : this.constraints = !1, this.elastic = WR(r), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Cr(a => { this.constraints !== !1 && this.getAxisMotionValue(a) && (this.constraints[a] = UR(i.layoutBox[a], this.constraints[a])) }) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps(); if (!e || !Is(e)) return !1; const r = e.current, { projection: i } = this.visualElement; if (!i || !i.layout) return !1; const s = GR(r, i.root, this.visualElement.getTransformPagePoint()); let a = IR(i.layout.layoutBox, s); if (n) { const u = n(KR(a)); this.hasMutatedConstraints = !!u, u && (a = mC(u)) } return a } startAnimation(e) { const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: s, dragSnapToOrigin: a, onDragTransitionEnd: u } = this.getProps(), c = this.constraints || {}, f = Cr(h => { if (!Cc(h, n, this.currentDirection)) return; let v = c[h] || {}; a && (v = { min: 0, max: 0 }); const m = i ? 200 : 1e6, g = i ? 40 : 1e7, S = { type: "inertia", velocity: r ? e[h] : 0, bounceStiffness: m, bounceDamping: g, timeConstant: 750, restDelta: 1, restSpeed: 10, ...s, ...v }; return this.startAxisValueAnimation(h, S) }); return Promise.all(f).then(u) } startAxisValueAnimation(e, n) { const r = this.getAxisMotionValue(e); return r0(this.visualElement, e), r.start(pv(e, r, 0, n, this.visualElement, !1)) } stopAnimation() { Cr(e => this.getAxisMotionValue(e).stop()) } pauseAnimation() { Cr(e => { var n; return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.pause() }) } getAnimationState(e) { var n; return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.state } getAxisMotionValue(e) { const n = `_drag${e.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n]; return i || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0) } snapToCursor(e) { Cr(n => { const { drag: r } = this.getProps(); if (!Cc(n, r, this.currentDirection)) return; const { projection: i } = this.visualElement, s = this.getAxisMotionValue(n); if (i && i.layout) { const { min: a, max: u } = i.layout.layoutBox[n]; s.set(e[n] - Bt(a, u, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!Is(n) || !r || !this.constraints) return; this.stopAnimation(); const i = { x: 0, y: 0 }; Cr(a => { const u = this.getAxisMotionValue(a); if (u && this.constraints !== !1) { const c = u.get(); i[a] = zR({ min: c, max: c }, this.constraints[a]) } }); const { transformTemplate: s } = this.visualElement.getProps(); this.visualElement.current.style.transform = s ? s({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Cr(a => { if (!Cc(a, e, null)) return; const u = this.getAxisMotionValue(a), { min: c, max: f } = this.constraints[a]; u.set(Bt(c, f, i[a])) }) } addListeners() { if (!this.visualElement.current) return; XR.set(this.visualElement, this); const e = this.visualElement.current, n = wl(e, "pointerdown", c => { const { drag: f, dragListener: h = !0 } = this.getProps(); f && h && this.start(c) }), r = () => { const { dragConstraints: c } = this.getProps(); Is(c) && c.current && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, s = i.addEventListener("measure", r); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Dt.read(r); const a = jl(window, "resize", () => this.scalePositionWithinConstraints()), u = i.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: f }) => { this.isDragging && f && (Cr(h => { const v = this.getAxisMotionValue(h); v && (this.originPoint[h] += c[h].translate, v.set(v.get() + c[h].translate)) }), this.visualElement.render()) }); return () => { a(), n(), s(), u && u() } } getProps() { const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: s = !1, dragElastic: a = o0, dragMomentum: u = !0 } = e; return { ...e, drag: n, dragDirectionLock: r, dragPropagation: i, dragConstraints: s, dragElastic: a, dragMomentum: u } } }; function Cc(t, e, n) { return (e === !0 || e === t) && (n === null || n === t) } function YR(t, e = 10) { let n = null; return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n } let QR = class extends wo { constructor(e) { super(e), this.removeGroupControls = ir, this.removeListeners = ir, this.controls = new ZR(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || ir } unmount() { this.removeGroupControls(), this.removeListeners() } }; const dx = t => (e, n) => { t && Dt.postRender(() => t(e, n)) }; let JR = class extends wo { constructor() { super(...arguments), this.removePointerDownListener = ir } onPointerDown(e) { this.session = new dC(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: wC(this.node) }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps(); return { onSessionStart: dx(e), onStart: dx(n), onMove: r, onEnd: (s, a) => { delete this.session, i && Dt.postRender(() => i(s, a)) } } } mount() { this.removePointerDownListener = wl(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } }; const wv = j.createContext(null); function _R() { const t = j.useContext(wv); if (t === null) return [!0, null]; const { isPresent: e, onExitComplete: n, register: r } = t, i = j.useId(); j.useEffect(() => r(i), []); const s = j.useCallback(() => n && n(i), [i, n]); return !e && n ? [!1, s] : [!0] } const SC = j.createContext({}), bC = j.createContext({}), Uc = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function hx(t, e) { return e.max === e.min ? 0 : t / (e.max - e.min) * 100 } const Ja = { correct: (t, e) => { if (!e.target) return t; if (typeof t == "string") if (Ke.test(t)) t = parseFloat(t); else return t; const n = hx(t, e.target.x), r = hx(t, e.target.y); return `${n}% ${r}%` } }, $R = { correct: (t, { treeScale: e, projectionDelta: n }) => { const r = t, i = fo.parse(t); if (i.length > 5) return r; const s = fo.createTransformer(t), a = typeof i[0] != "number" ? 1 : 0, u = n.x.scale * e.x, c = n.y.scale * e.y; i[0 + a] /= u, i[1 + a] /= c; const f = Bt(u, c, .5); return typeof i[2 + a] == "number" && (i[2 + a] /= f), typeof i[3 + a] == "number" && (i[3 + a] /= f), s(i) } }, af = {}; function eD(t) { Object.assign(af, t) } const { schedule: Sv, cancel: _4 } = bb(queueMicrotask, !1); let tD = class extends j.Component { componentDidMount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: s } = e; eD(nD), s && (n.group && n.group.add(s), r && r.register && i && r.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => { this.safeToRemove() }), s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })), Uc.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: n, visualElement: r, drag: i, isPresent: s } = this.props, a = r.projection; return a && (a.isPresent = s, i || e.layoutDependency !== n || n === void 0 ? a.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? a.promote() : a.relegate() || Dt.postRender(() => { const u = a.getStack(); (!u || !u.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), Sv.postRender(() => { !e.currentAnimation && e.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = e; i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } }; function CC(t) { const [e, n] = _R(), r = j.useContext(SC); return De.jsx(tD, { ...t, layoutGroup: r, switchLayoutGroup: j.useContext(bC), isPresent: e, safeToRemove: n }) } const nD = { borderRadius: { ...Ja, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Ja, borderTopRightRadius: Ja, borderBottomLeftRadius: Ja, borderBottomRightRadius: Ja, boxShadow: $R }, PC = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], rD = PC.length, px = t => typeof t == "string" ? parseFloat(t) : t, vx = t => typeof t == "number" || Ke.test(t); function iD(t, e, n, r, i, s) { i ? (t.opacity = Bt(0, n.opacity !== void 0 ? n.opacity : 1, oD(r)), t.opacityExit = Bt(e.opacity !== void 0 ? e.opacity : 1, 0, sD(r))) : s && (t.opacity = Bt(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r)); for (let a = 0; a < rD; a++) { const u = `border${PC[a]}Radius`; let c = mx(e, u), f = mx(n, u); if (c === void 0 && f === void 0) continue; c || (c = 0), f || (f = 0), c === 0 || f === 0 || vx(c) === vx(f) ? (t[u] = Math.max(Bt(px(c), px(f), r), 0), (ti.test(f) || ti.test(c)) && (t[u] += "%")) : t[u] = f } (e.rotate || n.rotate) && (t.rotate = Bt(e.rotate || 0, n.rotate || 0, r)) } function mx(t, e) { return t[e] !== void 0 ? t[e] : t.borderRadius } const oD = TC(0, .5, Fb), sD = TC(.5, .95, ir); function TC(t, e, n) { return r => r < t ? 0 : r > e ? 1 : n(ea(t, e, r)) } function gx(t, e) { t.min = e.min, t.max = e.max } function xr(t, e) { gx(t.x, e.x), gx(t.y, e.y) } function yx(t, e) { t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin } function xx(t, e, n, r, i) { return t -= e, t = sf(t, 1 / n, r), i !== void 0 && (t = sf(t, 1 / i, r)), t } function aD(t, e = 0, n = 1, r = .5, i, s = t, a = t) { if (ti.test(e) && (e = parseFloat(e), e = Bt(a.min, a.max, e / 100) - a.min), typeof e != "number") return; let u = Bt(s.min, s.max, r); t === s && (u -= e), t.min = xx(t.min, e, n, u, i), t.max = xx(t.max, e, n, u, i) } function wx(t, e, [n, r, i], s, a) { aD(t, e[n], e[r], e[i], e.scale, s, a) } const lD = ["x", "scaleX", "originX"], uD = ["y", "scaleY", "originY"]; function Sx(t, e, n, r) { wx(t.x, e, lD, n ? n.x : void 0, r ? r.x : void 0), wx(t.y, e, uD, n ? n.y : void 0, r ? r.y : void 0) } function bx(t) { return t.translate === 0 && t.scale === 1 } function kC(t) { return bx(t.x) && bx(t.y) } function Cx(t, e) { return t.min === e.min && t.max === e.max } function cD(t, e) { return Cx(t.x, e.x) && Cx(t.y, e.y) } function Px(t, e) { return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max) } function AC(t, e) { return Px(t.x, e.x) && Px(t.y, e.y) } function Tx(t) { return ar(t.x) / ar(t.y) } function kx(t, e) { return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint } let fD = class { constructor() { this.members = [] } add(e) { vv(this.members, e), e.scheduleRender() } remove(e) { if (mv(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(e) { const n = this.members.findIndex(i => e === i); if (n === 0) return !1; let r; for (let i = n; i >= 0; i--) { const s = this.members[i]; if (s.isPresent !== !1) { r = s; break } } return r ? (this.promote(r), !0) : !1 } promote(e, n) { const r = this.lead; if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) { r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: i } = e.options; i === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(e => { const { options: n, resumingFrom: r } = e; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } }; function dD(t, e, n) { let r = ""; const i = t.x.translate / e.x, s = t.y.translate / e.y, a = (n == null ? void 0 : n.z) || 0; if ((i || s || a) && (r = `translate3d(${i}px, ${s}px, ${a}px) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `), n) { const { transformPerspective: f, rotate: h, rotateX: v, rotateY: m, skewX: g, skewY: S } = n; f && (r = `perspective(${f}px) ${r}`), h && (r += `rotate(${h}deg) `), v && (r += `rotateX(${v}deg) `), m && (r += `rotateY(${m}deg) `), g && (r += `skewX(${g}deg) `), S && (r += `skewY(${S}deg) `) } const u = t.x.scale * e.x, c = t.y.scale * e.y; return (u !== 1 || c !== 1) && (r += `scale(${u}, ${c})`), r || "none" } const hD = (t, e) => t.depth - e.depth; let pD = class { constructor() { this.children = [], this.isDirty = !1 } add(e) { vv(this.children, e), this.isDirty = !0 } remove(e) { mv(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(hD), this.isDirty = !1, this.children.forEach(e) } }; function Wc(t) { const e = Fn(t) ? t.get() : t; return _F(e) ? e.toValue() : e } function vD(t, e) { const n = ni.now(), r = ({ timestamp: i }) => { const s = i - n; s >= e && (co(r), t(s - e)) }; return Dt.read(r, !0), () => co(r) } function mD(t) { return t instanceof SVGElement && t.tagName !== "svg" } function gD(t, e, n) { const r = Fn(t) ? t : Ll(t); return r.start(pv("", r, e, n)), r.animation } const Ho = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, ul = typeof window < "u" && window.MotionDebug !== void 0, cp = ["", "X", "Y", "Z"], yD = { visibility: "hidden" }, Ax = 1e3; let xD = 0; function fp(t, e, n, r) { const { latestValues: i } = e; i[t] && (n[t] = i[t], e.setStaticValue(t, 0), r && (r[t] = 0)) } function EC(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; const { visualElement: e } = t.options; if (!e) return; const n = sC(e); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: i, layoutId: s } = t.options; window.MotionCancelOptimisedAnimation(n, "transform", Dt, !(i || s)) } const { parent: r } = t; r && !r.hasCheckedOptimisedAppear && EC(r) } function FC({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(a = {}, u = e == null ? void 0 : e()) { this.id = xD++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, ul && (Ho.totalNodes = Ho.resolvedTargetDeltas = Ho.recalculatedProjection = 0), this.nodes.forEach(bD), this.nodes.forEach(AD), this.nodes.forEach(ED), this.nodes.forEach(CD), ul && window.MotionDebug.record(Ho) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = a, this.root = u ? u.root || u : this, this.path = u ? [...u.path, u] : [], this.parent = u, this.depth = u ? u.depth + 1 : 0; for (let c = 0; c < this.path.length; c++)this.path[c].shouldResetTransform = !0; this.root === this && (this.nodes = new pD) } addEventListener(a, u) { return this.eventHandlers.has(a) || this.eventHandlers.set(a, new gv), this.eventHandlers.get(a).add(u) } notifyListeners(a, ...u) { const c = this.eventHandlers.get(a); c && c.notify(...u) } hasListeners(a) { return this.eventHandlers.has(a) } mount(a, u = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = mD(a), this.instance = a; const { layoutId: c, layout: f, visualElement: h } = this.options; if (h && !h.current && h.mount(a), this.root.nodes.add(this), this.parent && this.parent.children.add(this), u && (f || c) && (this.isLayoutDirty = !0), t) { let v; const m = () => this.root.updateBlockedByResize = !1; t(a, () => { this.root.updateBlockedByResize = !0, v && v(), v = vD(m, 250), Uc.hasAnimatedSinceResize && (Uc.hasAnimatedSinceResize = !1, this.nodes.forEach(Fx)) }) } c && this.root.registerSharedNode(c, this), this.options.animate !== !1 && h && (c || f) && this.addEventListener("didUpdate", ({ delta: v, hasLayoutChanged: m, hasRelativeTargetChanged: g, layout: S }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const b = this.options.transition || h.getDefaultTransition() || MD, { onLayoutAnimationStart: P, onLayoutAnimationComplete: C } = h.getProps(), F = !this.targetLayout || !AC(this.targetLayout, S) || g, A = !m && g; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || A || m && (F || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(v, A); const N = { ...ev(b, "layout"), onPlay: P, onComplete: C }; (h.shouldReduceMotion || this.options.layoutRoot) && (N.delay = 0, N.type = !1), this.startAnimation(N) } else m || Fx(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = S }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const a = this.getStack(); a && a.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, co(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(FD), this.animationId++) } getTransformTemplate() { const { visualElement: a } = this.options; return a && a.getProps().transformTemplate } willUpdate(a = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && EC(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let h = 0; h < this.path.length; h++) { const v = this.path[h]; v.shouldResetTransform = !0, v.updateScroll("snapshot"), v.options.layoutRoot && v.willUpdate(!1) } const { layoutId: u, layout: c } = this.options; if (u === void 0 && !c) return; const f = this.getTransformTemplate(); this.prevTransformTemplateValue = f ? f(this.latestValues, "") : void 0, this.updateSnapshot(), a && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Ex); return } this.isUpdating || this.nodes.forEach(TD), this.isUpdating = !1, this.nodes.forEach(kD), this.nodes.forEach(wD), this.nodes.forEach(SD), this.clearAllSnapshots(); const u = ni.now(); xn.delta = Ri(0, 1e3 / 60, u - xn.timestamp), xn.timestamp = u, xn.isProcessing = !0, tp.update.process(xn), tp.preRender.process(xn), tp.render.process(xn), xn.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Sv.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(PD), this.sharedNodes.forEach(RD) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Dt.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Dt.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let c = 0; c < this.path.length; c++)this.path[c].updateScroll(); const a = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Zt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: u } = this.options; u && u.notify("LayoutMeasure", this.layout.layoutBox, a ? a.layoutBox : void 0) } updateScroll(a = "measure") { let u = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === a && (u = !1), u) { const c = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: a, isRoot: c, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : c } } } resetTransform() { if (!i) return; const a = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, u = this.projectionDelta && !kC(this.projectionDelta), c = this.getTransformTemplate(), f = c ? c(this.latestValues, "") : void 0, h = f !== this.prevTransformTemplateValue; a && (u || Ko(this.latestValues) || h) && (i(this.instance, f), this.shouldResetTransform = !1, this.scheduleRender()) } measure(a = !0) { const u = this.measurePageBox(); let c = this.removeElementScroll(u); return a && (c = this.removeTransform(c)), VD(c), { animationId: this.root.animationId, measuredBox: u, layoutBox: c, latestValues: {}, source: this.id } } measurePageBox() { var a; const { visualElement: u } = this.options; if (!u) return Zt(); const c = u.measureViewportBox(); if (!(((a = this.scroll) === null || a === void 0 ? void 0 : a.wasRoot) || this.path.some(ND))) { const { scroll: h } = this.root; h && (Us(c.x, h.offset.x), Us(c.y, h.offset.y)) } return c } removeElementScroll(a) { var u; const c = Zt(); if (xr(c, a), !((u = this.scroll) === null || u === void 0) && u.wasRoot) return c; for (let f = 0; f < this.path.length; f++) { const h = this.path[f], { scroll: v, options: m } = h; h !== this.root && v && m.layoutScroll && (v.wasRoot && xr(c, a), Us(c.x, v.offset.x), Us(c.y, v.offset.y)) } return c } applyTransform(a, u = !1) { const c = Zt(); xr(c, a); for (let f = 0; f < this.path.length; f++) { const h = this.path[f]; !u && h.options.layoutScroll && h.scroll && h !== h.root && Ws(c, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }), Ko(h.latestValues) && Ws(c, h.latestValues) } return Ko(this.latestValues) && Ws(c, this.latestValues), c } removeTransform(a) { const u = Zt(); xr(u, a); for (let c = 0; c < this.path.length; c++) { const f = this.path[c]; if (!f.instance || !Ko(f.latestValues)) continue; s0(f.latestValues) && f.updateSnapshot(); const h = Zt(), v = f.measurePageBox(); xr(h, v), Sx(u, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, h) } return Ko(this.latestValues) && Sx(u, this.latestValues), u } setTargetDelta(a) { this.targetDelta = a, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(a) { this.options = { ...this.options, ...a, crossfade: a.crossfade !== void 0 ? a.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== xn.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(a = !1) { var u; const c = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = c.isSharedProjectionDirty); const f = !!this.resumingFrom || this !== c; if (!(a || f && this.isSharedProjectionDirty || this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: v, layoutId: m } = this.options; if (!(!this.layout || !(v || m))) { if (this.resolvedRelativeTargetAt = xn.timestamp, !this.targetDelta && !this.relativeTarget) { const g = this.getClosestProjectingParent(); g && g.layout && this.animationProgress !== 1 ? (this.relativeParent = g, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Zt(), this.relativeTargetOrigin = Zt(), bl(this.relativeTargetOrigin, this.layout.layoutBox, g.layout.layoutBox), xr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Zt(), this.targetWithTransforms = Zt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), BR(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : xr(this.target, this.layout.layoutBox), yC(this.target, this.targetDelta)) : xr(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const g = this.getClosestProjectingParent(); g && !!g.resumingFrom == !!this.resumingFrom && !g.options.layoutScroll && g.target && this.animationProgress !== 1 ? (this.relativeParent = g, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Zt(), this.relativeTargetOrigin = Zt(), bl(this.relativeTargetOrigin, this.target, g.target), xr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } ul && Ho.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || s0(this.parent.latestValues) || gC(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var a; const u = this.getLead(), c = !!this.resumingFrom || this !== u; let f = !0; if ((this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty) && (f = !1), c && (this.isSharedProjectionDirty || this.isTransformDirty) && (f = !1), this.resolvedRelativeTargetAt === xn.timestamp && (f = !1), f) return; const { layout: h, layoutId: v } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || v)) return; xr(this.layoutCorrected, this.layout.layoutBox); const m = this.treeScale.x, g = this.treeScale.y; qR(this.layoutCorrected, this.treeScale, this.path, c), u.layout && !u.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (u.target = u.layout.layoutBox, u.targetWithTransforms = Zt()); const { target: S } = u; if (!S) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (yx(this.prevProjectionDelta.x, this.projectionDelta.x), yx(this.prevProjectionDelta.y, this.projectionDelta.y)), Sl(this.projectionDelta, this.layoutCorrected, S, this.latestValues), (this.treeScale.x !== m || this.treeScale.y !== g || !kx(this.projectionDelta.x, this.prevProjectionDelta.x) || !kx(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", S)), ul && Ho.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(a = !0) { var u; if ((u = this.options.visualElement) === null || u === void 0 || u.scheduleRender(), a) { const c = this.getStack(); c && c.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = zs(), this.projectionDelta = zs(), this.projectionDeltaWithTransform = zs() } setAnimationOrigin(a, u = !1) { const c = this.snapshot, f = c ? c.latestValues : {}, h = { ...this.latestValues }, v = zs(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !u; const m = Zt(), g = c ? c.source : void 0, S = this.layout ? this.layout.source : void 0, b = g !== S, P = this.getStack(), C = !P || P.members.length <= 1, F = !!(b && !C && this.options.crossfade === !0 && !this.path.some(OD)); this.animationProgress = 0; let A; this.mixTargetDelta = N => { const D = N / 1e3; Rx(v.x, a.x, D), Rx(v.y, a.y, D), this.setTargetDelta(v), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (bl(m, this.layout.layoutBox, this.relativeParent.layout.layoutBox), DD(this.relativeTarget, this.relativeTargetOrigin, m, D), A && cD(this.relativeTarget, A) && (this.isProjectionDirty = !1), A || (A = Zt()), xr(A, this.relativeTarget)), b && (this.animationValues = h, iD(h, f, this.latestValues, D, F, C)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = D }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(a) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (co(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Dt.update(() => { Uc.hasAnimatedSinceResize = !0, this.currentAnimation = gD(0, Ax, { ...a, onUpdate: u => { this.mixTargetDelta(u), a.onUpdate && a.onUpdate(u) }, onComplete: () => { a.onComplete && a.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const a = this.getStack(); a && a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Ax), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const a = this.getLead(); let { targetWithTransforms: u, target: c, layout: f, latestValues: h } = a; if (!(!u || !c || !f)) { if (this !== a && this.layout && f && RC(this.options.animationType, this.layout.layoutBox, f.layoutBox)) { c = this.target || Zt(); const v = ar(this.layout.layoutBox.x); c.x.min = a.target.x.min, c.x.max = c.x.min + v; const m = ar(this.layout.layoutBox.y); c.y.min = a.target.y.min, c.y.max = c.y.min + m } xr(u, c), Ws(u, h), Sl(this.projectionDeltaWithTransform, this.layoutCorrected, u, h) } } registerSharedNode(a, u) { this.sharedNodes.has(a) || this.sharedNodes.set(a, new fD), this.sharedNodes.get(a).add(u); const f = u.options.initialPromotionConfig; u.promote({ transition: f ? f.transition : void 0, preserveFollowOpacity: f && f.shouldPreserveFollowOpacity ? f.shouldPreserveFollowOpacity(u) : void 0 }) } isLead() { const a = this.getStack(); return a ? a.lead === this : !0 } getLead() { var a; const { layoutId: u } = this.options; return u ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) || this : this } getPrevLead() { var a; const { layoutId: u } = this.options; return u ? (a = this.getStack()) === null || a === void 0 ? void 0 : a.prevLead : void 0 } getStack() { const { layoutId: a } = this.options; if (a) return this.root.sharedNodes.get(a) } promote({ needsReset: a, transition: u, preserveFollowOpacity: c } = {}) { const f = this.getStack(); f && f.promote(this, c), a && (this.projectionDelta = void 0, this.needsReset = !0), u && this.setOptions({ transition: u }) } relegate() { const a = this.getStack(); return a ? a.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: a } = this.options; if (!a) return; let u = !1; const { latestValues: c } = a; if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (u = !0), !u) return; const f = {}; c.z && fp("z", a, f, this.animationValues); for (let h = 0; h < cp.length; h++)fp(`rotate${cp[h]}`, a, f, this.animationValues), fp(`skew${cp[h]}`, a, f, this.animationValues); a.render(); for (const h in f) a.setStaticValue(h, f[h]), this.animationValues && (this.animationValues[h] = f[h]); a.scheduleRender() } getProjectionStyles(a) { var u, c; if (!this.instance || this.isSVG) return; if (!this.isVisible) return yD; const f = { visibility: "" }, h = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, f.opacity = "", f.pointerEvents = Wc(a == null ? void 0 : a.pointerEvents) || "", f.transform = h ? h(this.latestValues, "") : "none", f; const v = this.getLead(); if (!this.projectionDelta || !this.layout || !v.target) { const b = {}; return this.options.layoutId && (b.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, b.pointerEvents = Wc(a == null ? void 0 : a.pointerEvents) || ""), this.hasProjected && !Ko(this.latestValues) && (b.transform = h ? h({}, "") : "none", this.hasProjected = !1), b } const m = v.animationValues || v.latestValues; this.applyTransformsToTarget(), f.transform = dD(this.projectionDeltaWithTransform, this.treeScale, m), h && (f.transform = h(m, f.transform)); const { x: g, y: S } = this.projectionDelta; f.transformOrigin = `${g.origin * 100}% ${S.origin * 100}% 0`, v.animationValues ? f.opacity = v === this ? (c = (u = m.opacity) !== null && u !== void 0 ? u : this.latestValues.opacity) !== null && c !== void 0 ? c : 1 : this.preserveOpacity ? this.latestValues.opacity : m.opacityExit : f.opacity = v === this ? m.opacity !== void 0 ? m.opacity : "" : m.opacityExit !== void 0 ? m.opacityExit : 0; for (const b in af) { if (m[b] === void 0) continue; const { correct: P, applyTo: C } = af[b], F = f.transform === "none" ? m[b] : P(m[b], v); if (C) { const A = C.length; for (let N = 0; N < A; N++)f[C[N]] = F } else f[b] = F } return this.options.layoutId && (f.pointerEvents = v === this ? Wc(a == null ? void 0 : a.pointerEvents) || "" : "none"), f } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(a => { var u; return (u = a.currentAnimation) === null || u === void 0 ? void 0 : u.stop() }), this.root.nodes.forEach(Ex), this.root.sharedNodes.clear() } } } function wD(t) { t.updateLayout() } function SD(t) { var e; const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot; if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) { const { layoutBox: r, measuredBox: i } = t.layout, { animationType: s } = t.options, a = n.source !== t.layout.source; s === "size" ? Cr(v => { const m = a ? n.measuredBox[v] : n.layoutBox[v], g = ar(m); m.min = r[v].min, m.max = m.min + g }) : RC(s, n.layoutBox, r) && Cr(v => { const m = a ? n.measuredBox[v] : n.layoutBox[v], g = ar(r[v]); m.max = m.min + g, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[v].max = t.relativeTarget[v].min + g) }); const u = zs(); Sl(u, r, n.layoutBox); const c = zs(); a ? Sl(c, t.applyTransform(i, !0), n.measuredBox) : Sl(c, r, n.layoutBox); const f = !kC(u); let h = !1; if (!t.resumeFrom) { const v = t.getClosestProjectingParent(); if (v && !v.resumeFrom) { const { snapshot: m, layout: g } = v; if (m && g) { const S = Zt(); bl(S, n.layoutBox, m.layoutBox); const b = Zt(); bl(b, r, g.layoutBox), AC(S, b) || (h = !0), v.options.layoutRoot && (t.relativeTarget = b, t.relativeTargetOrigin = S, t.relativeParent = v) } } } t.notifyListeners("didUpdate", { layout: r, snapshot: n, delta: c, layoutDelta: u, hasLayoutChanged: f, hasRelativeTargetChanged: h }) } else if (t.isLead()) { const { onExitComplete: r } = t.options; r && r() } t.options.transition = void 0 } function bD(t) { ul && Ho.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function CD(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function PD(t) { t.clearSnapshot() } function Ex(t) { t.clearMeasurements() } function TD(t) { t.isLayoutDirty = !1 } function kD(t) { const { visualElement: e } = t.options; e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform() } function Fx(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function AD(t) { t.resolveTargetDelta() } function ED(t) { t.calcProjection() } function FD(t) { t.resetSkewAndRotation() } function RD(t) { t.removeLeadSnapshot() } function Rx(t, e, n) { t.translate = Bt(e.translate, 0, n), t.scale = Bt(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint } function Dx(t, e, n, r) { t.min = Bt(e.min, n.min, r), t.max = Bt(e.max, n.max, r) } function DD(t, e, n, r) { Dx(t.x, e.x, n.x, r), Dx(t.y, e.y, n.y, r) } function OD(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const MD = { duration: .45, ease: [.4, 0, .1, 1] }, Ox = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), Mx = Ox("applewebkit/") && !Ox("chrome/") ? Math.round : ir; function Vx(t) { t.min = Mx(t.min), t.max = Mx(t.max) } function VD(t) { Vx(t.x), Vx(t.y) } function RC(t, e, n) { return t === "position" || t === "preserve-aspect" && !NR(Tx(e), Tx(n), .2) } function ND(t) { var e; return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot) } const BD = FC({ attachResizeListener: (t, e) => jl(t, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), dp = { current: void 0 }, DC = FC({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!dp.current) { const t = new BD({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), dp.current = t } return dp.current }, resetTransform: (t, e) => { t.style.transform = e !== void 0 ? e : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), LD = { pan: { Feature: JR }, drag: { Feature: QR, ProjectionNode: DC, MeasureLayout: CC } }; function Nx(t, e, n) { const { props: r } = t; t.animationState && r.whileHover && t.animationState.setActive("whileHover", n === "Start"); const i = "onHover" + n, s = r[i]; s && Dt.postRender(() => s(e, tu(e))) } let jD = class extends wo { mount() { const { current: e } = this.node; e && (this.unmount = SR(e, n => (Nx(this.node, n, "Start"), r => Nx(this.node, r, "End")))) } unmount() { } }, ID = class extends wo { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = eu(jl(this.node.current, "focus", () => this.onFocus()), jl(this.node.current, "blur", () => this.onBlur())) } unmount() { } }; function Bx(t, e, n) { const { props: r } = t; t.animationState && r.whileTap && t.animationState.setActive("whileTap", n === "Start"); const i = "onTap" + (n === "End" ? "" : n), s = r[i]; s && Dt.postRender(() => s(e, tu(e))) } let zD = class extends wo { mount() { const { current: e } = this.node; e && (this.unmount = TR(e, n => (Bx(this.node, n, "Start"), (r, { success: i }) => Bx(this.node, r, i ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } }; const l0 = new WeakMap, hp = new WeakMap, UD = t => { const e = l0.get(t.target); e && e(t) }, WD = t => { t.forEach(UD) }; function KD({ root: t, ...e }) { const n = t || document; hp.has(n) || hp.set(n, {}); const r = hp.get(n), i = JSON.stringify(e); return r[i] || (r[i] = new IntersectionObserver(WD, { root: t, ...e })), r[i] } function HD(t, e, n) { const r = KD(e); return l0.set(t, n), r.observe(t), () => { l0.delete(t), r.unobserve(t) } } const qD = { some: 0, all: 1 }; let GD = class extends wo { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: s } = e, a = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof i == "number" ? i : qD[i] }, u = c => { const { isIntersecting: f } = c; if (this.isInView === f || (this.isInView = f, s && !f && this.hasEnteredView)) return; f && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", f); const { onViewportEnter: h, onViewportLeave: v } = this.node.getProps(), m = f ? h : v; m && m(c) }; return HD(this.node.current, a, u) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: e, prevProps: n } = this.node;["amount", "margin", "root"].some(XD(e, n)) && this.startObserver() } unmount() { } }; function XD({ viewport: t = {} }, { viewport: e = {} } = {}) { return n => t[n] !== e[n] } const ZD = { inView: { Feature: GD }, tap: { Feature: zD }, focus: { Feature: ID }, hover: { Feature: jD } }, YD = { layout: { ProjectionNode: DC, MeasureLayout: CC } }, OC = j.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }), Bf = j.createContext({}), bv = typeof window < "u", QD = bv ? j.useLayoutEffect : j.useEffect, MC = j.createContext({ strict: !1 }); function JD(t, e, n, r, i) { var s, a; const { visualElement: u } = j.useContext(Bf), c = j.useContext(MC), f = j.useContext(wv), h = j.useContext(OC).reducedMotion, v = j.useRef(null); r = r || c.renderer, !v.current && r && (v.current = r(t, { visualState: e, parent: u, props: n, presenceContext: f, blockInitialAnimation: f ? f.initial === !1 : !1, reducedMotionConfig: h })); const m = v.current, g = j.useContext(bC); m && !m.projection && i && (m.type === "html" || m.type === "svg") && _D(v.current, n, i, g); const S = j.useRef(!1); j.useInsertionEffect(() => { m && S.current && m.update(n, f) }); const b = n[oC], P = j.useRef(!!b && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, b)) && ((a = window.MotionHasOptimisedAnimation) === null || a === void 0 ? void 0 : a.call(window, b))); return QD(() => { m && (S.current = !0, window.MotionIsMounted = !0, m.updateFeatures(), Sv.render(m.render), P.current && m.animationState && m.animationState.animateChanges()) }), j.useEffect(() => { m && (!P.current && m.animationState && m.animationState.animateChanges(), P.current && (queueMicrotask(() => { var C; (C = window.MotionHandoffMarkAsComplete) === null || C === void 0 || C.call(window, b) }), P.current = !1)) }), m } function _D(t, e, n, r) { const { layoutId: i, layout: s, drag: a, dragConstraints: u, layoutScroll: c, layoutRoot: f } = e; t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : VC(t.parent)), t.projection.setOptions({ layoutId: i, layout: s, alwaysMeasureLayout: !!a || u && Is(u), visualElement: t, animationType: typeof s == "string" ? s : "both", initialPromotionConfig: r, layoutScroll: c, layoutRoot: f }) } function VC(t) { if (t) return t.options.allowProjection !== !1 ? t.projection : VC(t.parent) } function $D(t, e, n) { return j.useCallback(r => { r && t.mount && t.mount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : Is(n) && (n.current = r)) }, [e]) } function Lf(t) { return Mf(t.animate) || $0.some(e => Vl(t[e])) } function NC(t) { return !!(Lf(t) || t.variants) } function eO(t, e) { if (Lf(t)) { const { initial: n, animate: r } = t; return { initial: n === !1 || Vl(n) ? n : void 0, animate: Vl(r) ? r : void 0 } } return t.inherit !== !1 ? e : {} } function tO(t) { const { initial: e, animate: n } = eO(t, j.useContext(Bf)); return j.useMemo(() => ({ initial: e, animate: n }), [Lx(e), Lx(n)]) } function Lx(t) { return Array.isArray(t) ? t.join(" ") : t } const jx = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, ta = {}; for (const t in jx) ta[t] = { isEnabled: e => jx[t].some(n => !!e[n]) }; function nO(t) { for (const e in t) ta[e] = { ...ta[e], ...t[e] } } const rO = Symbol.for("motionComponentSymbol"); function iO({ preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: r, Component: i }) { t && nO(t); function s(u, c) { let f; const h = { ...j.useContext(OC), ...u, layoutId: oO(u) }, { isStatic: v } = h, m = tO(u), g = r(u, v); if (!v && bv) { sO(); const S = aO(h); f = S.MeasureLayout, m.visualElement = JD(i, g, h, e, S.ProjectionNode) } return De.jsxs(Bf.Provider, { value: m, children: [f && m.visualElement ? De.jsx(f, { visualElement: m.visualElement, ...h }) : null, n(i, u, $D(g, m.visualElement, c), g, v, m.visualElement)] }) } const a = j.forwardRef(s); return a[rO] = i, a } function oO({ layoutId: t }) { const e = j.useContext(SC).id; return e && t !== void 0 ? e + "-" + t : t } function sO(t, e) { j.useContext(MC).strict } function aO(t) { const { drag: e, layout: n } = ta; if (!e && !n) return {}; const r = { ...e, ...n }; return { MeasureLayout: e != null && e.isEnabled(t) || n != null && n.isEnabled(t) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } const lO = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Cv(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(lO.indexOf(t) > -1 || /[A-Z]/u.test(t)) } function BC(t, { style: e, vars: n }, r, i) { Object.assign(t.style, e, i && i.getProjectionStyles(r)); for (const s in n) t.style.setProperty(s, n[s]) } const LC = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function jC(t, e, n, r) { BC(t, e, void 0, r); for (const i in e.attrs) t.setAttribute(LC.has(i) ? i : yv(i), e.attrs[i]) } function IC(t, { layout: e, layoutId: n }) { return ts.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!af[t] || t === "opacity") } function Pv(t, e, n) { var r; const { style: i } = t, s = {}; for (const a in i) (Fn(i[a]) || e.style && Fn(e.style[a]) || IC(a, t) || ((r = n == null ? void 0 : n.getValue(a)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (s[a] = i[a]); return s } function zC(t, e, n) { const r = Pv(t, e, n); for (const i in t) if (Fn(t[i]) || Fn(e[i])) { const s = Jl.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[s] = t[i] } return r } function uO(t) { const e = j.useRef(null); return e.current === null && (e.current = t()), e.current } function cO({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: n }, r, i, s) { const a = { latestValues: fO(r, i, s, t), renderState: e() }; return n && (a.mount = u => n(r, u, a)), a } const UC = t => (e, n) => { const r = j.useContext(Bf), i = j.useContext(wv), s = () => cO(t, e, r, i); return n ? s() : uO(s) }; function fO(t, e, n, r) { const i = {}, s = r(t, {}); for (const m in s) i[m] = Wc(s[m]); let { initial: a, animate: u } = t; const c = Lf(t), f = NC(t); e && f && !c && t.inherit !== !1 && (a === void 0 && (a = e.initial), u === void 0 && (u = e.animate)); let h = n ? n.initial === !1 : !1; h = h || a === !1; const v = h ? u : a; if (v && typeof v != "boolean" && !Mf(v)) { const m = Array.isArray(v) ? v : [v]; for (let g = 0; g < m.length; g++) { const S = J0(t, m[g]); if (S) { const { transitionEnd: b, transition: P, ...C } = S; for (const F in C) { let A = C[F]; if (Array.isArray(A)) { const N = h ? A.length - 1 : 0; A = A[N] } A !== null && (i[F] = A) } for (const F in b) i[F] = b[F] } } } return i } const Tv = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }), WC = () => ({ ...Tv(), attrs: {} }), KC = (t, e) => e && typeof t == "number" ? e.transform(t) : t, dO = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, hO = Jl.length; function pO(t, e, n) { let r = "", i = !0; for (let s = 0; s < hO; s++) { const a = Jl[s], u = t[a]; if (u === void 0) continue; let c = !0; if (typeof u == "number" ? c = u === (a.startsWith("scale") ? 1 : 0) : c = parseFloat(u) === 0, !c || n) { const f = KC(u, av[a]); if (!c) { i = !1; const h = dO[a] || a; r += `${h}(${f}) ` } n && (e[a] = f) } } return r = r.trim(), n ? r = n(e, i ? "" : r) : i && (r = "none"), r } function kv(t, e, n) { const { style: r, vars: i, transformOrigin: s } = t; let a = !1, u = !1; for (const c in e) { const f = e[c]; if (ts.has(c)) { a = !0; continue } else if (Vb(c)) { i[c] = f; continue } else { const h = KC(f, av[c]); c.startsWith("origin") ? (u = !0, s[c] = h) : r[c] = h } } if (e.transform || (a || n ? r.transform = pO(e, t.transform, n) : r.transform && (r.transform = "none")), u) { const { originX: c = "50%", originY: f = "50%", originZ: h = 0 } = s; r.transformOrigin = `${c} ${f} ${h}` } } function Ix(t, e, n) { return typeof t == "string" ? t : Ke.transform(e + n * t) } function vO(t, e, n) { const r = Ix(e, t.x, t.width), i = Ix(n, t.y, t.height); return `${r} ${i}` } const mO = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, gO = { offset: "strokeDashoffset", array: "strokeDasharray" }; function yO(t, e, n = 1, r = 0, i = !0) { t.pathLength = 1; const s = i ? mO : gO; t[s.offset] = Ke.transform(-r); const a = Ke.transform(e), u = Ke.transform(n); t[s.array] = `${a} ${u}` } function Av(t, { attrX: e, attrY: n, attrScale: r, originX: i, originY: s, pathLength: a, pathSpacing: u = 1, pathOffset: c = 0, ...f }, h, v) { if (kv(t, f, v), h) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: m, style: g, dimensions: S } = t; m.transform && (S && (g.transform = m.transform), delete m.transform), S && (i !== void 0 || s !== void 0 || g.transform) && (g.transformOrigin = vO(S, i !== void 0 ? i : .5, s !== void 0 ? s : .5)), e !== void 0 && (m.x = e), n !== void 0 && (m.y = n), r !== void 0 && (m.scale = r), a !== void 0 && yO(m, a, u, c, !1) } const Ev = t => typeof t == "string" && t.toLowerCase() === "svg", xO = { useVisualState: UC({ scrapeMotionValuesFromProps: zC, createRenderState: WC, onMount: (t, e, { renderState: n, latestValues: r }) => { Dt.read(() => { try { n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), Dt.render(() => { Av(n, r, Ev(e.tagName), t.transformTemplate), jC(e, n) }) } }) }, wO = { useVisualState: UC({ scrapeMotionValuesFromProps: Pv, createRenderState: Tv }) }; function HC(t, e, n) { for (const r in e) !Fn(e[r]) && !IC(r, n) && (t[r] = e[r]) } function SO({ transformTemplate: t }, e) { return j.useMemo(() => { const n = Tv(); return kv(n, e, t), Object.assign({}, n.vars, n.style) }, [e]) } function bO(t, e) { const n = t.style || {}, r = {}; return HC(r, n, t), Object.assign(r, SO(t, e)), r } function CO(t, e) { const n = {}, r = bO(t, e); return t.drag && t.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = r, n } const PO = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function lf(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || PO.has(t) } let qC = t => !lf(t); function TO(t) { t && (qC = e => e.startsWith("on") ? !lf(e) : t(e)) } try { TO(require("@emotion/is-prop-valid").default) } catch { } function kO(t, e, n) { const r = {}; for (const i in t) i === "values" && typeof t.values == "object" || (qC(i) || n === !0 && lf(i) || !e && !lf(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]); return r } function AO(t, e, n, r) { const i = j.useMemo(() => { const s = WC(); return Av(s, e, Ev(r), t.transformTemplate), { ...s.attrs, style: { ...s.style } } }, [e]); if (t.style) { const s = {}; HC(s, t.style, t), i.style = { ...s, ...i.style } } return i } function EO(t = !1) { return (n, r, i, { latestValues: s }, a) => { const c = (Cv(n) ? AO : CO)(r, s, a, n), f = kO(r, typeof n == "string", t), h = n !== j.Fragment ? { ...f, ...c, ref: i } : {}, { children: v } = r, m = j.useMemo(() => Fn(v) ? v.get() : v, [v]); return j.createElement(n, { ...h, children: m }) } } function FO(t, e) { return function (r, { forwardMotionProps: i } = { forwardMotionProps: !1 }) { const a = { ...Cv(r) ? xO : wO, preloadedFeatures: t, useRender: EO(i), createVisualElement: e, Component: r }; return iO(a) } } const u0 = { current: null }, GC = { current: !1 }; function RO() { if (GC.current = !0, !!bv) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), e = () => u0.current = t.matches; t.addListener(e), e() } else u0.current = !1 } function DO(t, e, n) { for (const r in e) { const i = e[r], s = n[r]; if (Fn(i)) t.addValue(r, i); else if (Fn(s)) t.addValue(r, Ll(i, { owner: t })); else if (s !== i) if (t.hasValue(r)) { const a = t.getValue(r); a.liveStyle === !0 ? a.jump(i) : a.hasAnimated || a.set(i) } else { const a = t.getStaticValue(r); t.addValue(r, Ll(a !== void 0 ? a : i, { owner: t })) } } for (const r in n) e[r] === void 0 && t.removeValue(r); return e } const zx = new WeakMap, OO = [...Lb, An, fo], MO = t => OO.find(Bb(t)), Ux = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; let VO = class { scrapeMotionValuesFromProps(e, n, r) { return {} } constructor({ parent: e, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: a }, u = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = iv, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const m = ni.now(); this.renderScheduledAt < m && (this.renderScheduledAt = m, Dt.render(this.render, !1, !0)) }; const { latestValues: c, renderState: f } = a; this.latestValues = c, this.baseTarget = { ...c }, this.initialValues = n.initial ? { ...c } : {}, this.renderState = f, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = u, this.blockInitialAnimation = !!s, this.isControllingVariants = Lf(n), this.isVariantNode = NC(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); const { willChange: h, ...v } = this.scrapeMotionValuesFromProps(n, {}, this); for (const m in v) { const g = v[m]; c[m] !== void 0 && Fn(g) && g.set(c[m], !1) } } mount(e) { this.current = e, zx.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), GC.current || RO(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : u0.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { zx.delete(this.current), this.projection && this.projection.unmount(), co(this.notifyUpdate), co(this.render), this.valueSubscriptions.forEach(e => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const e in this.events) this.events[e].clear(); for (const e in this.features) { const n = this.features[e]; n && (n.unmount(), n.isMounted = !1) } this.current = null } bindToMotionValue(e, n) { this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)(); const r = ts.has(e), i = n.on("change", u => { this.latestValues[e] = u, this.props.onUpdate && Dt.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0) }), s = n.on("renderRequest", this.scheduleRender); let a; window.MotionCheckAppearSync && (a = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => { i(), s(), a && a(), n.owner && n.stop() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } updateFeatures() { let e = "animation"; for (e in ta) { const n = ta[e]; if (!n) continue; const { isEnabled: r, Feature: i } = n; if (!this.features[e] && i && r(this.props) && (this.features[e] = new i(this)), this.features[e]) { const s = this.features[e]; s.isMounted ? s.update() : (s.mount(), s.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Zt() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, n) { this.latestValues[e] = n } update(e, n) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < Ux.length; r++) { const i = Ux[r]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); const s = "on" + i, a = e[s]; a && (this.propEventSubscriptions[i] = this.on(i, a)) } this.prevMotionValues = DO(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(e) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e) } addValue(e, n) { const r = this.values.get(e); n !== r && (r && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get()) } removeValue(e) { this.values.delete(e); const n = this.valueSubscriptions.get(e); n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, n) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let r = this.values.get(e); return r === void 0 && n !== void 0 && (r = Ll(n === null ? void 0 : n, { owner: this }), this.addValue(e, r)), r } readValue(e, n) { var r; let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (r = this.getBaseTargetFromProps(this.props, e)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, e, this.options); return i != null && (typeof i == "string" && (Ob(i) || Db(i)) ? i = parseFloat(i) : !MO(i) && fo.test(n) && (i = qb(e, n)), this.setBaseTarget(e, Fn(i) ? i.get() : i)), Fn(i) ? i.get() : i } setBaseTarget(e, n) { this.baseTarget[e] = n } getBaseTarget(e) { var n; const { initial: r } = this.props; let i; if (typeof r == "string" || typeof r == "object") { const a = J0(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom); a && (i = a[e]) } if (r && i !== void 0) return i; const s = this.getBaseTargetFromProps(this.props, e); return s !== void 0 && !Fn(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e] } on(e, n) { return this.events[e] || (this.events[e] = new gv), this.events[e].add(n) } notify(e, ...n) { this.events[e] && this.events[e].notify(...n) } }, XC = class extends VO { constructor() { super(...arguments), this.KeyframeResolver = Gb } sortInstanceNodePosition(e, n) { return e.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(e, n) { return e.style ? e.style[n] : void 0 } removeValueFromRenderState(e, { vars: n, style: r }) { delete n[e], delete r[e] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; Fn(e) && (this.childSubscription = e.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } }; function NO(t) { return window.getComputedStyle(t) } let BO = class extends XC { constructor() { super(...arguments), this.type = "html", this.renderInstance = BC } readValueFromInstance(e, n) { if (ts.has(n)) { const r = lv(n); return r && r.default || 0 } else { const r = NO(e), i = (Vb(n) ? r.getPropertyValue(n) : r[n]) || 0; return typeof i == "string" ? i.trim() : i } } measureInstanceViewportBox(e, { transformPagePoint: n }) { return xC(e, n) } build(e, n, r) { kv(e, n, r.transformTemplate) } scrapeMotionValuesFromProps(e, n, r) { return Pv(e, n, r) } }, LO = class extends XC { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Zt } getBaseTargetFromProps(e, n) { return e[n] } readValueFromInstance(e, n) { if (ts.has(n)) { const r = lv(n); return r && r.default || 0 } return n = LC.has(n) ? n : yv(n), e.getAttribute(n) } scrapeMotionValuesFromProps(e, n, r) { return zC(e, n, r) } build(e, n, r) { Av(e, n, this.isSVGTag, r.transformTemplate) } renderInstance(e, n, r, i) { jC(e, n, r, i) } mount(e) { this.isSVGTag = Ev(e.tagName), super.mount(e) } }; const jO = (t, e) => Cv(t) ? new LO(e) : new BO(e, { allowProjection: t !== j.Fragment }), IO = FO({ ...xR, ...ZD, ...LD, ...YD }, jO), Wx = gE(IO); function zO() { const t = ["Img to Pdf", "Pdf Compressor", "Pdf Merger", "Image Compressor", "Excel to Pdf", "Word to Pdf"]; return De.jsx("div", { className: "mt-5 w-screen h-24 flex gap-4 items-center overflow-x-hidden overflow-y-auto px-4", children: De.jsx(Wx.div, { animate: { x: [0, -1600] }, transition: { duration: 20, repeat: 1 / 0, ease: "linear", repeatType: "loop" }, className: "flex gap-4", children: [...t, ...t].map((e, n) => De.jsx(Wx.div, { initial: { scale: 0 }, animate: { scale: 1 }, className: "h-16 min-w-28 border border-white/30 hover:border-white/80 rounded-full px-5 hover:font-bold text-white/80 hover:text-white flex items-center justify-center cursor-pointer transition-all duration-300", children: e }, n)) }) }) }/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var c0 = function (t, e) { return c0 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, r) { n.__proto__ = r } || function (n, r) { for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i]) }, c0(t, e) }; function we(t, e) { c0(t, e); function n() { this.constructor = t } t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n) } var _e = function () { return _e = Object.assign || function (e) { for (var n, r = 1, i = arguments.length; r < i; r++) { n = arguments[r]; for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]) } return e }, _e.apply(this, arguments) }; function UO(t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]); return n } function tt(t, e, n, r) { function i(s) { return s instanceof n ? s : new n(function (a) { a(s) }) } return new (n || (n = Promise))(function (s, a) { function u(h) { try { f(r.next(h)) } catch (v) { a(v) } } function c(h) { try { f(r.throw(h)) } catch (v) { a(v) } } function f(h) { h.done ? s(h.value) : i(h.value).then(u, c) } f((r = r.apply(t, [])).next()) }) } function nt(t, e) { var n = { label: 0, sent: function () { if (s[0] & 1) throw s[1]; return s[1] }, trys: [], ops: [] }, r, i, s, a; return a = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function () { return this }), a; function u(f) { return function (h) { return c([f, h]) } } function c(f) { if (r) throw new TypeError("Generator is already executing."); for (; n;)try { if (r = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s; switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) { case 0: case 1: s = f; break; case 4: return n.label++, { value: f[1], done: !1 }; case 5: n.label++, i = f[1], f = [0]; continue; case 7: f = n.ops.pop(), n.trys.pop(); continue; default: if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) { n = 0; continue } if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) { n.label = f[1]; break } if (f[0] === 6 && n.label < s[1]) { n.label = s[1], s = f; break } if (s && n.label < s[2]) { n.label = s[2], n.ops.push(f); break } s[2] && n.ops.pop(), n.trys.pop(); continue }f = e.call(t, n) } catch (h) { f = [6, h], i = 0 } finally { r = s = 0 } if (f[0] & 5) throw f[1]; return { value: f[0] ? f[1] : void 0, done: !0 } } } function ft() { for (var t = 0, e = 0, n = arguments.length; e < n; e++)t += arguments[e].length; for (var r = Array(t), i = 0, e = 0; e < n; e++)for (var s = arguments[e], a = 0, u = s.length; a < u; a++, i++)r[i] = s[a]; return r } var Ks = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", cl = new Uint8Array(256); for (var Pc = 0; Pc < Ks.length; Pc++)cl[Ks.charCodeAt(Pc)] = Pc; var WO = function (t) { for (var e = "", n = t.length, r = 0; r < n; r += 3)e += Ks[t[r] >> 2], e += Ks[(t[r] & 3) << 4 | t[r + 1] >> 4], e += Ks[(t[r + 1] & 15) << 2 | t[r + 2] >> 6], e += Ks[t[r + 2] & 63]; return n % 3 === 2 ? e = e.substring(0, e.length - 1) + "=" : n % 3 === 1 && (e = e.substring(0, e.length - 2) + "=="), e }, Kx = function (t) { var e = t.length * .75, n = t.length, r, i = 0, s, a, u, c; t[t.length - 1] === "=" && (e--, t[t.length - 2] === "=" && e--); var f = new Uint8Array(e); for (r = 0; r < n; r += 4)s = cl[t.charCodeAt(r)], a = cl[t.charCodeAt(r + 1)], u = cl[t.charCodeAt(r + 2)], c = cl[t.charCodeAt(r + 3)], f[i++] = s << 2 | a >> 4, f[i++] = (a & 15) << 4 | u >> 2, f[i++] = (u & 3) << 6 | c & 63; return f }, KO = /^(data)?:?([\w\/\+]+)?;?(charset=[\w-]+|base64)?.*,/i, HO = function (t) { var e = t.trim(), n = e.substring(0, 100), r = n.match(KO); if (!r) return Kx(e); var i = r[0], s = e.substring(i.length); return Kx(s) }, Qe = function (t) { return t.charCodeAt(0) }, qO = function (t) { return t.codePointAt(0) }, nu = function (t, e) { return qr(t.toString(16), e, "0").toUpperCase() }, jf = function (t) { return nu(t, 2) }, Ti = function (t) { return String.fromCharCode(t) }, GO = function (t) { return Ti(parseInt(t, 16)) }, qr = function (t, e, n) { for (var r = "", i = 0, s = e - t.length; i < s; i++)r += n; return r + t }, wn = function (t, e, n) { for (var r = t.length, i = 0; i < r; i++)e[n++] = t.charCodeAt(i); return r }, XO = function (t) { return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") }, ru = function (t) { return t.replace(/\t|\u0085|\u2028|\u2029/g, "    ").replace(/[\b\v]/g, "") }, ZO = ["\\n", "\\f", "\\r", "\\u000B"], ZC = function (t) { return /^[\n\f\r\u000B]$/.test(t) }, YC = function (t) { return t.split(/[\n\f\r\u000B]/) }, QC = function (t) { return t.replace(/[\n\f\r\u000B]/g, " ") }, JC = function (t, e) { var n = t.charCodeAt(e), r, i = e + 1, s = 1; return n >= 55296 && n <= 56319 && t.length > i && (r = t.charCodeAt(i), r >= 56320 && r <= 57343 && (s = 2)), [t.slice(e, e + s), s] }, YO = function (t) { for (var e = [], n = 0, r = t.length; n < r;) { var i = JC(t, n), s = i[0], a = i[1]; e.push(s), n += a } return e }, QO = function (t) { for (var e = ZO.join("|"), n = ["$"], r = 0, i = t.length; r < i; r++) { var s = t[r]; if (ZC(s)) throw new TypeError("`wordBreak` must not include " + e); n.push(s === "" ? "." : XO(s)) } var a = n.join("|"); return new RegExp("(" + e + ")|((.*?)(" + a + "))", "gm") }, JO = function (t, e, n, r) { for (var i = QO(e), s = ru(t).match(i), a = "", u = 0, c = [], f = function () { a !== "" && c.push(a), a = "", u = 0 }, h = 0, v = s.length; h < v; h++) { var m = s[h]; if (ZC(m)) f(); else { var g = r(m); u + g > n && f(), a += m, u += g } } return f(), c }, _O = /^D:(\d\d\d\d)(\d\d)?(\d\d)?(\d\d)?(\d\d)?(\d\d)?([+\-Z])?(\d\d)?'?(\d\d)?'?$/, _C = function (t) { var e = t.match(_O); if (e) { var n = e[1], r = e[2], i = r === void 0 ? "01" : r, s = e[3], a = s === void 0 ? "01" : s, u = e[4], c = u === void 0 ? "00" : u, f = e[5], h = f === void 0 ? "00" : f, v = e[6], m = v === void 0 ? "00" : v, g = e[7], S = g === void 0 ? "Z" : g, b = e[8], P = b === void 0 ? "00" : b, C = e[9], F = C === void 0 ? "00" : C, A = S === "Z" ? "Z" : "" + S + P + ":" + F, N = new Date(n + "-" + i + "-" + a + "T" + c + ":" + h + ":" + m + A); return N } }, Fv = function (t, e) { for (var n, r = 0, i; r < t.length;) { var s = t.substring(r).match(e); if (!s) return { match: i, pos: r }; i = s, r += ((n = s.index) !== null && n !== void 0 ? n : 0) + s[0].length } return { match: i, pos: r } }, uf = function (t) { return t[t.length - 1] }, f0 = function (t) { if (t instanceof Uint8Array) return t; for (var e = t.length, n = new Uint8Array(e), r = 0; r < e; r++)n[r] = t.charCodeAt(r); return n }, $O = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; for (var n = t.length, r = [], i = 0; i < n; i++) { var s = t[i]; r[i] = s instanceof Uint8Array ? s : f0(s) } for (var a = 0, i = 0; i < n; i++)a += t[i].length; for (var u = new Uint8Array(a), c = 0, f = 0; f < n; f++)for (var h = r[f], v = 0, m = h.length; v < m; v++)u[c++] = h[v]; return u }, eM = function (t) { for (var e = 0, n = 0, r = t.length; n < r; n++)e += t[n].length; for (var i = new Uint8Array(e), s = 0, n = 0, r = t.length; n < r; n++) { var a = t[n]; i.set(a, s), s += a.length } return i }, $C = function (t) { for (var e = "", n = 0, r = t.length; n < r; n++)e += Ti(t[n]); return e }, tM = function (t, e) { return t.id - e.id }, nM = function (t, e) { for (var n = [], r = 0, i = t.length; r < i; r++) { var s = t[r], a = t[r - 1]; (r === 0 || e(s) !== e(a)) && n.push(s) } return n }, Ds = function (t) { for (var e = t.length, n = 0, r = Math.floor(e / 2); n < r; n++) { var i = n, s = e - n - 1, a = t[n]; t[i] = t[s], t[s] = a } return t }, rM = function (t) { for (var e = 0, n = 0, r = t.length; n < r; n++)e += t[n]; return e }, iM = function (t, e) { for (var n = new Array(e - t), r = 0, i = n.length; r < i; r++)n[r] = t + r; return n }, oM = function (t, e) { for (var n = new Array(e.length), r = 0, i = e.length; r < i; r++)n[r] = t[e[r]]; return n }, sM = function (t) { return t instanceof Uint8Array || t instanceof ArrayBuffer || typeof t == "string" }, _a = function (t) { if (typeof t == "string") return HO(t); if (t instanceof ArrayBuffer) return new Uint8Array(t); if (t instanceof Uint8Array) return t; throw new TypeError("`input` must be one of `string | ArrayBuffer | Uint8Array`") }, na = function () { return new Promise(function (t) { setTimeout(function () { return t() }, 0) }) }, aM = function (t, e) { e === void 0 && (e = !0); var n = []; e && n.push(65279); for (var r = 0, i = t.length; r < i;) { var s = t.codePointAt(r); if (s < 65536) n.push(s), r += 1; else if (s < 1114112) n.push(eP(s), tP(s)), r += 2; else throw new Error("Invalid code point: 0x" + jf(s)) } return new Uint16Array(n) }, lM = function (t) { return t >= 0 && t <= 65535 }, uM = function (t) { return t >= 65536 && t <= 1114111 }, eP = function (t) { return Math.floor((t - 65536) / 1024) + 55296 }, tP = function (t) { return (t - 65536) % 1024 + 56320 }, lo; (function (t) { t.BigEndian = "BigEndian", t.LittleEndian = "LittleEndian" })(lo || (lo = {})); var $a = "�".codePointAt(0), nP = function (t, e) { if (e === void 0 && (e = !0), t.length <= 1) return String.fromCodePoint($a); for (var n = e ? fM(t) : lo.BigEndian, r = e ? 2 : 0, i = []; t.length - r >= 2;) { var s = qx(t[r++], t[r++], n); if (cM(s)) if (t.length - r < 2) i.push($a); else { var a = qx(t[r++], t[r++], n); Hx(a) ? i.push(s, a) : i.push($a) } else Hx(s) ? (r += 2, i.push($a)) : i.push(s) } return r < t.length && i.push($a), String.fromCodePoint.apply(String, i) }, cM = function (t) { return t >= 55296 && t <= 56319 }, Hx = function (t) { return t >= 56320 && t <= 57343 }, qx = function (t, e, n) { if (n === lo.LittleEndian) return e << 8 | t; if (n === lo.BigEndian) return t << 8 | e; throw new Error("Invalid byteOrder: " + n) }, fM = function (t) { return rP(t) ? lo.BigEndian : iP(t) ? lo.LittleEndian : lo.BigEndian }, rP = function (t) { return t[0] === 254 && t[1] === 255 }, iP = function (t) { return t[0] === 255 && t[1] === 254 }, oP = function (t) { return rP(t) || iP(t) }, dM = function (t) { var e = String(t); if (Math.abs(t) < 1) { var n = parseInt(t.toString().split("e-")[1]); if (n) { var r = t < 0; r && (t *= -1), t *= Math.pow(10, n - 1), e = "0." + new Array(n).join("0") + t.toString().substring(2), r && (e = "-" + e) } } else { var n = parseInt(t.toString().split("+")[1]); n > 20 && (n -= 20, t /= Math.pow(10, n), e = t.toString() + new Array(n + 1).join("0")) } return e }, Kc = function (t) { return Math.ceil(t.toString(2).length / 8) }, Os = function (t) { for (var e = new Uint8Array(Kc(t)), n = 1; n <= e.length; n++)e[n - 1] = t >> (e.length - n) * 8; return e }, iu = function (t) { throw new Error(t) }, pp = {}, Gx; function So() { return Gx || (Gx = 1, function (t) { var e = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u"; function n(s, a) { return Object.prototype.hasOwnProperty.call(s, a) } t.assign = function (s) { for (var a = Array.prototype.slice.call(arguments, 1); a.length;) { var u = a.shift(); if (u) { if (typeof u != "object") throw new TypeError(u + "must be non-object"); for (var c in u) n(u, c) && (s[c] = u[c]) } } return s }, t.shrinkBuf = function (s, a) { return s.length === a ? s : s.subarray ? s.subarray(0, a) : (s.length = a, s) }; var r = { arraySet: function (s, a, u, c, f) { if (a.subarray && s.subarray) { s.set(a.subarray(u, u + c), f); return } for (var h = 0; h < c; h++)s[f + h] = a[u + h] }, flattenChunks: function (s) { var a, u, c, f, h, v; for (c = 0, a = 0, u = s.length; a < u; a++)c += s[a].length; for (v = new Uint8Array(c), f = 0, a = 0, u = s.length; a < u; a++)h = s[a], v.set(h, f), f += h.length; return v } }, i = { arraySet: function (s, a, u, c, f) { for (var h = 0; h < c; h++)s[f + h] = a[u + h] }, flattenChunks: function (s) { return [].concat.apply([], s) } }; t.setTyped = function (s) { s ? (t.Buf8 = Uint8Array, t.Buf16 = Uint16Array, t.Buf32 = Int32Array, t.assign(t, r)) : (t.Buf8 = Array, t.Buf16 = Array, t.Buf32 = Array, t.assign(t, i)) }, t.setTyped(e) }(pp)), pp } var Ms = {}, zr = {}, jo = {}, Xx; function hM() { if (Xx) return jo; Xx = 1; var t = So(), e = 4, n = 0, r = 1, i = 2; function s(R) { for (var de = R.length; --de >= 0;)R[de] = 0 } var a = 0, u = 1, c = 2, f = 3, h = 258, v = 29, m = 256, g = m + 1 + v, S = 30, b = 19, P = 2 * g + 1, C = 15, F = 16, A = 7, N = 256, D = 16, V = 17, B = 18, I = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], Y = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], Z = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], se = 512, q = new Array((g + 2) * 2); s(q); var ue = new Array(S * 2); s(ue); var ye = new Array(se); s(ye); var ae = new Array(h - f + 1); s(ae); var _ = new Array(v); s(_); var Q = new Array(S); s(Q); function le(R, de, ge, ke, H) { this.static_tree = R, this.extra_bits = de, this.extra_base = ge, this.elems = ke, this.max_length = H, this.has_stree = R && R.length } var ce, W, re; function Ae(R, de) { this.dyn_tree = R, this.max_code = 0, this.stat_desc = de } function Fe(R) { return R < 256 ? ye[R] : ye[256 + (R >>> 7)] } function Be(R, de) { R.pending_buf[R.pending++] = de & 255, R.pending_buf[R.pending++] = de >>> 8 & 255 } function Ee(R, de, ge) { R.bi_valid > F - ge ? (R.bi_buf |= de << R.bi_valid & 65535, Be(R, R.bi_buf), R.bi_buf = de >> F - R.bi_valid, R.bi_valid += ge - F) : (R.bi_buf |= de << R.bi_valid & 65535, R.bi_valid += ge) } function Ie(R, de, ge) { Ee(R, ge[de * 2], ge[de * 2 + 1]) } function be(R, de) { var ge = 0; do ge |= R & 1, R >>>= 1, ge <<= 1; while (--de > 0); return ge >>> 1 } function Je(R) { R.bi_valid === 16 ? (Be(R, R.bi_buf), R.bi_buf = 0, R.bi_valid = 0) : R.bi_valid >= 8 && (R.pending_buf[R.pending++] = R.bi_buf & 255, R.bi_buf >>= 8, R.bi_valid -= 8) } function pt(R, de) { var ge = de.dyn_tree, ke = de.max_code, H = de.stat_desc.static_tree, oe = de.stat_desc.has_stree, k = de.stat_desc.extra_bits, fe = de.stat_desc.extra_base, ze = de.stat_desc.max_length, x, ee, ne, E, z, $, Ve = 0; for (E = 0; E <= C; E++)R.bl_count[E] = 0; for (ge[R.heap[R.heap_max] * 2 + 1] = 0, x = R.heap_max + 1; x < P; x++)ee = R.heap[x], E = ge[ge[ee * 2 + 1] * 2 + 1] + 1, E > ze && (E = ze, Ve++), ge[ee * 2 + 1] = E, !(ee > ke) && (R.bl_count[E]++, z = 0, ee >= fe && (z = k[ee - fe]), $ = ge[ee * 2], R.opt_len += $ * (E + z), oe && (R.static_len += $ * (H[ee * 2 + 1] + z))); if (Ve !== 0) { do { for (E = ze - 1; R.bl_count[E] === 0;)E--; R.bl_count[E]--, R.bl_count[E + 1] += 2, R.bl_count[ze]--, Ve -= 2 } while (Ve > 0); for (E = ze; E !== 0; E--)for (ee = R.bl_count[E]; ee !== 0;)ne = R.heap[--x], !(ne > ke) && (ge[ne * 2 + 1] !== E && (R.opt_len += (E - ge[ne * 2 + 1]) * ge[ne * 2], ge[ne * 2 + 1] = E), ee--) } } function Qt(R, de, ge) { var ke = new Array(C + 1), H = 0, oe, k; for (oe = 1; oe <= C; oe++)ke[oe] = H = H + ge[oe - 1] << 1; for (k = 0; k <= de; k++) { var fe = R[k * 2 + 1]; fe !== 0 && (R[k * 2] = be(ke[fe]++, fe)) } } function ht() { var R, de, ge, ke, H, oe = new Array(C + 1); for (ge = 0, ke = 0; ke < v - 1; ke++)for (_[ke] = ge, R = 0; R < 1 << I[ke]; R++)ae[ge++] = ke; for (ae[ge - 1] = ke, H = 0, ke = 0; ke < 16; ke++)for (Q[ke] = H, R = 0; R < 1 << Y[ke]; R++)ye[H++] = ke; for (H >>= 7; ke < S; ke++)for (Q[ke] = H << 7, R = 0; R < 1 << Y[ke] - 7; R++)ye[256 + H++] = ke; for (de = 0; de <= C; de++)oe[de] = 0; for (R = 0; R <= 143;)q[R * 2 + 1] = 8, R++, oe[8]++; for (; R <= 255;)q[R * 2 + 1] = 9, R++, oe[9]++; for (; R <= 279;)q[R * 2 + 1] = 7, R++, oe[7]++; for (; R <= 287;)q[R * 2 + 1] = 8, R++, oe[8]++; for (Qt(q, g + 1, oe), R = 0; R < S; R++)ue[R * 2 + 1] = 5, ue[R * 2] = be(R, 5); ce = new le(q, I, m + 1, g, C), W = new le(ue, Y, 0, S, C), re = new le(new Array(0), Z, 0, b, A) } function Et(R) { var de; for (de = 0; de < g; de++)R.dyn_ltree[de * 2] = 0; for (de = 0; de < S; de++)R.dyn_dtree[de * 2] = 0; for (de = 0; de < b; de++)R.bl_tree[de * 2] = 0; R.dyn_ltree[N * 2] = 1, R.opt_len = R.static_len = 0, R.last_lit = R.matches = 0 } function jn(R) { R.bi_valid > 8 ? Be(R, R.bi_buf) : R.bi_valid > 0 && (R.pending_buf[R.pending++] = R.bi_buf), R.bi_buf = 0, R.bi_valid = 0 } function vn(R, de, ge, ke) { jn(R), Be(R, ge), Be(R, ~ge), t.arraySet(R.pending_buf, R.window, de, ge, R.pending), R.pending += ge } function un(R, de, ge, ke) { var H = de * 2, oe = ge * 2; return R[H] < R[oe] || R[H] === R[oe] && ke[de] <= ke[ge] } function Ct(R, de, ge) { for (var ke = R.heap[ge], H = ge << 1; H <= R.heap_len && (H < R.heap_len && un(de, R.heap[H + 1], R.heap[H], R.depth) && H++, !un(de, ke, R.heap[H], R.depth));)R.heap[ge] = R.heap[H], ge = H, H <<= 1; R.heap[ge] = ke } function it(R, de, ge) { var ke, H, oe = 0, k, fe; if (R.last_lit !== 0) do ke = R.pending_buf[R.d_buf + oe * 2] << 8 | R.pending_buf[R.d_buf + oe * 2 + 1], H = R.pending_buf[R.l_buf + oe], oe++, ke === 0 ? Ie(R, H, de) : (k = ae[H], Ie(R, k + m + 1, de), fe = I[k], fe !== 0 && (H -= _[k], Ee(R, H, fe)), ke--, k = Fe(ke), Ie(R, k, ge), fe = Y[k], fe !== 0 && (ke -= Q[k], Ee(R, ke, fe))); while (oe < R.last_lit); Ie(R, N, de) } function Kt(R, de) { var ge = de.dyn_tree, ke = de.stat_desc.static_tree, H = de.stat_desc.has_stree, oe = de.stat_desc.elems, k, fe, ze = -1, x; for (R.heap_len = 0, R.heap_max = P, k = 0; k < oe; k++)ge[k * 2] !== 0 ? (R.heap[++R.heap_len] = ze = k, R.depth[k] = 0) : ge[k * 2 + 1] = 0; for (; R.heap_len < 2;)x = R.heap[++R.heap_len] = ze < 2 ? ++ze : 0, ge[x * 2] = 1, R.depth[x] = 0, R.opt_len--, H && (R.static_len -= ke[x * 2 + 1]); for (de.max_code = ze, k = R.heap_len >> 1; k >= 1; k--)Ct(R, ge, k); x = oe; do k = R.heap[1], R.heap[1] = R.heap[R.heap_len--], Ct(R, ge, 1), fe = R.heap[1], R.heap[--R.heap_max] = k, R.heap[--R.heap_max] = fe, ge[x * 2] = ge[k * 2] + ge[fe * 2], R.depth[x] = (R.depth[k] >= R.depth[fe] ? R.depth[k] : R.depth[fe]) + 1, ge[k * 2 + 1] = ge[fe * 2 + 1] = x, R.heap[1] = x++, Ct(R, ge, 1); while (R.heap_len >= 2); R.heap[--R.heap_max] = R.heap[1], pt(R, de), Qt(ge, ze, R.bl_count) } function cr(R, de, ge) { var ke, H = -1, oe, k = de[0 * 2 + 1], fe = 0, ze = 7, x = 4; for (k === 0 && (ze = 138, x = 3), de[(ge + 1) * 2 + 1] = 65535, ke = 0; ke <= ge; ke++)oe = k, k = de[(ke + 1) * 2 + 1], !(++fe < ze && oe === k) && (fe < x ? R.bl_tree[oe * 2] += fe : oe !== 0 ? (oe !== H && R.bl_tree[oe * 2]++, R.bl_tree[D * 2]++) : fe <= 10 ? R.bl_tree[V * 2]++ : R.bl_tree[B * 2]++, fe = 0, H = oe, k === 0 ? (ze = 138, x = 3) : oe === k ? (ze = 6, x = 3) : (ze = 7, x = 4)) } function Dn(R, de, ge) { var ke, H = -1, oe, k = de[0 * 2 + 1], fe = 0, ze = 7, x = 4; for (k === 0 && (ze = 138, x = 3), ke = 0; ke <= ge; ke++)if (oe = k, k = de[(ke + 1) * 2 + 1], !(++fe < ze && oe === k)) { if (fe < x) do Ie(R, oe, R.bl_tree); while (--fe !== 0); else oe !== 0 ? (oe !== H && (Ie(R, oe, R.bl_tree), fe--), Ie(R, D, R.bl_tree), Ee(R, fe - 3, 2)) : fe <= 10 ? (Ie(R, V, R.bl_tree), Ee(R, fe - 3, 3)) : (Ie(R, B, R.bl_tree), Ee(R, fe - 11, 7)); fe = 0, H = oe, k === 0 ? (ze = 138, x = 3) : oe === k ? (ze = 6, x = 3) : (ze = 7, x = 4) } } function bn(R) { var de; for (cr(R, R.dyn_ltree, R.l_desc.max_code), cr(R, R.dyn_dtree, R.d_desc.max_code), Kt(R, R.bl_desc), de = b - 1; de >= 3 && R.bl_tree[ie[de] * 2 + 1] === 0; de--); return R.opt_len += 3 * (de + 1) + 5 + 5 + 4, de } function ci(R, de, ge, ke) { var H; for (Ee(R, de - 257, 5), Ee(R, ge - 1, 5), Ee(R, ke - 4, 4), H = 0; H < ke; H++)Ee(R, R.bl_tree[ie[H] * 2 + 1], 3); Dn(R, R.dyn_ltree, de - 1), Dn(R, R.dyn_dtree, ge - 1) } function Or(R) { var de = 4093624447, ge; for (ge = 0; ge <= 31; ge++, de >>>= 1)if (de & 1 && R.dyn_ltree[ge * 2] !== 0) return n; if (R.dyn_ltree[9 * 2] !== 0 || R.dyn_ltree[10 * 2] !== 0 || R.dyn_ltree[13 * 2] !== 0) return r; for (ge = 32; ge < m; ge++)if (R.dyn_ltree[ge * 2] !== 0) return r; return n } var In = !1; function fi(R) { In || (ht(), In = !0), R.l_desc = new Ae(R.dyn_ltree, ce), R.d_desc = new Ae(R.dyn_dtree, W), R.bl_desc = new Ae(R.bl_tree, re), R.bi_buf = 0, R.bi_valid = 0, Et(R) } function fr(R, de, ge, ke) { Ee(R, (a << 1) + (ke ? 1 : 0), 3), vn(R, de, ge) } function Ht(R) { Ee(R, u << 1, 3), Ie(R, N, q), Je(R) } function Zn(R, de, ge, ke) { var H, oe, k = 0; R.level > 0 ? (R.strm.data_type === i && (R.strm.data_type = Or(R)), Kt(R, R.l_desc), Kt(R, R.d_desc), k = bn(R), H = R.opt_len + 3 + 7 >>> 3, oe = R.static_len + 3 + 7 >>> 3, oe <= H && (H = oe)) : H = oe = ge + 5, ge + 4 <= H && de !== -1 ? fr(R, de, ge, ke) : R.strategy === e || oe === H ? (Ee(R, (u << 1) + (ke ? 1 : 0), 3), it(R, q, ue)) : (Ee(R, (c << 1) + (ke ? 1 : 0), 3), ci(R, R.l_desc.max_code + 1, R.d_desc.max_code + 1, k + 1), it(R, R.dyn_ltree, R.dyn_dtree)), Et(R), ke && jn(R) } function dr(R, de, ge) { return R.pending_buf[R.d_buf + R.last_lit * 2] = de >>> 8 & 255, R.pending_buf[R.d_buf + R.last_lit * 2 + 1] = de & 255, R.pending_buf[R.l_buf + R.last_lit] = ge & 255, R.last_lit++, de === 0 ? R.dyn_ltree[ge * 2]++ : (R.matches++, de--, R.dyn_ltree[(ae[ge] + m + 1) * 2]++, R.dyn_dtree[Fe(de) * 2]++), R.last_lit === R.lit_bufsize - 1 } return jo._tr_init = fi, jo._tr_stored_block = fr, jo._tr_flush_block = Zn, jo._tr_tally = dr, jo._tr_align = Ht, jo } var vp, Zx; function sP() { if (Zx) return vp; Zx = 1; function t(e, n, r, i) { for (var s = e & 65535 | 0, a = e >>> 16 & 65535 | 0, u = 0; r !== 0;) { u = r > 2e3 ? 2e3 : r, r -= u; do s = s + n[i++] | 0, a = a + s | 0; while (--u); s %= 65521, a %= 65521 } return s | a << 16 | 0 } return vp = t, vp } var mp, Yx; function aP() { if (Yx) return mp; Yx = 1; function t() { for (var r, i = [], s = 0; s < 256; s++) { r = s; for (var a = 0; a < 8; a++)r = r & 1 ? 3988292384 ^ r >>> 1 : r >>> 1; i[s] = r } return i } var e = t(); function n(r, i, s, a) { var u = e, c = a + s; r ^= -1; for (var f = a; f < c; f++)r = r >>> 8 ^ u[(r ^ i[f]) & 255]; return r ^ -1 } return mp = n, mp } var gp, Qx; function Rv() { return Qx || (Qx = 1, gp = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }), gp } var Jx; function pM() { if (Jx) return zr; Jx = 1; var t = So(), e = hM(), n = sP(), r = aP(), i = Rv(), s = 0, a = 1, u = 3, c = 4, f = 5, h = 0, v = 1, m = -2, g = -3, S = -5, b = -1, P = 1, C = 2, F = 3, A = 4, N = 0, D = 2, V = 8, B = 9, I = 15, Y = 8, Z = 29, ie = 256, se = ie + 1 + Z, q = 30, ue = 19, ye = 2 * se + 1, ae = 15, _ = 3, Q = 258, le = Q + _ + 1, ce = 32, W = 42, re = 69, Ae = 73, Fe = 91, Be = 103, Ee = 113, Ie = 666, be = 1, Je = 2, pt = 3, Qt = 4, ht = 3; function Et(x, ee) { return x.msg = i[ee], ee } function jn(x) { return (x << 1) - (x > 4 ? 9 : 0) } function vn(x) { for (var ee = x.length; --ee >= 0;)x[ee] = 0 } function un(x) { var ee = x.state, ne = ee.pending; ne > x.avail_out && (ne = x.avail_out), ne !== 0 && (t.arraySet(x.output, ee.pending_buf, ee.pending_out, ne, x.next_out), x.next_out += ne, ee.pending_out += ne, x.total_out += ne, x.avail_out -= ne, ee.pending -= ne, ee.pending === 0 && (ee.pending_out = 0)) } function Ct(x, ee) { e._tr_flush_block(x, x.block_start >= 0 ? x.block_start : -1, x.strstart - x.block_start, ee), x.block_start = x.strstart, un(x.strm) } function it(x, ee) { x.pending_buf[x.pending++] = ee } function Kt(x, ee) { x.pending_buf[x.pending++] = ee >>> 8 & 255, x.pending_buf[x.pending++] = ee & 255 } function cr(x, ee, ne, E) { var z = x.avail_in; return z > E && (z = E), z === 0 ? 0 : (x.avail_in -= z, t.arraySet(ee, x.input, x.next_in, z, ne), x.state.wrap === 1 ? x.adler = n(x.adler, ee, z, ne) : x.state.wrap === 2 && (x.adler = r(x.adler, ee, z, ne)), x.next_in += z, x.total_in += z, z) } function Dn(x, ee) { var ne = x.max_chain_length, E = x.strstart, z, $, Ve = x.prev_length, Ce = x.nice_match, Pe = x.strstart > x.w_size - le ? x.strstart - (x.w_size - le) : 0, at = x.window, On = x.w_mask, kt = x.prev, ot = x.strstart + Q, qt = at[E + Ve - 1], jt = at[E + Ve]; x.prev_length >= x.good_match && (ne >>= 2), Ce > x.lookahead && (Ce = x.lookahead); do if (z = ee, !(at[z + Ve] !== jt || at[z + Ve - 1] !== qt || at[z] !== at[E] || at[++z] !== at[E + 1])) { E += 2, z++; do; while (at[++E] === at[++z] && at[++E] === at[++z] && at[++E] === at[++z] && at[++E] === at[++z] && at[++E] === at[++z] && at[++E] === at[++z] && at[++E] === at[++z] && at[++E] === at[++z] && E < ot); if ($ = Q - (ot - E), E = ot - Q, $ > Ve) { if (x.match_start = ee, Ve = $, $ >= Ce) break; qt = at[E + Ve - 1], jt = at[E + Ve] } } while ((ee = kt[ee & On]) > Pe && --ne !== 0); return Ve <= x.lookahead ? Ve : x.lookahead } function bn(x) { var ee = x.w_size, ne, E, z, $, Ve; do { if ($ = x.window_size - x.lookahead - x.strstart, x.strstart >= ee + (ee - le)) { t.arraySet(x.window, x.window, ee, ee, 0), x.match_start -= ee, x.strstart -= ee, x.block_start -= ee, E = x.hash_size, ne = E; do z = x.head[--ne], x.head[ne] = z >= ee ? z - ee : 0; while (--E); E = ee, ne = E; do z = x.prev[--ne], x.prev[ne] = z >= ee ? z - ee : 0; while (--E); $ += ee } if (x.strm.avail_in === 0) break; if (E = cr(x.strm, x.window, x.strstart + x.lookahead, $), x.lookahead += E, x.lookahead + x.insert >= _) for (Ve = x.strstart - x.insert, x.ins_h = x.window[Ve], x.ins_h = (x.ins_h << x.hash_shift ^ x.window[Ve + 1]) & x.hash_mask; x.insert && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[Ve + _ - 1]) & x.hash_mask, x.prev[Ve & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = Ve, Ve++, x.insert--, !(x.lookahead + x.insert < _));); } while (x.lookahead < le && x.strm.avail_in !== 0) } function ci(x, ee) { var ne = 65535; for (ne > x.pending_buf_size - 5 && (ne = x.pending_buf_size - 5); ;) { if (x.lookahead <= 1) { if (bn(x), x.lookahead === 0 && ee === s) return be; if (x.lookahead === 0) break } x.strstart += x.lookahead, x.lookahead = 0; var E = x.block_start + ne; if ((x.strstart === 0 || x.strstart >= E) && (x.lookahead = x.strstart - E, x.strstart = E, Ct(x, !1), x.strm.avail_out === 0) || x.strstart - x.block_start >= x.w_size - le && (Ct(x, !1), x.strm.avail_out === 0)) return be } return x.insert = 0, ee === c ? (Ct(x, !0), x.strm.avail_out === 0 ? pt : Qt) : (x.strstart > x.block_start && (Ct(x, !1), x.strm.avail_out === 0), be) } function Or(x, ee) { for (var ne, E; ;) { if (x.lookahead < le) { if (bn(x), x.lookahead < le && ee === s) return be; if (x.lookahead === 0) break } if (ne = 0, x.lookahead >= _ && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + _ - 1]) & x.hash_mask, ne = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart), ne !== 0 && x.strstart - ne <= x.w_size - le && (x.match_length = Dn(x, ne)), x.match_length >= _) if (E = e._tr_tally(x, x.strstart - x.match_start, x.match_length - _), x.lookahead -= x.match_length, x.match_length <= x.max_lazy_match && x.lookahead >= _) { x.match_length--; do x.strstart++, x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + _ - 1]) & x.hash_mask, ne = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart; while (--x.match_length !== 0); x.strstart++ } else x.strstart += x.match_length, x.match_length = 0, x.ins_h = x.window[x.strstart], x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + 1]) & x.hash_mask; else E = e._tr_tally(x, 0, x.window[x.strstart]), x.lookahead--, x.strstart++; if (E && (Ct(x, !1), x.strm.avail_out === 0)) return be } return x.insert = x.strstart < _ - 1 ? x.strstart : _ - 1, ee === c ? (Ct(x, !0), x.strm.avail_out === 0 ? pt : Qt) : x.last_lit && (Ct(x, !1), x.strm.avail_out === 0) ? be : Je } function In(x, ee) { for (var ne, E, z; ;) { if (x.lookahead < le) { if (bn(x), x.lookahead < le && ee === s) return be; if (x.lookahead === 0) break } if (ne = 0, x.lookahead >= _ && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + _ - 1]) & x.hash_mask, ne = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart), x.prev_length = x.match_length, x.prev_match = x.match_start, x.match_length = _ - 1, ne !== 0 && x.prev_length < x.max_lazy_match && x.strstart - ne <= x.w_size - le && (x.match_length = Dn(x, ne), x.match_length <= 5 && (x.strategy === P || x.match_length === _ && x.strstart - x.match_start > 4096) && (x.match_length = _ - 1)), x.prev_length >= _ && x.match_length <= x.prev_length) { z = x.strstart + x.lookahead - _, E = e._tr_tally(x, x.strstart - 1 - x.prev_match, x.prev_length - _), x.lookahead -= x.prev_length - 1, x.prev_length -= 2; do ++x.strstart <= z && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + _ - 1]) & x.hash_mask, ne = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart); while (--x.prev_length !== 0); if (x.match_available = 0, x.match_length = _ - 1, x.strstart++, E && (Ct(x, !1), x.strm.avail_out === 0)) return be } else if (x.match_available) { if (E = e._tr_tally(x, 0, x.window[x.strstart - 1]), E && Ct(x, !1), x.strstart++, x.lookahead--, x.strm.avail_out === 0) return be } else x.match_available = 1, x.strstart++, x.lookahead-- } return x.match_available && (E = e._tr_tally(x, 0, x.window[x.strstart - 1]), x.match_available = 0), x.insert = x.strstart < _ - 1 ? x.strstart : _ - 1, ee === c ? (Ct(x, !0), x.strm.avail_out === 0 ? pt : Qt) : x.last_lit && (Ct(x, !1), x.strm.avail_out === 0) ? be : Je } function fi(x, ee) { for (var ne, E, z, $, Ve = x.window; ;) { if (x.lookahead <= Q) { if (bn(x), x.lookahead <= Q && ee === s) return be; if (x.lookahead === 0) break } if (x.match_length = 0, x.lookahead >= _ && x.strstart > 0 && (z = x.strstart - 1, E = Ve[z], E === Ve[++z] && E === Ve[++z] && E === Ve[++z])) { $ = x.strstart + Q; do; while (E === Ve[++z] && E === Ve[++z] && E === Ve[++z] && E === Ve[++z] && E === Ve[++z] && E === Ve[++z] && E === Ve[++z] && E === Ve[++z] && z < $); x.match_length = Q - ($ - z), x.match_length > x.lookahead && (x.match_length = x.lookahead) } if (x.match_length >= _ ? (ne = e._tr_tally(x, 1, x.match_length - _), x.lookahead -= x.match_length, x.strstart += x.match_length, x.match_length = 0) : (ne = e._tr_tally(x, 0, x.window[x.strstart]), x.lookahead--, x.strstart++), ne && (Ct(x, !1), x.strm.avail_out === 0)) return be } return x.insert = 0, ee === c ? (Ct(x, !0), x.strm.avail_out === 0 ? pt : Qt) : x.last_lit && (Ct(x, !1), x.strm.avail_out === 0) ? be : Je } function fr(x, ee) { for (var ne; ;) { if (x.lookahead === 0 && (bn(x), x.lookahead === 0)) { if (ee === s) return be; break } if (x.match_length = 0, ne = e._tr_tally(x, 0, x.window[x.strstart]), x.lookahead--, x.strstart++, ne && (Ct(x, !1), x.strm.avail_out === 0)) return be } return x.insert = 0, ee === c ? (Ct(x, !0), x.strm.avail_out === 0 ? pt : Qt) : x.last_lit && (Ct(x, !1), x.strm.avail_out === 0) ? be : Je } function Ht(x, ee, ne, E, z) { this.good_length = x, this.max_lazy = ee, this.nice_length = ne, this.max_chain = E, this.func = z } var Zn; Zn = [new Ht(0, 0, 0, 0, ci), new Ht(4, 4, 8, 4, Or), new Ht(4, 5, 16, 8, Or), new Ht(4, 6, 32, 32, Or), new Ht(4, 4, 16, 16, In), new Ht(8, 16, 32, 32, In), new Ht(8, 16, 128, 128, In), new Ht(8, 32, 128, 256, In), new Ht(32, 128, 258, 1024, In), new Ht(32, 258, 258, 4096, In)]; function dr(x) { x.window_size = 2 * x.w_size, vn(x.head), x.max_lazy_match = Zn[x.level].max_lazy, x.good_match = Zn[x.level].good_length, x.nice_match = Zn[x.level].nice_length, x.max_chain_length = Zn[x.level].max_chain, x.strstart = 0, x.block_start = 0, x.lookahead = 0, x.insert = 0, x.match_length = x.prev_length = _ - 1, x.match_available = 0, x.ins_h = 0 } function R() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = V, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new t.Buf16(ye * 2), this.dyn_dtree = new t.Buf16((2 * q + 1) * 2), this.bl_tree = new t.Buf16((2 * ue + 1) * 2), vn(this.dyn_ltree), vn(this.dyn_dtree), vn(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new t.Buf16(ae + 1), this.heap = new t.Buf16(2 * se + 1), vn(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new t.Buf16(2 * se + 1), vn(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function de(x) { var ee; return !x || !x.state ? Et(x, m) : (x.total_in = x.total_out = 0, x.data_type = D, ee = x.state, ee.pending = 0, ee.pending_out = 0, ee.wrap < 0 && (ee.wrap = -ee.wrap), ee.status = ee.wrap ? W : Ee, x.adler = ee.wrap === 2 ? 0 : 1, ee.last_flush = s, e._tr_init(ee), h) } function ge(x) { var ee = de(x); return ee === h && dr(x.state), ee } function ke(x, ee) { return !x || !x.state || x.state.wrap !== 2 ? m : (x.state.gzhead = ee, h) } function H(x, ee, ne, E, z, $) { if (!x) return m; var Ve = 1; if (ee === b && (ee = 6), E < 0 ? (Ve = 0, E = -E) : E > 15 && (Ve = 2, E -= 16), z < 1 || z > B || ne !== V || E < 8 || E > 15 || ee < 0 || ee > 9 || $ < 0 || $ > A) return Et(x, m); E === 8 && (E = 9); var Ce = new R; return x.state = Ce, Ce.strm = x, Ce.wrap = Ve, Ce.gzhead = null, Ce.w_bits = E, Ce.w_size = 1 << Ce.w_bits, Ce.w_mask = Ce.w_size - 1, Ce.hash_bits = z + 7, Ce.hash_size = 1 << Ce.hash_bits, Ce.hash_mask = Ce.hash_size - 1, Ce.hash_shift = ~~((Ce.hash_bits + _ - 1) / _), Ce.window = new t.Buf8(Ce.w_size * 2), Ce.head = new t.Buf16(Ce.hash_size), Ce.prev = new t.Buf16(Ce.w_size), Ce.lit_bufsize = 1 << z + 6, Ce.pending_buf_size = Ce.lit_bufsize * 4, Ce.pending_buf = new t.Buf8(Ce.pending_buf_size), Ce.d_buf = 1 * Ce.lit_bufsize, Ce.l_buf = 3 * Ce.lit_bufsize, Ce.level = ee, Ce.strategy = $, Ce.method = ne, ge(x) } function oe(x, ee) { return H(x, ee, V, I, Y, N) } function k(x, ee) { var ne, E, z, $; if (!x || !x.state || ee > f || ee < 0) return x ? Et(x, m) : m; if (E = x.state, !x.output || !x.input && x.avail_in !== 0 || E.status === Ie && ee !== c) return Et(x, x.avail_out === 0 ? S : m); if (E.strm = x, ne = E.last_flush, E.last_flush = ee, E.status === W) if (E.wrap === 2) x.adler = 0, it(E, 31), it(E, 139), it(E, 8), E.gzhead ? (it(E, (E.gzhead.text ? 1 : 0) + (E.gzhead.hcrc ? 2 : 0) + (E.gzhead.extra ? 4 : 0) + (E.gzhead.name ? 8 : 0) + (E.gzhead.comment ? 16 : 0)), it(E, E.gzhead.time & 255), it(E, E.gzhead.time >> 8 & 255), it(E, E.gzhead.time >> 16 & 255), it(E, E.gzhead.time >> 24 & 255), it(E, E.level === 9 ? 2 : E.strategy >= C || E.level < 2 ? 4 : 0), it(E, E.gzhead.os & 255), E.gzhead.extra && E.gzhead.extra.length && (it(E, E.gzhead.extra.length & 255), it(E, E.gzhead.extra.length >> 8 & 255)), E.gzhead.hcrc && (x.adler = r(x.adler, E.pending_buf, E.pending, 0)), E.gzindex = 0, E.status = re) : (it(E, 0), it(E, 0), it(E, 0), it(E, 0), it(E, 0), it(E, E.level === 9 ? 2 : E.strategy >= C || E.level < 2 ? 4 : 0), it(E, ht), E.status = Ee); else { var Ve = V + (E.w_bits - 8 << 4) << 8, Ce = -1; E.strategy >= C || E.level < 2 ? Ce = 0 : E.level < 6 ? Ce = 1 : E.level === 6 ? Ce = 2 : Ce = 3, Ve |= Ce << 6, E.strstart !== 0 && (Ve |= ce), Ve += 31 - Ve % 31, E.status = Ee, Kt(E, Ve), E.strstart !== 0 && (Kt(E, x.adler >>> 16), Kt(E, x.adler & 65535)), x.adler = 1 } if (E.status === re) if (E.gzhead.extra) { for (z = E.pending; E.gzindex < (E.gzhead.extra.length & 65535) && !(E.pending === E.pending_buf_size && (E.gzhead.hcrc && E.pending > z && (x.adler = r(x.adler, E.pending_buf, E.pending - z, z)), un(x), z = E.pending, E.pending === E.pending_buf_size));)it(E, E.gzhead.extra[E.gzindex] & 255), E.gzindex++; E.gzhead.hcrc && E.pending > z && (x.adler = r(x.adler, E.pending_buf, E.pending - z, z)), E.gzindex === E.gzhead.extra.length && (E.gzindex = 0, E.status = Ae) } else E.status = Ae; if (E.status === Ae) if (E.gzhead.name) { z = E.pending; do { if (E.pending === E.pending_buf_size && (E.gzhead.hcrc && E.pending > z && (x.adler = r(x.adler, E.pending_buf, E.pending - z, z)), un(x), z = E.pending, E.pending === E.pending_buf_size)) { $ = 1; break } E.gzindex < E.gzhead.name.length ? $ = E.gzhead.name.charCodeAt(E.gzindex++) & 255 : $ = 0, it(E, $) } while ($ !== 0); E.gzhead.hcrc && E.pending > z && (x.adler = r(x.adler, E.pending_buf, E.pending - z, z)), $ === 0 && (E.gzindex = 0, E.status = Fe) } else E.status = Fe; if (E.status === Fe) if (E.gzhead.comment) { z = E.pending; do { if (E.pending === E.pending_buf_size && (E.gzhead.hcrc && E.pending > z && (x.adler = r(x.adler, E.pending_buf, E.pending - z, z)), un(x), z = E.pending, E.pending === E.pending_buf_size)) { $ = 1; break } E.gzindex < E.gzhead.comment.length ? $ = E.gzhead.comment.charCodeAt(E.gzindex++) & 255 : $ = 0, it(E, $) } while ($ !== 0); E.gzhead.hcrc && E.pending > z && (x.adler = r(x.adler, E.pending_buf, E.pending - z, z)), $ === 0 && (E.status = Be) } else E.status = Be; if (E.status === Be && (E.gzhead.hcrc ? (E.pending + 2 > E.pending_buf_size && un(x), E.pending + 2 <= E.pending_buf_size && (it(E, x.adler & 255), it(E, x.adler >> 8 & 255), x.adler = 0, E.status = Ee)) : E.status = Ee), E.pending !== 0) { if (un(x), x.avail_out === 0) return E.last_flush = -1, h } else if (x.avail_in === 0 && jn(ee) <= jn(ne) && ee !== c) return Et(x, S); if (E.status === Ie && x.avail_in !== 0) return Et(x, S); if (x.avail_in !== 0 || E.lookahead !== 0 || ee !== s && E.status !== Ie) { var Pe = E.strategy === C ? fr(E, ee) : E.strategy === F ? fi(E, ee) : Zn[E.level].func(E, ee); if ((Pe === pt || Pe === Qt) && (E.status = Ie), Pe === be || Pe === pt) return x.avail_out === 0 && (E.last_flush = -1), h; if (Pe === Je && (ee === a ? e._tr_align(E) : ee !== f && (e._tr_stored_block(E, 0, 0, !1), ee === u && (vn(E.head), E.lookahead === 0 && (E.strstart = 0, E.block_start = 0, E.insert = 0))), un(x), x.avail_out === 0)) return E.last_flush = -1, h } return ee !== c ? h : E.wrap <= 0 ? v : (E.wrap === 2 ? (it(E, x.adler & 255), it(E, x.adler >> 8 & 255), it(E, x.adler >> 16 & 255), it(E, x.adler >> 24 & 255), it(E, x.total_in & 255), it(E, x.total_in >> 8 & 255), it(E, x.total_in >> 16 & 255), it(E, x.total_in >> 24 & 255)) : (Kt(E, x.adler >>> 16), Kt(E, x.adler & 65535)), un(x), E.wrap > 0 && (E.wrap = -E.wrap), E.pending !== 0 ? h : v) } function fe(x) { var ee; return !x || !x.state ? m : (ee = x.state.status, ee !== W && ee !== re && ee !== Ae && ee !== Fe && ee !== Be && ee !== Ee && ee !== Ie ? Et(x, m) : (x.state = null, ee === Ee ? Et(x, g) : h)) } function ze(x, ee) { var ne = ee.length, E, z, $, Ve, Ce, Pe, at, On; if (!x || !x.state || (E = x.state, Ve = E.wrap, Ve === 2 || Ve === 1 && E.status !== W || E.lookahead)) return m; for (Ve === 1 && (x.adler = n(x.adler, ee, ne, 0)), E.wrap = 0, ne >= E.w_size && (Ve === 0 && (vn(E.head), E.strstart = 0, E.block_start = 0, E.insert = 0), On = new t.Buf8(E.w_size), t.arraySet(On, ee, ne - E.w_size, E.w_size, 0), ee = On, ne = E.w_size), Ce = x.avail_in, Pe = x.next_in, at = x.input, x.avail_in = ne, x.next_in = 0, x.input = ee, bn(E); E.lookahead >= _;) { z = E.strstart, $ = E.lookahead - (_ - 1); do E.ins_h = (E.ins_h << E.hash_shift ^ E.window[z + _ - 1]) & E.hash_mask, E.prev[z & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = z, z++; while (--$); E.strstart = z, E.lookahead = _ - 1, bn(E) } return E.strstart += E.lookahead, E.block_start = E.strstart, E.insert = E.lookahead, E.lookahead = 0, E.match_length = E.prev_length = _ - 1, E.match_available = 0, x.next_in = Pe, x.input = at, x.avail_in = Ce, E.wrap = Ve, h } return zr.deflateInit = oe, zr.deflateInit2 = H, zr.deflateReset = ge, zr.deflateResetKeep = de, zr.deflateSetHeader = ke, zr.deflate = k, zr.deflateEnd = fe, zr.deflateSetDictionary = ze, zr.deflateInfo = "pako deflate (from Nodeca project)", zr } var Io = {}, _x; function lP() { if (_x) return Io; _x = 1; var t = So(), e = !0, n = !0; try { String.fromCharCode.apply(null, [0]) } catch { e = !1 } try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch { n = !1 } for (var r = new t.Buf8(256), i = 0; i < 256; i++)r[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1; r[254] = r[254] = 1, Io.string2buf = function (a) { var u, c, f, h, v, m = a.length, g = 0; for (h = 0; h < m; h++)c = a.charCodeAt(h), (c & 64512) === 55296 && h + 1 < m && (f = a.charCodeAt(h + 1), (f & 64512) === 56320 && (c = 65536 + (c - 55296 << 10) + (f - 56320), h++)), g += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4; for (u = new t.Buf8(g), v = 0, h = 0; v < g; h++)c = a.charCodeAt(h), (c & 64512) === 55296 && h + 1 < m && (f = a.charCodeAt(h + 1), (f & 64512) === 56320 && (c = 65536 + (c - 55296 << 10) + (f - 56320), h++)), c < 128 ? u[v++] = c : c < 2048 ? (u[v++] = 192 | c >>> 6, u[v++] = 128 | c & 63) : c < 65536 ? (u[v++] = 224 | c >>> 12, u[v++] = 128 | c >>> 6 & 63, u[v++] = 128 | c & 63) : (u[v++] = 240 | c >>> 18, u[v++] = 128 | c >>> 12 & 63, u[v++] = 128 | c >>> 6 & 63, u[v++] = 128 | c & 63); return u }; function s(a, u) { if (u < 65534 && (a.subarray && n || !a.subarray && e)) return String.fromCharCode.apply(null, t.shrinkBuf(a, u)); for (var c = "", f = 0; f < u; f++)c += String.fromCharCode(a[f]); return c } return Io.buf2binstring = function (a) { return s(a, a.length) }, Io.binstring2buf = function (a) { for (var u = new t.Buf8(a.length), c = 0, f = u.length; c < f; c++)u[c] = a.charCodeAt(c); return u }, Io.buf2string = function (a, u) { var c, f, h, v, m = u || a.length, g = new Array(m * 2); for (f = 0, c = 0; c < m;) { if (h = a[c++], h < 128) { g[f++] = h; continue } if (v = r[h], v > 4) { g[f++] = 65533, c += v - 1; continue } for (h &= v === 2 ? 31 : v === 3 ? 15 : 7; v > 1 && c < m;)h = h << 6 | a[c++] & 63, v--; if (v > 1) { g[f++] = 65533; continue } h < 65536 ? g[f++] = h : (h -= 65536, g[f++] = 55296 | h >> 10 & 1023, g[f++] = 56320 | h & 1023) } return s(g, f) }, Io.utf8border = function (a, u) { var c; for (u = u || a.length, u > a.length && (u = a.length), c = u - 1; c >= 0 && (a[c] & 192) === 128;)c--; return c < 0 || c === 0 ? u : c + r[a[c]] > u ? c : u }, Io } var yp, $x; function uP() { if ($x) return yp; $x = 1; function t() { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } return yp = t, yp } var ew; function vM() { if (ew) return Ms; ew = 1; var t = pM(), e = So(), n = lP(), r = Rv(), i = uP(), s = Object.prototype.toString, a = 0, u = 4, c = 0, f = 1, h = 2, v = -1, m = 0, g = 8; function S(F) { if (!(this instanceof S)) return new S(F); this.options = e.assign({ level: v, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: m, to: "" }, F || {}); var A = this.options; A.raw && A.windowBits > 0 ? A.windowBits = -A.windowBits : A.gzip && A.windowBits > 0 && A.windowBits < 16 && (A.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i, this.strm.avail_out = 0; var N = t.deflateInit2(this.strm, A.level, A.method, A.windowBits, A.memLevel, A.strategy); if (N !== c) throw new Error(r[N]); if (A.header && t.deflateSetHeader(this.strm, A.header), A.dictionary) { var D; if (typeof A.dictionary == "string" ? D = n.string2buf(A.dictionary) : s.call(A.dictionary) === "[object ArrayBuffer]" ? D = new Uint8Array(A.dictionary) : D = A.dictionary, N = t.deflateSetDictionary(this.strm, D), N !== c) throw new Error(r[N]); this._dict_set = !0 } } S.prototype.push = function (F, A) { var N = this.strm, D = this.options.chunkSize, V, B; if (this.ended) return !1; B = A === ~~A ? A : A === !0 ? u : a, typeof F == "string" ? N.input = n.string2buf(F) : s.call(F) === "[object ArrayBuffer]" ? N.input = new Uint8Array(F) : N.input = F, N.next_in = 0, N.avail_in = N.input.length; do { if (N.avail_out === 0 && (N.output = new e.Buf8(D), N.next_out = 0, N.avail_out = D), V = t.deflate(N, B), V !== f && V !== c) return this.onEnd(V), this.ended = !0, !1; (N.avail_out === 0 || N.avail_in === 0 && (B === u || B === h)) && (this.options.to === "string" ? this.onData(n.buf2binstring(e.shrinkBuf(N.output, N.next_out))) : this.onData(e.shrinkBuf(N.output, N.next_out))) } while ((N.avail_in > 0 || N.avail_out === 0) && V !== f); return B === u ? (V = t.deflateEnd(this.strm), this.onEnd(V), this.ended = !0, V === c) : (B === h && (this.onEnd(c), N.avail_out = 0), !0) }, S.prototype.onData = function (F) { this.chunks.push(F) }, S.prototype.onEnd = function (F) { F === c && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = e.flattenChunks(this.chunks)), this.chunks = [], this.err = F, this.msg = this.strm.msg }; function b(F, A) { var N = new S(A); if (N.push(F, !0), N.err) throw N.msg || r[N.err]; return N.result } function P(F, A) { return A = A || {}, A.raw = !0, b(F, A) } function C(F, A) { return A = A || {}, A.gzip = !0, b(F, A) } return Ms.Deflate = S, Ms.deflate = b, Ms.deflateRaw = P, Ms.gzip = C, Ms } var Vs = {}, wr = {}, xp, tw; function mM() { if (tw) return xp; tw = 1; var t = 30, e = 12; return xp = function (r, i) { var s, a, u, c, f, h, v, m, g, S, b, P, C, F, A, N, D, V, B, I, Y, Z, ie, se, q; s = r.state, a = r.next_in, se = r.input, u = a + (r.avail_in - 5), c = r.next_out, q = r.output, f = c - (i - r.avail_out), h = c + (r.avail_out - 257), v = s.dmax, m = s.wsize, g = s.whave, S = s.wnext, b = s.window, P = s.hold, C = s.bits, F = s.lencode, A = s.distcode, N = (1 << s.lenbits) - 1, D = (1 << s.distbits) - 1; e: do { C < 15 && (P += se[a++] << C, C += 8, P += se[a++] << C, C += 8), V = F[P & N]; t: for (; ;) { if (B = V >>> 24, P >>>= B, C -= B, B = V >>> 16 & 255, B === 0) q[c++] = V & 65535; else if (B & 16) { I = V & 65535, B &= 15, B && (C < B && (P += se[a++] << C, C += 8), I += P & (1 << B) - 1, P >>>= B, C -= B), C < 15 && (P += se[a++] << C, C += 8, P += se[a++] << C, C += 8), V = A[P & D]; n: for (; ;) { if (B = V >>> 24, P >>>= B, C -= B, B = V >>> 16 & 255, B & 16) { if (Y = V & 65535, B &= 15, C < B && (P += se[a++] << C, C += 8, C < B && (P += se[a++] << C, C += 8)), Y += P & (1 << B) - 1, Y > v) { r.msg = "invalid distance too far back", s.mode = t; break e } if (P >>>= B, C -= B, B = c - f, Y > B) { if (B = Y - B, B > g && s.sane) { r.msg = "invalid distance too far back", s.mode = t; break e } if (Z = 0, ie = b, S === 0) { if (Z += m - B, B < I) { I -= B; do q[c++] = b[Z++]; while (--B); Z = c - Y, ie = q } } else if (S < B) { if (Z += m + S - B, B -= S, B < I) { I -= B; do q[c++] = b[Z++]; while (--B); if (Z = 0, S < I) { B = S, I -= B; do q[c++] = b[Z++]; while (--B); Z = c - Y, ie = q } } } else if (Z += S - B, B < I) { I -= B; do q[c++] = b[Z++]; while (--B); Z = c - Y, ie = q } for (; I > 2;)q[c++] = ie[Z++], q[c++] = ie[Z++], q[c++] = ie[Z++], I -= 3; I && (q[c++] = ie[Z++], I > 1 && (q[c++] = ie[Z++])) } else { Z = c - Y; do q[c++] = q[Z++], q[c++] = q[Z++], q[c++] = q[Z++], I -= 3; while (I > 2); I && (q[c++] = q[Z++], I > 1 && (q[c++] = q[Z++])) } } else if (B & 64) { r.msg = "invalid distance code", s.mode = t; break e } else { V = A[(V & 65535) + (P & (1 << B) - 1)]; continue n } break } } else if (B & 64) if (B & 32) { s.mode = e; break e } else { r.msg = "invalid literal/length code", s.mode = t; break e } else { V = F[(V & 65535) + (P & (1 << B) - 1)]; continue t } break } } while (a < u && c < h); I = C >> 3, a -= I, C -= I << 3, P &= (1 << C) - 1, r.next_in = a, r.next_out = c, r.avail_in = a < u ? 5 + (u - a) : 5 - (a - u), r.avail_out = c < h ? 257 + (h - c) : 257 - (c - h), s.hold = P, s.bits = C }, xp } var wp, nw; function gM() { if (nw) return wp; nw = 1; var t = So(), e = 15, n = 852, r = 592, i = 0, s = 1, a = 2, u = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], f = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], h = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; return wp = function (m, g, S, b, P, C, F, A) { var N = A.bits, D = 0, V = 0, B = 0, I = 0, Y = 0, Z = 0, ie = 0, se = 0, q = 0, ue = 0, ye, ae, _, Q, le, ce = null, W = 0, re, Ae = new t.Buf16(e + 1), Fe = new t.Buf16(e + 1), Be = null, Ee = 0, Ie, be, Je; for (D = 0; D <= e; D++)Ae[D] = 0; for (V = 0; V < b; V++)Ae[g[S + V]]++; for (Y = N, I = e; I >= 1 && Ae[I] === 0; I--); if (Y > I && (Y = I), I === 0) return P[C++] = 1 << 24 | 64 << 16 | 0, P[C++] = 1 << 24 | 64 << 16 | 0, A.bits = 1, 0; for (B = 1; B < I && Ae[B] === 0; B++); for (Y < B && (Y = B), se = 1, D = 1; D <= e; D++)if (se <<= 1, se -= Ae[D], se < 0) return -1; if (se > 0 && (m === i || I !== 1)) return -1; for (Fe[1] = 0, D = 1; D < e; D++)Fe[D + 1] = Fe[D] + Ae[D]; for (V = 0; V < b; V++)g[S + V] !== 0 && (F[Fe[g[S + V]]++] = V); if (m === i ? (ce = Be = F, re = 19) : m === s ? (ce = u, W -= 257, Be = c, Ee -= 257, re = 256) : (ce = f, Be = h, re = -1), ue = 0, V = 0, D = B, le = C, Z = Y, ie = 0, _ = -1, q = 1 << Y, Q = q - 1, m === s && q > n || m === a && q > r) return 1; for (; ;) { Ie = D - ie, F[V] < re ? (be = 0, Je = F[V]) : F[V] > re ? (be = Be[Ee + F[V]], Je = ce[W + F[V]]) : (be = 96, Je = 0), ye = 1 << D - ie, ae = 1 << Z, B = ae; do ae -= ye, P[le + (ue >> ie) + ae] = Ie << 24 | be << 16 | Je | 0; while (ae !== 0); for (ye = 1 << D - 1; ue & ye;)ye >>= 1; if (ye !== 0 ? (ue &= ye - 1, ue += ye) : ue = 0, V++, --Ae[D] === 0) { if (D === I) break; D = g[S + F[V]] } if (D > Y && (ue & Q) !== _) { for (ie === 0 && (ie = Y), le += B, Z = D - ie, se = 1 << Z; Z + ie < I && (se -= Ae[Z + ie], !(se <= 0));)Z++, se <<= 1; if (q += 1 << Z, m === s && q > n || m === a && q > r) return 1; _ = ue & Q, P[_] = Y << 24 | Z << 16 | le - C | 0 } } return ue !== 0 && (P[le + ue] = D - ie << 24 | 64 << 16 | 0), A.bits = Y, 0 }, wp } var rw; function yM() { if (rw) return wr; rw = 1; var t = So(), e = sP(), n = aP(), r = mM(), i = gM(), s = 0, a = 1, u = 2, c = 4, f = 5, h = 6, v = 0, m = 1, g = 2, S = -2, b = -3, P = -4, C = -5, F = 8, A = 1, N = 2, D = 3, V = 4, B = 5, I = 6, Y = 7, Z = 8, ie = 9, se = 10, q = 11, ue = 12, ye = 13, ae = 14, _ = 15, Q = 16, le = 17, ce = 18, W = 19, re = 20, Ae = 21, Fe = 22, Be = 23, Ee = 24, Ie = 25, be = 26, Je = 27, pt = 28, Qt = 29, ht = 30, Et = 31, jn = 32, vn = 852, un = 592, Ct = 15, it = Ct; function Kt(H) { return (H >>> 24 & 255) + (H >>> 8 & 65280) + ((H & 65280) << 8) + ((H & 255) << 24) } function cr() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new t.Buf16(320), this.work = new t.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } function Dn(H) { var oe; return !H || !H.state ? S : (oe = H.state, H.total_in = H.total_out = oe.total = 0, H.msg = "", oe.wrap && (H.adler = oe.wrap & 1), oe.mode = A, oe.last = 0, oe.havedict = 0, oe.dmax = 32768, oe.head = null, oe.hold = 0, oe.bits = 0, oe.lencode = oe.lendyn = new t.Buf32(vn), oe.distcode = oe.distdyn = new t.Buf32(un), oe.sane = 1, oe.back = -1, v) } function bn(H) { var oe; return !H || !H.state ? S : (oe = H.state, oe.wsize = 0, oe.whave = 0, oe.wnext = 0, Dn(H)) } function ci(H, oe) { var k, fe; return !H || !H.state || (fe = H.state, oe < 0 ? (k = 0, oe = -oe) : (k = (oe >> 4) + 1, oe < 48 && (oe &= 15)), oe && (oe < 8 || oe > 15)) ? S : (fe.window !== null && fe.wbits !== oe && (fe.window = null), fe.wrap = k, fe.wbits = oe, bn(H)) } function Or(H, oe) { var k, fe; return H ? (fe = new cr, H.state = fe, fe.window = null, k = ci(H, oe), k !== v && (H.state = null), k) : S } function In(H) { return Or(H, it) } var fi = !0, fr, Ht; function Zn(H) { if (fi) { var oe; for (fr = new t.Buf32(512), Ht = new t.Buf32(32), oe = 0; oe < 144;)H.lens[oe++] = 8; for (; oe < 256;)H.lens[oe++] = 9; for (; oe < 280;)H.lens[oe++] = 7; for (; oe < 288;)H.lens[oe++] = 8; for (i(a, H.lens, 0, 288, fr, 0, H.work, { bits: 9 }), oe = 0; oe < 32;)H.lens[oe++] = 5; i(u, H.lens, 0, 32, Ht, 0, H.work, { bits: 5 }), fi = !1 } H.lencode = fr, H.lenbits = 9, H.distcode = Ht, H.distbits = 5 } function dr(H, oe, k, fe) { var ze, x = H.state; return x.window === null && (x.wsize = 1 << x.wbits, x.wnext = 0, x.whave = 0, x.window = new t.Buf8(x.wsize)), fe >= x.wsize ? (t.arraySet(x.window, oe, k - x.wsize, x.wsize, 0), x.wnext = 0, x.whave = x.wsize) : (ze = x.wsize - x.wnext, ze > fe && (ze = fe), t.arraySet(x.window, oe, k - fe, ze, x.wnext), fe -= ze, fe ? (t.arraySet(x.window, oe, k - fe, fe, 0), x.wnext = fe, x.whave = x.wsize) : (x.wnext += ze, x.wnext === x.wsize && (x.wnext = 0), x.whave < x.wsize && (x.whave += ze))), 0 } function R(H, oe) { var k, fe, ze, x, ee, ne, E, z, $, Ve, Ce, Pe, at, On, kt = 0, ot, qt, jt, $t, di, Bi, It, zn, en = new t.Buf8(4), mn, Yn, ma = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!H || !H.state || !H.output || !H.input && H.avail_in !== 0) return S; k = H.state, k.mode === ue && (k.mode = ye), ee = H.next_out, ze = H.output, E = H.avail_out, x = H.next_in, fe = H.input, ne = H.avail_in, z = k.hold, $ = k.bits, Ve = ne, Ce = E, zn = v; e: for (; ;)switch (k.mode) { case A: if (k.wrap === 0) { k.mode = ye; break } for (; $ < 16;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (k.wrap & 2 && z === 35615) { k.check = 0, en[0] = z & 255, en[1] = z >>> 8 & 255, k.check = n(k.check, en, 2, 0), z = 0, $ = 0, k.mode = N; break } if (k.flags = 0, k.head && (k.head.done = !1), !(k.wrap & 1) || (((z & 255) << 8) + (z >> 8)) % 31) { H.msg = "incorrect header check", k.mode = ht; break } if ((z & 15) !== F) { H.msg = "unknown compression method", k.mode = ht; break } if (z >>>= 4, $ -= 4, It = (z & 15) + 8, k.wbits === 0) k.wbits = It; else if (It > k.wbits) { H.msg = "invalid window size", k.mode = ht; break } k.dmax = 1 << It, H.adler = k.check = 1, k.mode = z & 512 ? se : ue, z = 0, $ = 0; break; case N: for (; $ < 16;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (k.flags = z, (k.flags & 255) !== F) { H.msg = "unknown compression method", k.mode = ht; break } if (k.flags & 57344) { H.msg = "unknown header flags set", k.mode = ht; break } k.head && (k.head.text = z >> 8 & 1), k.flags & 512 && (en[0] = z & 255, en[1] = z >>> 8 & 255, k.check = n(k.check, en, 2, 0)), z = 0, $ = 0, k.mode = D; case D: for (; $ < 32;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } k.head && (k.head.time = z), k.flags & 512 && (en[0] = z & 255, en[1] = z >>> 8 & 255, en[2] = z >>> 16 & 255, en[3] = z >>> 24 & 255, k.check = n(k.check, en, 4, 0)), z = 0, $ = 0, k.mode = V; case V: for (; $ < 16;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } k.head && (k.head.xflags = z & 255, k.head.os = z >> 8), k.flags & 512 && (en[0] = z & 255, en[1] = z >>> 8 & 255, k.check = n(k.check, en, 2, 0)), z = 0, $ = 0, k.mode = B; case B: if (k.flags & 1024) { for (; $ < 16;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } k.length = z, k.head && (k.head.extra_len = z), k.flags & 512 && (en[0] = z & 255, en[1] = z >>> 8 & 255, k.check = n(k.check, en, 2, 0)), z = 0, $ = 0 } else k.head && (k.head.extra = null); k.mode = I; case I: if (k.flags & 1024 && (Pe = k.length, Pe > ne && (Pe = ne), Pe && (k.head && (It = k.head.extra_len - k.length, k.head.extra || (k.head.extra = new Array(k.head.extra_len)), t.arraySet(k.head.extra, fe, x, Pe, It)), k.flags & 512 && (k.check = n(k.check, fe, Pe, x)), ne -= Pe, x += Pe, k.length -= Pe), k.length)) break e; k.length = 0, k.mode = Y; case Y: if (k.flags & 2048) { if (ne === 0) break e; Pe = 0; do It = fe[x + Pe++], k.head && It && k.length < 65536 && (k.head.name += String.fromCharCode(It)); while (It && Pe < ne); if (k.flags & 512 && (k.check = n(k.check, fe, Pe, x)), ne -= Pe, x += Pe, It) break e } else k.head && (k.head.name = null); k.length = 0, k.mode = Z; case Z: if (k.flags & 4096) { if (ne === 0) break e; Pe = 0; do It = fe[x + Pe++], k.head && It && k.length < 65536 && (k.head.comment += String.fromCharCode(It)); while (It && Pe < ne); if (k.flags & 512 && (k.check = n(k.check, fe, Pe, x)), ne -= Pe, x += Pe, It) break e } else k.head && (k.head.comment = null); k.mode = ie; case ie: if (k.flags & 512) { for (; $ < 16;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (z !== (k.check & 65535)) { H.msg = "header crc mismatch", k.mode = ht; break } z = 0, $ = 0 } k.head && (k.head.hcrc = k.flags >> 9 & 1, k.head.done = !0), H.adler = k.check = 0, k.mode = ue; break; case se: for (; $ < 32;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } H.adler = k.check = Kt(z), z = 0, $ = 0, k.mode = q; case q: if (k.havedict === 0) return H.next_out = ee, H.avail_out = E, H.next_in = x, H.avail_in = ne, k.hold = z, k.bits = $, g; H.adler = k.check = 1, k.mode = ue; case ue: if (oe === f || oe === h) break e; case ye: if (k.last) { z >>>= $ & 7, $ -= $ & 7, k.mode = Je; break } for (; $ < 3;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } switch (k.last = z & 1, z >>>= 1, $ -= 1, z & 3) { case 0: k.mode = ae; break; case 1: if (Zn(k), k.mode = re, oe === h) { z >>>= 2, $ -= 2; break e } break; case 2: k.mode = le; break; case 3: H.msg = "invalid block type", k.mode = ht }z >>>= 2, $ -= 2; break; case ae: for (z >>>= $ & 7, $ -= $ & 7; $ < 32;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if ((z & 65535) !== (z >>> 16 ^ 65535)) { H.msg = "invalid stored block lengths", k.mode = ht; break } if (k.length = z & 65535, z = 0, $ = 0, k.mode = _, oe === h) break e; case _: k.mode = Q; case Q: if (Pe = k.length, Pe) { if (Pe > ne && (Pe = ne), Pe > E && (Pe = E), Pe === 0) break e; t.arraySet(ze, fe, x, Pe, ee), ne -= Pe, x += Pe, E -= Pe, ee += Pe, k.length -= Pe; break } k.mode = ue; break; case le: for (; $ < 14;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (k.nlen = (z & 31) + 257, z >>>= 5, $ -= 5, k.ndist = (z & 31) + 1, z >>>= 5, $ -= 5, k.ncode = (z & 15) + 4, z >>>= 4, $ -= 4, k.nlen > 286 || k.ndist > 30) { H.msg = "too many length or distance symbols", k.mode = ht; break } k.have = 0, k.mode = ce; case ce: for (; k.have < k.ncode;) { for (; $ < 3;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } k.lens[ma[k.have++]] = z & 7, z >>>= 3, $ -= 3 } for (; k.have < 19;)k.lens[ma[k.have++]] = 0; if (k.lencode = k.lendyn, k.lenbits = 7, mn = { bits: k.lenbits }, zn = i(s, k.lens, 0, 19, k.lencode, 0, k.work, mn), k.lenbits = mn.bits, zn) { H.msg = "invalid code lengths set", k.mode = ht; break } k.have = 0, k.mode = W; case W: for (; k.have < k.nlen + k.ndist;) { for (; kt = k.lencode[z & (1 << k.lenbits) - 1], ot = kt >>> 24, qt = kt >>> 16 & 255, jt = kt & 65535, !(ot <= $);) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (jt < 16) z >>>= ot, $ -= ot, k.lens[k.have++] = jt; else { if (jt === 16) { for (Yn = ot + 2; $ < Yn;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (z >>>= ot, $ -= ot, k.have === 0) { H.msg = "invalid bit length repeat", k.mode = ht; break } It = k.lens[k.have - 1], Pe = 3 + (z & 3), z >>>= 2, $ -= 2 } else if (jt === 17) { for (Yn = ot + 3; $ < Yn;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } z >>>= ot, $ -= ot, It = 0, Pe = 3 + (z & 7), z >>>= 3, $ -= 3 } else { for (Yn = ot + 7; $ < Yn;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } z >>>= ot, $ -= ot, It = 0, Pe = 11 + (z & 127), z >>>= 7, $ -= 7 } if (k.have + Pe > k.nlen + k.ndist) { H.msg = "invalid bit length repeat", k.mode = ht; break } for (; Pe--;)k.lens[k.have++] = It } } if (k.mode === ht) break; if (k.lens[256] === 0) { H.msg = "invalid code -- missing end-of-block", k.mode = ht; break } if (k.lenbits = 9, mn = { bits: k.lenbits }, zn = i(a, k.lens, 0, k.nlen, k.lencode, 0, k.work, mn), k.lenbits = mn.bits, zn) { H.msg = "invalid literal/lengths set", k.mode = ht; break } if (k.distbits = 6, k.distcode = k.distdyn, mn = { bits: k.distbits }, zn = i(u, k.lens, k.nlen, k.ndist, k.distcode, 0, k.work, mn), k.distbits = mn.bits, zn) { H.msg = "invalid distances set", k.mode = ht; break } if (k.mode = re, oe === h) break e; case re: k.mode = Ae; case Ae: if (ne >= 6 && E >= 258) { H.next_out = ee, H.avail_out = E, H.next_in = x, H.avail_in = ne, k.hold = z, k.bits = $, r(H, Ce), ee = H.next_out, ze = H.output, E = H.avail_out, x = H.next_in, fe = H.input, ne = H.avail_in, z = k.hold, $ = k.bits, k.mode === ue && (k.back = -1); break } for (k.back = 0; kt = k.lencode[z & (1 << k.lenbits) - 1], ot = kt >>> 24, qt = kt >>> 16 & 255, jt = kt & 65535, !(ot <= $);) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (qt && !(qt & 240)) { for ($t = ot, di = qt, Bi = jt; kt = k.lencode[Bi + ((z & (1 << $t + di) - 1) >> $t)], ot = kt >>> 24, qt = kt >>> 16 & 255, jt = kt & 65535, !($t + ot <= $);) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } z >>>= $t, $ -= $t, k.back += $t } if (z >>>= ot, $ -= ot, k.back += ot, k.length = jt, qt === 0) { k.mode = be; break } if (qt & 32) { k.back = -1, k.mode = ue; break } if (qt & 64) { H.msg = "invalid literal/length code", k.mode = ht; break } k.extra = qt & 15, k.mode = Fe; case Fe: if (k.extra) { for (Yn = k.extra; $ < Yn;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } k.length += z & (1 << k.extra) - 1, z >>>= k.extra, $ -= k.extra, k.back += k.extra } k.was = k.length, k.mode = Be; case Be: for (; kt = k.distcode[z & (1 << k.distbits) - 1], ot = kt >>> 24, qt = kt >>> 16 & 255, jt = kt & 65535, !(ot <= $);) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (!(qt & 240)) { for ($t = ot, di = qt, Bi = jt; kt = k.distcode[Bi + ((z & (1 << $t + di) - 1) >> $t)], ot = kt >>> 24, qt = kt >>> 16 & 255, jt = kt & 65535, !($t + ot <= $);) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } z >>>= $t, $ -= $t, k.back += $t } if (z >>>= ot, $ -= ot, k.back += ot, qt & 64) { H.msg = "invalid distance code", k.mode = ht; break } k.offset = jt, k.extra = qt & 15, k.mode = Ee; case Ee: if (k.extra) { for (Yn = k.extra; $ < Yn;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } k.offset += z & (1 << k.extra) - 1, z >>>= k.extra, $ -= k.extra, k.back += k.extra } if (k.offset > k.dmax) { H.msg = "invalid distance too far back", k.mode = ht; break } k.mode = Ie; case Ie: if (E === 0) break e; if (Pe = Ce - E, k.offset > Pe) { if (Pe = k.offset - Pe, Pe > k.whave && k.sane) { H.msg = "invalid distance too far back", k.mode = ht; break } Pe > k.wnext ? (Pe -= k.wnext, at = k.wsize - Pe) : at = k.wnext - Pe, Pe > k.length && (Pe = k.length), On = k.window } else On = ze, at = ee - k.offset, Pe = k.length; Pe > E && (Pe = E), E -= Pe, k.length -= Pe; do ze[ee++] = On[at++]; while (--Pe); k.length === 0 && (k.mode = Ae); break; case be: if (E === 0) break e; ze[ee++] = k.length, E--, k.mode = Ae; break; case Je: if (k.wrap) { for (; $ < 32;) { if (ne === 0) break e; ne--, z |= fe[x++] << $, $ += 8 } if (Ce -= E, H.total_out += Ce, k.total += Ce, Ce && (H.adler = k.check = k.flags ? n(k.check, ze, Ce, ee - Ce) : e(k.check, ze, Ce, ee - Ce)), Ce = E, (k.flags ? z : Kt(z)) !== k.check) { H.msg = "incorrect data check", k.mode = ht; break } z = 0, $ = 0 } k.mode = pt; case pt: if (k.wrap && k.flags) { for (; $ < 32;) { if (ne === 0) break e; ne--, z += fe[x++] << $, $ += 8 } if (z !== (k.total & 4294967295)) { H.msg = "incorrect length check", k.mode = ht; break } z = 0, $ = 0 } k.mode = Qt; case Qt: zn = m; break e; case ht: zn = b; break e; case Et: return P; case jn: default: return S }return H.next_out = ee, H.avail_out = E, H.next_in = x, H.avail_in = ne, k.hold = z, k.bits = $, (k.wsize || Ce !== H.avail_out && k.mode < ht && (k.mode < Je || oe !== c)) && dr(H, H.output, H.next_out, Ce - H.avail_out), Ve -= H.avail_in, Ce -= H.avail_out, H.total_in += Ve, H.total_out += Ce, k.total += Ce, k.wrap && Ce && (H.adler = k.check = k.flags ? n(k.check, ze, Ce, H.next_out - Ce) : e(k.check, ze, Ce, H.next_out - Ce)), H.data_type = k.bits + (k.last ? 64 : 0) + (k.mode === ue ? 128 : 0) + (k.mode === re || k.mode === _ ? 256 : 0), (Ve === 0 && Ce === 0 || oe === c) && zn === v && (zn = C), zn } function de(H) { if (!H || !H.state) return S; var oe = H.state; return oe.window && (oe.window = null), H.state = null, v } function ge(H, oe) { var k; return !H || !H.state || (k = H.state, !(k.wrap & 2)) ? S : (k.head = oe, oe.done = !1, v) } function ke(H, oe) { var k = oe.length, fe, ze, x; return !H || !H.state || (fe = H.state, fe.wrap !== 0 && fe.mode !== q) ? S : fe.mode === q && (ze = 1, ze = e(ze, oe, k, 0), ze !== fe.check) ? b : (x = dr(H, oe, k, k), x ? (fe.mode = Et, P) : (fe.havedict = 1, v)) } return wr.inflateReset = bn, wr.inflateReset2 = ci, wr.inflateResetKeep = Dn, wr.inflateInit = In, wr.inflateInit2 = Or, wr.inflate = R, wr.inflateEnd = de, wr.inflateGetHeader = ge, wr.inflateSetDictionary = ke, wr.inflateInfo = "pako inflate (from Nodeca project)", wr } var Sp, iw; function cP() { return iw || (iw = 1, Sp = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }), Sp } var bp, ow; function xM() { if (ow) return bp; ow = 1; function t() { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1 } return bp = t, bp } var sw; function wM() { if (sw) return Vs; sw = 1; var t = yM(), e = So(), n = lP(), r = cP(), i = Rv(), s = uP(), a = xM(), u = Object.prototype.toString; function c(v) { if (!(this instanceof c)) return new c(v); this.options = e.assign({ chunkSize: 16384, windowBits: 0, to: "" }, v || {}); var m = this.options; m.raw && m.windowBits >= 0 && m.windowBits < 16 && (m.windowBits = -m.windowBits, m.windowBits === 0 && (m.windowBits = -15)), m.windowBits >= 0 && m.windowBits < 16 && !(v && v.windowBits) && (m.windowBits += 32), m.windowBits > 15 && m.windowBits < 48 && (m.windowBits & 15 || (m.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s, this.strm.avail_out = 0; var g = t.inflateInit2(this.strm, m.windowBits); if (g !== r.Z_OK) throw new Error(i[g]); if (this.header = new a, t.inflateGetHeader(this.strm, this.header), m.dictionary && (typeof m.dictionary == "string" ? m.dictionary = n.string2buf(m.dictionary) : u.call(m.dictionary) === "[object ArrayBuffer]" && (m.dictionary = new Uint8Array(m.dictionary)), m.raw && (g = t.inflateSetDictionary(this.strm, m.dictionary), g !== r.Z_OK))) throw new Error(i[g]) } c.prototype.push = function (v, m) { var g = this.strm, S = this.options.chunkSize, b = this.options.dictionary, P, C, F, A, N, D = !1; if (this.ended) return !1; C = m === ~~m ? m : m === !0 ? r.Z_FINISH : r.Z_NO_FLUSH, typeof v == "string" ? g.input = n.binstring2buf(v) : u.call(v) === "[object ArrayBuffer]" ? g.input = new Uint8Array(v) : g.input = v, g.next_in = 0, g.avail_in = g.input.length; do { if (g.avail_out === 0 && (g.output = new e.Buf8(S), g.next_out = 0, g.avail_out = S), P = t.inflate(g, r.Z_NO_FLUSH), P === r.Z_NEED_DICT && b && (P = t.inflateSetDictionary(this.strm, b)), P === r.Z_BUF_ERROR && D === !0 && (P = r.Z_OK, D = !1), P !== r.Z_STREAM_END && P !== r.Z_OK) return this.onEnd(P), this.ended = !0, !1; g.next_out && (g.avail_out === 0 || P === r.Z_STREAM_END || g.avail_in === 0 && (C === r.Z_FINISH || C === r.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (F = n.utf8border(g.output, g.next_out), A = g.next_out - F, N = n.buf2string(g.output, F), g.next_out = A, g.avail_out = S - A, A && e.arraySet(g.output, g.output, F, A, 0), this.onData(N)) : this.onData(e.shrinkBuf(g.output, g.next_out))), g.avail_in === 0 && g.avail_out === 0 && (D = !0) } while ((g.avail_in > 0 || g.avail_out === 0) && P !== r.Z_STREAM_END); return P === r.Z_STREAM_END && (C = r.Z_FINISH), C === r.Z_FINISH ? (P = t.inflateEnd(this.strm), this.onEnd(P), this.ended = !0, P === r.Z_OK) : (C === r.Z_SYNC_FLUSH && (this.onEnd(r.Z_OK), g.avail_out = 0), !0) }, c.prototype.onData = function (v) { this.chunks.push(v) }, c.prototype.onEnd = function (v) { v === r.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = e.flattenChunks(this.chunks)), this.chunks = [], this.err = v, this.msg = this.strm.msg }; function f(v, m) { var g = new c(m); if (g.push(v, !0), g.err) throw g.msg || i[g.err]; return g.result } function h(v, m) { return m = m || {}, m.raw = !0, f(v, m) } return Vs.Inflate = c, Vs.inflate = f, Vs.inflateRaw = h, Vs.ungzip = f, Vs } var Cp, aw; function SM() { if (aw) return Cp; aw = 1; var t = So().assign, e = vM(), n = wM(), r = cP(), i = {}; return t(i, e, n, r), Cp = i, Cp } var bM = SM(); const If = Y0(bM); var lw = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", fl = new Uint8Array(256); for (var Tc = 0; Tc < lw.length; Tc++)fl[lw.charCodeAt(Tc)] = Tc; var CM = function (t) { var e = t.length * .75, n = t.length, r, i = 0, s, a, u, c; t[t.length - 1] === "=" && (e--, t[t.length - 2] === "=" && e--); var f = new Uint8Array(e); for (r = 0; r < n; r += 4)s = fl[t.charCodeAt(r)], a = fl[t.charCodeAt(r + 1)], u = fl[t.charCodeAt(r + 2)], c = fl[t.charCodeAt(r + 3)], f[i++] = s << 2 | a >> 4, f[i++] = (a & 15) << 4 | u >> 2, f[i++] = (u & 3) << 6 | c & 63; return f }, PM = function (t) { for (var e = "", n = 0; n < t.length; n++)e += String.fromCharCode(t[n]); return e }, fP = function (t) { return PM(If.inflate(CM(t))) }, TM = function (t, e, n) { for (var r = "", i = 0, s = e - t.length; i < s; i++)r += n; return r + t }; const kM = "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", AM = "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", EM = "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", FM = "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", RM = JSON.parse('"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"'), DM = JSON.parse('"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"'), OM = JSON.parse('"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"'), MM = JSON.parse('"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"'), VM = JSON.parse('"eJyFnVtzG0eShf8KA0+7EfKseJXkN9nj0Vj0yNaNEHZiHkCySWEJsmmAIA1PzH/fRqMr8+TJU9CLQv2dYqMrK/NU9Q349+jH9va2uXsYfT86+8dqOb1u9o72Tw5P9o4PTk72R89Gf2vvHt5Nb5uuwafZbbP87od2frnhq/kc+V7h09vZfI1KB8fN7Prr5jOGRj8/TOezi9d31/Ou1fNue/m32R/N5W+zh4uvo+8fFqvm2ejHr9PF9OKhWXxsNn/50x8Pzd1lc/mhvZ3eDcf1ww/tH6Pv//nd/snLZ98d7L98tv/8+fNnrw6P//Vs9LlrvJjP7prf2uXsYdbejb7/rpNB+PR1dnFz1yyXo++PO37WLJZ9s9Hz5wd/6XbUfci79mF2senIj+39erHpw95/Xfz33v6rl8fPNv++6P99tfn31fP+38P+3xd7ry/b82bv43r50Nwu936+u2gX9+1i+tBc/mVv7/V8vvdhs7fl3odm2SweO7oN4my5N917WEwvm9vp4mavvdr7ZXbXPqzvm+/+3nR/9frN3vTu8n/axd6s++Pl6nw5u5xNF7Nm+ZfucH/qPuZydnf98eJr08e/P4qPD92fTBeXRe0a/ji9//swJCcvTp6NvpSto5P9Z6PXy4tNqBed+PLw2eivjW13QX7xbPTx4fLv467tUf/fs+6/+4evtgP2j+ZhMbvoIvrPf4/GX0bfH2wi+647kuX9tAvkf55t8eHh4RY3f1zMp7fGj4+Pt/z3VduF6nzuyvNhR3er2/PNSF3fZe2ync+nC+N9NvTCfbO42CR5UV6Wz5/edtKyi08+tP4Q+jHP2v100dzNm6uaFP/Mjm+63OxxeePKi3KA89XSqAXtoqvNaf6Ir+v7r81dbt51ZdZ6Tw5evBxiP58uv+aj+bNZtJm2d02GD0+i5cPXRSPaXrWrhaCzR9F2OftDwOaxEYPb6Jjeze5EXl208/Yu42VzO4uSjcB8YwSJNr+vpvOMrxdNV8qim7+vmmVvNkV5dVjG3o/9xcHBlr02dHLyYot+yK1+zOiv+Q9/crS/v0V/8z8sqfAmo797mDon69HPuWNv8x+e5oP4xfu9cYcN+kc++nd5X7/mo/8tt3qf9/UBvONkiz7m4/qU//BzRmfCOca52ZeMJvkj/zdn33k3n900D8E3rEjPOy0WKv8dmcrL/WIqF7PZxWxxsbrNw7ba+Paym3xEjfQGFw7GjSpH9dzQURnai9zqMrcSn3yVP/E67+trDtIs7+v/8h/e5D/0Gjbrv81/KFynza3uM/o9d9vNwcpqmY/+Ie9rlQ/iMWfcU24lrHSdj+tPP4hXR55fMREODp6XrFxU2lM2HjyHbHyYzS+rk/1l+yTiHKZnnwoe+qWaJ8d+Ka+rzdoQjdb7rCaPq3m7mAm+bCp7uVgtunn8Yp1TqS+b5axfuwr/365bdFldr2adcts+6KXDRu53/A2ZQl8S52ommFhBdWs5uR64nF5fqzlty3ExRiuOzdg1i8Zr//io6N0S/noxvQdTK3963p0/NKKXHt7z6XJHhHerlQWYDUDU3e67NfbsfjlbCqnr68PXdhUWi2neD8ntI7eYPop6mF6sHtTapffyq3nzR9YqlXU7vVio9c75olEffNk+TC9Cxbk060YSA2DKAuvQD7a57EKqFqmru+vpYnU7n67Ex7TX3TrzRuxuiv2AcbkNOevCa1/3HJpnLy6vuoVeWBn6EiVOsr4Cidw/4Vf4hEP/hNvO6VZz/Ajz5qkzc43LTdEvl7OszCvL85YOtOy9hbQvZd7VZ3dW3OU9jJst5tKQ+tQcM9Cn/5g3PjXJQfXdxdHz1VE6AltIX84eZ5cihJN4ZL5iFsXhh135o8+7/mhNVWiTdX/yRWUCXc279M8LpeI4h8GOnOrB/4ZGyEaC/sBPA9KH+ElD5xFwFhLPMqmjL45eFHG48CE+ilzH14UxD7yXOi7v1AF4edRyNJqqL/Vld+xcqra3aKwQzmyVniGhm8DJE335Gj/9qCyo5u2fzd21yNwPVFF2Gqc66cmxs0h2Ze7r2pAu4oHAUFNf/fwnR85O7T59bReiV7/Sp3sYKlXwMfKTF0P7y4oRfaYP8IjFyS1c4Viu+lXOQhxvTEGPYo2TrRYTvF3NH2b387U4LuqgJ3kcjpJI3XrrYTadX86uxCnWum4N7+LneMKKZPHa2JlmO2adunRRGei7mg3WMuZdpTZ/ph3h9bduxYAX4ewUaNHeNHd4ImTmuGiuZ8u49PUSpbWXT8e5LuxsZNVVdTgf8WDHnPLCrBhaS5Hxuqyk1P+SaR+9KmvX/lJXvBBmcf7pQaxQfqwa4FxOqvvDaD5UTKapzo414XVt+bAjKysB/rNWGvzZ5gq1EalNPbx4t3mk9sm5ju2zdy5LaMbcL+uCZv4gLvg8BJN2T3xqdzhiXuKU3d2uRE/iEXmo5DrTa4FC71ef4grnxTH6eJfAiy6RxaF9TCcxNjFX5t9Tlcd+ihEHzk8l7MaOMsX6QuNnOn80XqvxX+iwSxy6qH2dzmFqKEW+OTWhS902FsrlzZfjsslT7RsDSOsgCwLPz3beHs0UOzQMqxrVqZzrP8oFomWwPsWxayGdTaibHm1lyv+xchAryvwyEF2CzC6U0f614o2Lncvdd3F8/HAr4/Zhd17v/KzXlX2+rpp0PB2wEYj7cSMWE6cvRSrTfc0pbuQC2hZkYSXge9tZCnQIdsVm5yfN2+vNeN+14mJVWzfTVZZKBnW7qlTytTwSu8ICM7nHvJK+d2pXfv3lLi+a3fNrNf7TanM78l/PRqfN4u636WyxuYv8z9Hrze3q0bPvjo//9WzY2rpHQNvjjGgwdYRv4tbWVQLCjqHwa7d15FvlEABBcgRuQxXotv4DCs4TlCFkgW2vDgW0LRxE78PWp27rlW+VmCEKvXfh8yYWz23LBsBR6D1w6D3Q0ntA1HtQrPfAhroOrLcTJGfd1r53f7zZPDR1stl87pulU8jg6AHfd5sHtlt4TuDZdy+OCl6FQ1nlkK0qIVvJkK1yyFbVkK1EyFYiZKsUssfY06dNFtjWOnRwXboECA59oEMjLGFDVMfGqZidc0UX5Y1AVNvGZYEXFarcEJW6cVXvJuaiN4kq37guf5PZA0wgIzBOblD4+4zAFwyROThXDlFUsAlDlPjGVfabmEvAJKoD47oYTOaKMIHLwoRYGwWjpxSGxlIYuosxthgThM8UDcymIOU4RVvlQ2bvMb5rCIQLmVQZgoofmVwbguRMJugheBRRAqMqaJ2Dw5ZlPPvWYB/oW4bIt4yTbzln3yrKG4HIt4xL3yoq+JYh8i3jyrdMzL5lEvmWce1bJrNvmUC+ZZx8q/D3GYFvGSLfcq58q6jgW4aoaIyrojExF41JVDTGddGYzEVjAheNCbFoCkbfKgx9qzD0LWPsWyYI3yoa+FZByreKtsqHzL5lfNcQCN8yqTIEFd8yuTYEybdM0EPwKKIEvlXQOgeHfct49i2MDZpX5ORgUSQbI5G9LMhvapxcLYrS2kIT8LfIyeSiqJwutsh2F3XyvChq44tt2P2iShYYRfLBIL6vcHDEyMkWSVTeGJqAQUZOJRpFVaexRS7WqFPFRlGXbWzDtRtVLuCoxioOGrppENBSg4C+GgU216gKhw0NwGYDV14bGqwqXWPXjeI3h1T4b9R3DWnFiWObnUOaPDmqO4b0sRZhsOjA15XAsllHMTu2E/RrpOTWKJFXB4mdGsQ3mpJLoyQ9GhqAQyMlf0ZJuTPq2ZtRJWdGSfsytmBXRo08GSVyZJDeSwpujJS8OEjKiaEB+DBSKlmUVMGinssVVSpWlHSpYgsuVNS4TFGLRQoKui5g9FzA6LiI2W9RE24LMngtUOW0IK9kV9hlUfrGkAmHRbU+ZBV3xRY7hiw5K2rVIXvUkQRPBbqWAWQ/RSm76dB9tFJD5KPGyUSds4MW5Y1A5J3GpXEWFVzTEFmmceWXJmazNImc0ri2SZPZI00ggzRO7lj4+4zAFw2RKTpXjlhUsENDVFjGVVWZmEvKJKon47qYTOZKMoHLyIRYQwWj5xWGhlcYup0xtjoThM8VDUyuIOVwRVvlQ2ZvM75rCISrmVQZgoqfmVwbguRkJugheBRRAgMraJ2Dw9ZlPPtWOVg0LmfkXC6QdYHA3mXSG8XIvVyQ9mUy+JczMjAXlIO5mi3MNfIwF7SJuc4u5grZmAvkYya8FwyczBlZGQjKy0wGM3NGpeSCqiVXczG5RtXkgi4n17meXOGCciVWlHF0NYNoawbR1xyysbkinM1EsDZjyttMXIlDZ3dzYeeQCH9zrTYkFYdzvTokyeNcqQzJo4oY2JyxtQgUG50L2enKkaHTOSOnc4GcDgR2OpPeKEZO54J0OpPB6ZyR07mgnM7V7HSukdO5oJ3OdXY6V8jpXCCnM+G9YOB0zsjpQFBOZzI4nTMqKxdUWbmay8o1KisXdFm5zmXlCpeVK7GsjKPTGUSnM4hO55CdzhXhdCaC0xlTTmfiShw6O50LO4dEOJ1rtSGpOJ3r1SFJTudKZUgeVcTA6YxtnO6QAmVOlwTo9qAthi9bcTsphFyuYPI4w+xwg/AmE3K3gqW3DSI4WyHkawUrVyta9rSikKMVrP2sqOxmhZOXFUxONuD3iYCLFUIeZlg52CCCfxVCpVKwKpSi5TIpChVJwbpEisoFUjiXR+GxOAaKbjUg9KoBoVMVxD5VuHCpQQKPGohyqEFapUNldyp4R8iFMxVFh7ziSkWthDw5UuEy5I85MuBFA1mngPCKq+C83hpqA23IEPmQcTIi5+xERXkjEHmRcWlGRQU3MkR2ZFz5kYnZkEwiRzKuLclk9iQTyJSMkysV/j4j8CVDZEzOlTMVFazJEBWKcVUpJuZSMYlqxbguFpO5WkzgcjEh1kvB6FGFoUkVhi5ljG3KBOFTRQOjKkg5VdFW+ZDZq4zvGgLhViZVhqDiVybXhiA5lgl6CB5FlMC0Clrn4LBtGU++9UNHX2/WUs9ty5ZejorHAAoxBY7rM6clkoAsSsAsQMCG2AApBe/ocx8p2/L0MxQOF3hISKPlcAHRmINiHQFmHQE2dGRL/lrifmxbFndHFndHMe7OMe5OLe6OPO7OPO7OStydWNwNbUziyPozDluTuGWziyOcO4wO367XecEWDf6MwTJEETNOYTOuYmdiDqBJFEXjHEoTOJ4mxKAapsgWDuEtaJzRRCCKtvEc8iKluPfveMa4F8RxL5zjXriMexFF3IvEcS88xb0IKe5FoLgXzHEfOMZ9QOOMJgJx3AsXcR8kivvfhpC/8q2yT0Al0IBCjIHDJwMtkQVkQQVm8QQ2hBJIiaKjqc3l/VbpAaDSA0ChB8ChB0BLDwBZD4BZD4ANPQBSeuBo+52gXZ8OCol6k/vUlKUkIt2nRvYJXk4OOHe1EV1tRFfbuJWPua0cYCsPsM1H0tK8CIo4xras4QHl2FtJ7G/nyrdhjfI2r1He5jXK28oa5a1co7zNa5S3Yo3yVqxR3qY1ytu8Rnk71MT+sW3ZGsVR6QGguGxxjssWp7ZsceSLE2e+OHFWFidOSg8c0VbugVUAIt2DRvYgVADg3LFGdKwRHWvjVj7mtnKArTzANh8JVwAo4hitAgDlSNOksEGr0GCVO7KqdGQlO7LKHeHTGlBER1Yi2KuQRaej7XWGbQn0W7FseyRqtOepRnsaa7RHdNSgUPX2rIQfUCzV02D1p9nqT7PVn1as/lRa/am2+tNs9afC6k+F1Z8Gqz/NVn9asfpTafWn2epPq1Z/Kqz+NFv9abb605DVpzmrTytZfSqz+jRn9Wk1q09FVp+KrD6VWb054z7yrXjhrEfpslj4KpNQFyRQiZCqqoWa5MKhBlRDpOpyokZcWSRTkZFK9RZVSA8SKKNJpYJkVaQ+NclVwA1yxVILKhlSuUZI5pKOclsVdoZF1jw1+VbH2QlI1aZAjXb3na2CVHKNqIKBkEBeQqqyFWqSHYYakNmQqn2HGrEFkcxuRHI0piiCR5FAdkVqcq5fRsOF8wPbsmvmgOLlchPOwtY4bE3ilp3nOsKTV6Pxy4fLGsmUgoeTh1+GWBxbZywAgPAi8JaGt/YPIqL+197aj+pZRuOMJgJRYNTr7CRVQiTfbC9xwhe6KQYcMfVC9yDFbILgkUAhZFUFMrY5qwnjmjCpChRgUnOYY4NKsEUjDnmuWBlFDn+9YocGg59i+A1R4J2rkBf1LKNxRhOBKLTGc1CLVAlnkDmQRVznGHDwjKewvRttLzNsP7DfssnVkV24chQnWec4szq16dSRT4/OfD3grFy4cmJz4xaVwnwtEPXFOHXIuOqViblrJlH/jHMnTeCemhC7a5j6jDcIGFGf0w0C5qrP6gYBS9TnfIOABe4z3yBgzH0ODvC6KnD/o8pRiKqMRWwiIhIbcFyimqIT5RSjKFOkokjxKvc/XwtEMTJO0TGu4mJijohJFAvjHAUTuP8mxJ4bjn3+dejukW/FmxO/YicBxcc9nKdbGL9irwD5AxzOrC/Ahm4AsSc5DH2KW2XyQhTmLRc2U9axbY3D1pfQchI0m7EApUcEfkWjPSJEYU5Gy1wFXBktSxT6bLQs8CCw0TKm4cAVMSMamMqKmNSzHM9xRl/yH05yKx42tUgepPCmOAxg5DSKUaShjKIaz9giD2rUaWSjyMMbVR7jqMaBjhqNdvrCC8lp3Hd94YVqclYZlXGFf6nsZ1Jpz1lR/dKHQYeXXiExkFJaoERJgZJKCdRzQqBK6YASJwNqnAqoxURAhdKA3rMXlFKg/p59bnAmIz+W9Ivcw0S25WGvvHs+qOV1QRhxQzTcxmmsjauBNjGPskk0xMZ5fE3gwTUhjqxhGlZ8R5gRDWjlHWFSz3I8xxl9yX84ya14+NT7tIMUL7LhELJCI8kyDSjLaly5TR5ebkGjzDIPNus85qzHoWeVMoDkT3WF8iHJKi2o0Vl1xMZV5Ut1b5Pq33DmsJwTyF6hg9RxRknjAqWLCypRXM0p4holhwucFq5wQrgSU8E5JUF4wzYxGvjaG7Ysn4nojgX7Iv52ItrxoMq3UAetXN2B0TREg2mcxtK4GkoT80iaRANpnMfRBB5GE+IoGqZBxKt9jGgIK1f7SD3L8Rxn9CX/4SS34sFTFwAHCU/SjwjR2KWTdOZq7NRJOks0dvkknQUeOz5JZ0xjh28mMKKxq7yZQOpZjuc4oy/5Dye5FY+deop/K/02DNv2mfLfcMQAlcECFMYJeHpO/TccHUA2MMBsTIANwwGkjISj/gkt648/oeXIntByJB4s73l6sLyn8cHyHtHj4z2jx8d7Fh4f74k9N2QoPrW4IX5BqN+KF7t6ZHfOAeVLXD1PV7e2FG+MO47Xu3pEl7p6Rle5NqyNW/mY28oBtvIA23wk6a61K+IY/f60o3ixbYP4qcX3I3wvod+KGdUjkT49T+nT05g+PZLvJfQKJVbPKLF6FhLr/Sg9ffZhhM+r9FvxIZUeiSdTep4eR+lpfAalR/LBk16hp016Fh8x6VF8ruRDcNUP2VA/1Lz0wzBwvp/Pub+fK/39LPv7OfeXBw4U0d/P9NTpBxg4J735H5etje8f2tYkbsVH+D+Qqw+0XESD0TdEITGu4mJiDo5JFCHjOkwmc6xMoAQxTlmSL2o6onzZeVHT1M9535w+xnfFSiSSSZVYVVLK5FqsUnKZEDMsXLeNGTLOSTMRiLJOXaQdpHLnC1LPEIXTuAqniTmcJlE4jetwmszhNIFSzzilXuGQeoYo9Zyr1Cvq57xvTj3ju2IlUs+kSqwqqWdyLVYp9UyIqYdvRB3HDBnnpJkIRKmn3ogqUuVJTRY4tN98UpObiDDvelKT1UrIdz6pyTKn6q4nNUnFtNXP9lRUmcKhzefaZ6Z0juq3Y65SOzbYGfNamsdGu2OeUz7KlPjpoadjlaXjWvpOqgIXRPWhp22DbrjhxbR+y57tcRRfTOuReDGt5+nFtJ7GF9N6RC+m9YxeTOtZeDGtJ/HFtE9DNe+/tC1bkDuKC3LnuCB3agtyR7wgd8UX5M7sdRBHdlpnyE/p+q34TFWP7EsgHMWX3p3jybtTe9Xdkb/G7szj7qzE3Unpgf/hRTuHs/Qt2Z6qOoldanIv7VQVUcgu57KX4VQVGufON6Lzjej81/X91yYe0iwM3Syn2MxPwoy1YRdt7ntb6Sie8gK1MnJEeQmKF5izkpeArJoM2YmiF9giDOkiXgXqURlERGFKcGHZ3M5y5qzCMaxyrFaVWK1krFY5VvzsNigiViuRF6tUFE+hD/6dV/2WebGj9D1XZVpFF04PujEnP9YPurGYnTk96MacPTo/6MZCdOv0oBtx8O10GsBcObg6DWCJvLx2GsAyu3o6DWBO/l44mLwhym3jZPfGleebmC3RJDJA4+yCJnDKmxDz3jDNCIVTcTsOc0PBIhI8SxinqcK5sAYT6xFSM4dpleilOcSEWvR4Nil8lrOF5xXjPLkUoc275WnG+K4giQnHJHJS49pOTWZPNYEmIeM0ExXO01Hhi5xKPDEZp9nJuZqiiirmqSKt8mHyjGV8V9jF3GVSJeyVWczkWtjTfGaCLu6n3GuY3gzRHGdcTHTp6eYyoPrpZq3y1Lfj6WbdREyD+ulmraYpsfJ0s5ZpetRPN0sVp0p9wUKrctqsXrDQDXgK3XnBQjdK06m+YKFVnlqDihNsFLggo8qTbVTllBubiGklNuAJJKppGolyqtYoU81GkafloLKjkRin6Pgya+0D03QdVZ60SVX2GJt8K9JyGo8tdo5FntKjvHss0vQe1Fktb9NUH9U04Qe5rX1cmvyj+u1gq4VAbMDzUlQrs1NslOaoKPMCIaq8TAhqWiwEdVFL7bRwiCovH0iVi4jQRi0lQoNVrUNpWRHVbw+oWmLEBjsHtLbciI12D2heekR5l5k91SKGi5Eo8JIkqmlh8nlYjZw8t62yB0BlugAUYg8cPgFoiTIgixowCxWwIT5ASg04Ks59bMRKYUD4cssJIepwermFueq6ermFJQpCfrmFBQ4Hv9zCmAJTOEWnYA5ReofkRHEKln6HRIoqbNV3SKROAay8QyJVDqV8h0RqFNQgUmSDxuGl9zBOMqXQqvcwhKTCWnkPQ6gUUvkehtA4nOI9DKFQKEGiQILCYcQ3G04IUQDTmw3MVejUmw0sUdDymw0scLj4zQbGFKjCKUoFc4jECwQnWqGA1V4gqMgqfDteIKi0oGBWXyCo6BzaygsEFZUCTTLFm1QOe3js/oQZhTo/dp8EFV752H3SKKTisfukcBjTY/eJU+hMoKAZ53DZz19AuJxRuFygcLmgwuVqDpdrFC4XOFyucLhcieFyTuEygcLlv8NC4Rq+pR+CVQiFqmAKVMEqTEXLQSoKhahgDlDhHJ7CY3AKpdAMmAJTfvohhuVsCMn+9ob+GcYDmT3kDCxeHAIBLwkBtgtBwPzKDkA/ewVYnkgFZFd2nG1+DOHQema/gwAonm+54L9+0G/ZywWOxG8e9Dx9O1JP4y8d9Ej+yEGv0O8b9Cz+tEGP4q8abJBfv+q34ulej+ySpyNx2tfzdK7X03iC1yM6YesZnaX1LJya9SSefp+N/IoSkm3i7h+8Kqgf5ec2Vv41o8DKaXZg8UlqF8Kj1IDxq0aB+zPWzuBRaofwLLVBu8SzPRPdoM11ncMXtmXnnI7iY0vO8QTUqT2g5MgfOHLmTxkZa+OxtiKybS2KrY5iK6KVvhAVJBVI/0pUYP5ugzF/wN5rAi+XeFat4lauFHU1pOeyLFa5LPTFjl4RBcOXNXoWCmZcvHn7yP04eDMw82ZgcchAwCEDbEMGzMcFoCc4wOLNgGysnPU3IXwrvvgwTg4LPL34MEaHBSRffBgHhwXmOWYovj4zHhz25Ni2bLHgyBYKjuIiwTkuEJza4sCRLwyc+aLAWVkQOLHFgKFSC8dA8JWg8WCw/hdN7qXZKyLdy0b2Mngr4Nz5RnS+EZ03X9262XiE18vHo3SRfDzKV8bHgwW+sL2aAwKKb6Q5xzfSnNobaY4oL0Hxd9WclbwEZC+mGfJr1TaIaHw+2P6jOGM0PkDip3DGZHxA4w/gjIXxgUI/ezMOxgcs/NjNhmwu0J74Vlyj9ygttifFL/d90zIAmPklsOg8IKD1ADbvAeYWA9DzDWDxS0BmPM76p8yPbSs+mztJfgk8Pag7Qb8ExI8uu0I/pzFBvwQUfyxjMvjlS98qRw2oxB9Q6Ahw6AjQ0hFAdrjALPTAhsgDKT1wFNcOk+SXk8Ev9/f3bdPzzJktSJHFPHMBrQQorkehtVmMIzcSZ5B8BumG42SEq9HJKK1GJ6O8cJwMrgm7bUUE2lpvw8IRsFeVM57SQYKCc2iTOjAvLmNkn5ORWjdORrhunIzSunGS7BN4WjdORmndOBH2CQqtGyejvG6cjHjdOLH7GeAn6WZNEtgW9e2apAqDTDdskpCsMt+ySQqZZrppwwLYZ35BkbgyUvmCIklkqdUXFElmc80vKBInmy0cvNYQGa5xcl3jynpNzP5rEpmwcXZiE9iOTYiebJiM2W/GhQrle3SEseqNsVWZwI7tgjIyU7N3uyQM3ERyceNs5SYkPy8Km3rh4OyGyN6Ns8cXoRWfl9zehJ2RUr5vGpu/CZUZwPQ0DZjCc4EJPCGkW7oURzE1FGklEE0SxtVMYWKeLkyiOcO4njhM5tnDBJ5CTIjzCN1xLQarbrkqjSeU6k1X1UBMK+q2q9LS5CJvvCqRphh161VoMNEgpbkGJTXdoJ5nHFRp0kFJzzvYgqce1Gj2QYkmIJBgDkJK0xBKNBOhpCYj1PN8hCpNSSjxrIQaT0yoxbkJFZqewr34YBTiLn1W0IwQs8+ixrNV0JQNY4M8ZwVVTFuo08yFEk9eqKX5C0SewkCCWQwpTWQo8VwGWqs/Ps1oqH0rmmpeQ5mnNtQqsxs2SRMcijzHocbTnHosJIdbTHagrjSlKQ8lNeuhnic+VGnuQ0lPf9iCZ0DUeBJELcyDXcX2P7u8/a2Z4myIBkdDFB5lAg6fArQ8iQLI7vsDs5vbwOC37AeCPxW9Refd1vmoXNU+x+E/MrQZ2APfKgMKSHzD0jkNIND4DUvnYsBAoW9YOg8DBCx8zfn50Mntb90M5pp+K+Ioq0XaXiTtwtA/KLrdzeXF8COsjprwOQ0mwIDKiyuIOAEGTglQqBsuYsyLAYW8GFjIiy27gunGSfcx82a5nNlMfjXY64FttXHL0sCR+P2oKzJBoPGXoq6E5YFCvwl1hQYHKP760xXms/eV8mB7afmKUmCbAdd5D9elpplXnhjfquX3RmDL5hVHOFv0dFaGrj/GWUiwLcrZtOWcTVsa0maLYtpsWUybnt2UtYhvxft0N2HlASjfuruhdQbScJ/dcLyjdxOWE8DoC8tuyqx+bFsx6Dd5DneeBuMmzNiO5G933cT52Vn8Sc+bMBsbWsetfNQ5VW7yWzVDFCpv1WiVRnDXWzW6SR7XHW/V6BY02rW3arTMOZDfcJHx4szY9YaLbvKtEeHU2f2Gi27ECVV5w0WrlGb5vQct7AxMzsNiJdv1wx1a1oBwTiwo7BQEXLJsURtsqS3z8XYrG6QhaFXxzMihvfRSpNA2O6whaEUPvD5WFfgbYdTOoF350tzHjKAVBpaQtyqTWFo6bWfHKEet/MW8uSqPSm/3yUK0I1bjd6iyKuyImyQ74gbRbFgls2GZzIbl8GWZLMYnSnpVB2tHpHaE6Vsx2h2gHdHZFZpdcakH5dsRgf9/d3Jo6pByI//60YiHFbvSQsqKXS70ny3i2U/UytwptfB0qWjhD+5FHC9mRK18oNS6mXg+n9bU+LCraHE/vegv5Bwl6dE60AVpdLEZsJe2FZ+s6ZEtKQDZwQEM18AWZQ1jepN33eRd0xLFOeY5UFyMOI6vpi/issMZPTO0YZ7a/VYszB7F0LtATy1tkM/0/VaciXtkAQAU9+9CnP8XZTVkh97mALeVaLYymm0OW1rWuCIC2sYX9hdh1WLoPoTNT7SeG/s9tPcprlQvJq0h6r1xyjHnnMP6jqNhsW9O6Xy/kbkYDnW3MUk5zdPNRuY8PuJmYxSuc5w5/43LIkg3LYdKKBwS3RDVhHEqDOeqOkylEgl3OmNnuVgq9zlJrA8R1071JifJtVHiUsp3OCO/z8OQKqsIv+c/hxqz72XyVoYoaMYp351zjfGXPg01hl/6RC25xtKXPiUuBlB96VOSco2lL31izqOXv/SJhOscZ64x47LG0rdHDTVWONSMIaox41RjzlWNmUo1hl85RZ3lGtNfOcVifYi4xmpfOcVybZS4xtJXThG/z8OQaqwIv+c/xxqLX68CbaPAAYwqVwCpqfbkd7qUCsxXn9RfpWqsXH3Sqhr2+tUn3UBUaeXqk1RTLtSuPin5ujaCqYajqitZf11MqeegYpVGgWs7qlzhpMo6j2242vPVOBWoVPm7rsbJJt9KhOQFu6/GyUa7cyG5Q+VqnFLva8Oc/SLIv9d26N4xnNj1Fxm2l2qMlKATtq+0iji+HBA1fEEgKvaSQMT+OkDk/kpA5OW1gEjtG6oC/jQqr3MasRNnwuIV0CJuvk37KOx3nNpM0mdPdEwnKUDdAMFPCvVb8XpPj6JN9Ehc3+l5uq7T03g9p0d0HadndP2mZ+G6TU/i9ZpHmBS8T1Fvcp/ojsNjNnrnsk/ihsJj8HFHoqt8v+Cx2JJv5WPmFx+NywNs85Hktx5NEcfYxvfRHoN9GDJreNGjpzQcT6FrT7lrT5WuPcmuPeWuPVW79iS69pS79pS79pS7tk5dW4dMW+dMW+dMW1cybS0zba0zbZ0zbS0ybS0ybT3Ce+prHA5A4p76moYDaLynvhbDAQrdU1/jcACK99TXYjj4wscwJuHCR2zJo5MvfDAX4yQvfLCURyxf+CDOYycufEQBRjFdHmCuxlNdHmCJRrZ2eYBlHuN0eYA5jXa6FjAMuXh2cRh1fnYxteexl08uCklkQOW5RaXmPFCPLQqJs0E/tpg0yAn1MKGQVGZUHiUUKuXHjgcJRQvOEvUYoZAoV9RDhF26/Os//w8s8zdF"'), NM = JSON.parse('"eJyFnV9TG0myxb8K0U/3RjC7NgZj5o0ZZnYGz5pZGyH3bsyDEA3oImhWfxCajf3ut1Xqyjx5Mkt+cbh/p9RdlZV1qrrVJf5T/dg+PjZPi+r76urvy/nortk7PPpwfLh39P7DyUm1X/3cPi0+jR6brsDl5LGZf/dDO735dTGaTsYbdTmdorq3UfdUHj1Opmss0MFhM7m731xwU7Y73pY+fbqbdqW+e3vUkfnPk9fm5vfJYnxffb+YLZv96sf70Ww0XjSzL83msz+9Lpqnm+bmc/s4euqr+cMP7Wv1/b++O3jzZv+7g7cf9k9O3u+fHLz9Y78adGVn08lT83s7nywm7dPmSl0xFS7vJ+OHp2Y+r74/6vhVM5unYtWbNwd/efPmTXeNT+1iMt605Mf2eT3bNGLvf8b/u/f25MPR/ubf4/Tvyebfkzfp33fp3+O905v2utn7sp4vmsf53q9P43b23M5Gi+bmL3t7p9Pp3ufN2eZ7n5t5M3vp6DaYk/neaG8xG900j6PZw157u/fb5KldrJ+b735puk+d/m1v9HTz13a2N+k+PF9ezyc3k9Fs0sz/0lX3p+4yN5Onuy/j+yZ1QKrFl0X3kdHsJqtdwR9Hz7/0ffL+/cl+9TUfHb4/2K9O5+NNpGed+OHdfnXWyHEX4+P96svi5pdhV/Yg/feq++/bg7fb/vp7s5hNxl1E//Wfavi1+v5gE9lPXU3mz6MukP/d3+J3XcwSbl7H09Gj8KOjoy3/97LtQnU9VeVNf6Kn5eP1pqfunrx2006no5nwD+/ebflzMxtvMj4Lx8cftsLosZPmXXi0ZvkzqQapy732PJo1T9PmtiTZj0n1RvPNGecPqhz3yvN0ORcqMRt3A3XkL3G/fr5vnnzxrimTVltykBs5n47m9742fzaz1tP2qfFwsQpKLu5nTVD2tl3OAjp5CcrOJ68BbF6aoG+bOKZPE6iwhGjcTtsnj+fN48RK0gPTjQ842vx7OZp6fDdrupEcNPPfy2aevEZT8KDve637+/fHW3bq0Q8e/ahpe9Cf7MyX+smjn/0H/+aHwC9+UP7qG3buT/9R0du3W/Sbtjuf6+++Ep88uvDn+t2X+oevxGewjvdb9MWf69Kfa+DPdeVrP/SlvvrT1x790yffdTeZPTQLYxsyRq87zY5T/hx5yrF4yngyGU9m4+Wj77XlxrXn3dQTDJHkb6Yy6lMeXQs6PDzsx1jgv75UcOVb/8E73433PkgTj/7Pn+vBl9IhLGn/6K8YmE5ge8/BqPdDaObR3Ndr4Sux9CF88Um48pV49R9c+0r8qejwg+aXTYSDg9zrMJna8ruycTGZ3hSn+pt2FcTZzM46EyzSQk2T421u/+1mYYg+K59ZR3PH7bSdTQI+bwpnGS9n3TQ+XvsuS8NmPklL18D+t6uWeFjdLSed8tgu4pXDRk4n/oZMoc+JczsJWLB+6lZy4XLgZnR3F01pW45LMVpwbPqumTU3/qPdWmh0Nxs9g6nlj153dxFN0EoN7/VoviPCu9XC+ks6wOrdXUGOzXQ6eZ5P5oHUtXVx3y7NWtFN+ya5tedmo5fABkfj5SJauiQvv502r16jkZXx42g8i5Y717MmuvBNuxiNzYhTadL1JAZAlBmOQ61sc9OFNFqjLp/uRrPl43S0DC7T3nXLzIfgdCNsB/TLo8nZk2xwp7rqOXjf53w7u7ntlnlmXagLFDvH6vrDcrnAhV7gncwJs5vHzueWU7yCnGmkTDzjZjPk5/Ng+poW1uZtoZ5tkPTd6OxuiLush16TlZzrUJ2Ybf7p5G+zRiemsEv1dLbvdG3kaiCTxc3kZXITdFJta6bL5WBoaLXth3SdF3xIJ0gagzJVpzsvGiTQVH9KvZ4ZKIp9GKTmNBr0M9RD0hP0Ab0HcBfRO4bOIeAWxN5iUkOPD4+z2D/0CC5FnqOrQpsH2so4Lp+iCujwKOWotVRd50dn0xup0tmsrUI4vVFqhphmAidH1MWrvfrhSR+waftn83QXXP6zvYTew0WN1OTYOUgCUYcXTyOylrUVga6mturdj4+c9tF9OwtadUFX1zAURsEXcok32WwLYRvQBTRidmozjzfmy7TGmQX1pRSUKJY42Wo2wcfldDF5nq6DelEDNcltd+RE6lZbi8loejO5vfV9tS5bwyd7HU3YXcny08402zHrlKVxoaOfSjZIHQqeEo/NX+lE+PCtWzDgEzi5AZq1D80T3gaJOc6au8ncLnx1iNLKS6djPy7kXmTZjWpzN6LBphWkDMyCobU8lmRcFlLqn2Tahyd55Zqec9mnYNLKnxb3vq4/Fg1wGvnWu7xsWxRMpinOjqVZ8LS0fNiRlYUA/1kaGqVKXZR6pDT1lDx3XrpyeRxf7FyW8IyZ1wXNdBE87lkYk1ZPXLU7HDFY6b3PJhe0xNZIQxWuM3UsUOj1PtWucI6P0Me7BJ51iQxVk2nE3cJ8OMj5OgonpI/hIkPuMGzH6T2MfKkTmWJ5ofFrITV/LY3x32j+y3HoonY/msKztzzIN7cm9Jxb+iJyefFlu2zSVPtGB9I6SILA87Pc31gzxQb13Rr16iic67+E613J4PgWRzKss4noG4+2MOX/WKjEkjL/UOz8ZjKOjPasMKHNdrbmk+0frW5huft5d17vXFqfFs55WjTp+HbgovDs8M9g4tSlSGG6LznFQ9iUN9mrzEpAz7ZzKNgq6PPdnVeatneb/n5qg0dVrTdTSR8v5QzqTlUYyXfhTYM8X4GZXGNeSN+ncB6H7w/dFKGeXxrjPy0330X+sV99bGZPv48ms803yP+qTjdfVVf7370/+mO/P9q6h0HbelrUmzrCv22O3sjR1lUMwoahcNEdHelRrgIgSA7DpasM3Y5/g4zzGKUPmWHbp0MGbQcOon9sjqT1l/YoxwyRab0KA3PWgW/9oND6Qdj6gW/9oNj6QdD6vPAzLNkJkqvu6ETaMOyOuqk4H9bd4bEe5SYBgqorhVcCOnyY8bI7eieFlvlsgEyAgMNVgOYAAaIAgSIBAiYBAtYHSMmLacPKHK3tkcRHEcZnS/tCOF4F0aAVTiNXOQ/frMAYFkQDWXg4mrMKQ1oQZbbwKL1F9DkuEiW68DjbReaUF4FGvXAa+pnD+M/oMkDkBMojO8jqwF+OjUH4rvAFFiFSIXwFsxC5FD5nGyJY78gYDCQjdJHMwEoEkZ8I96aSpchZsgb2Iog8RnhkNCJ6txGJLEd47Dsis/mIwA4kgrWhjF98q1cerQNE1iTc+1NvE+hPgsifhJM/KWd/ygr4kyDyJ+GhP2UV/EkQDTDh0QAT0Q8wkWiACY8HmMg8wEQgfxJO/pQ5+FNGlwEif1Ie+VNWB/5y7E/Cd4Uv8CeRCuEr+JPIpfA5fxLB+lPG4E8ZoT9lBv4kiPxJuPenLEX+lDXwJ0HkT8IjfxLR+5NI5E/CY38Smf1JBPYnEaw/ZfziW73yaB0g8ifh3p8wNGhSlpNTWZHsikT2LCODcVlO7mXF0MJMEfAxy2k0WjEakraEH5dWp8FpxXiE2jI8TK1KVmdF8jsjgukZflniZH8kRh5oigwK9WA3tOI34x/4otV3xb/gkLbMzvg7r7SqNUyjgWsajtZpBPBPy8lEreid1OiRnZoC4KmWk7FaMXJXW8JbrNXJZ60Ym60tw45rVbZdq1rvNdpLIU6rAl+XOPmxFb0pK0FLRkqGjBLZsZHYjEEEK0ZKRoxSaMNQAEwYKVkASpEBoO6HP6o0+FGKhz6W4IGPGtkuSmS6IIHlAr2MKdmtkSKzhQKD8OpstCh9I8qByaJajnLBYLHEjig7c0XNWisoYKxA0VYBg6kiJUtFyRsqqJGdggxmipSsFKXISFH3NooqmShKsYViCTZQ1Ng+UbPmCcpLGJNVSNcxJdNEyVtm33r0S0FklsLJKZWzTWYFPFIQGaTw0B2zCtYoiEas8Gi4iujHqkg0UIXHo1RkHqIikAsKJwvMHPwvo8sAkfMpj2wvqwN/OTY84bvCF1idSIXwFUxO5FL4nL2JYL0tYzC2jNDVMgNLE0R+JtybWZYiJ8sa2Jgg8jDhkYGJ6N1LJLIu4bFvicymJQI7lgjWrjJ+8a1eebQOEFmUcO9Pua5oUMrIoVQgiwKBPUokMCll5FIqhDYlMviUMhppKkRDTVU/1lSjwaZCPNpU5+GmCtmVCuRXIoBhCbuMGFkWCJFniTwIrsmupcLOWAa+pVoplgXnUr0YS+ddqljzEg7uJQztSyD4lzIyMBW8g4kWWZiI4GHKyMRUiFxMVW9jqpGPqRAbmersZKqwlalivUz4S9D+VcDWESM/U8EbWq4YGpoyMjQVyNBAYEMTCQxNGRmaCqGhiQyGpowGoQrRIFTVD0LVaBCqEA9C1XkQqkKGpgIZmghgaMIuI0aGBkJkaCIPgmuyoamwM5aBoalWimXB0FQvxtIZmirW0ISDoQlDQxMIhqaMDE0Fb2iiRYYmIhiaMjI0FSJDU9UbmmpkaCrEhqY6G5oqbGiqWEMT/hK0fxWwjaG9YyYxYQFbvdVm/W+UqANlQmaWMVmZYDayXgAby4RMLOPQwnoRDCwTGnIZRwMua364ZYUGW8bxUMsqD7TMybIyJsPqMdhVTy49IasSHBlVLw7cldikMt4RscCgshJHrGBOWS1EzBlT5taWegqm1BO0pB6BIWVCdpSxN6Neiayol8CIMiEbyjgyoax5C8oKGVDGsf1klc0nc7aezK3x9PTFtXXlyNoTWkFl7NdP/SBAvxFEhiOcHEc5W05WwHMEkekID10nq2A7gmgUCY+GkYh+HIlEA0l4PJJE5qEkArmPcLKfzMF/MroMEDmQ8siCsjrwl2MTEr4rfIENiVQIX8GIRC6Fz1mRCNaLMgYzygjdKDOwI0HkR8K9IWUpcqSsgSUJIk8SHpmSiN6VRCJbEh77kshsTCKwM4lgrSnjF9/qlUfrAJE9CXf+9ENHT7ujgyM5yp8FlL0EkAkpcLgC0BxIQBIkYBIfYH1ogOSBrWiQMlCOcgsAmeoCh+oCzdUFRF0OijQEmDQEWN+QLTkzcT/zcT/zcT8rxP0sjPuZj/tZEPezIO5nLu5nPu5nvRkcSXs2PnAoR7XRamuDZzTue9qbLkZGEIVHOMVIeBQoEX20RKKQCee4icDBE8FGUDCFMfMrHwYIaEa1L8WhFR7EN21itPHNiOObOcc38zC+WQzimyWOb+Yuvllw8c0CxTdjjm/Pr3wYML49qn0pF9/MXXx/7kPbT4Y/Y1iR5ZAiI4NSwTiUYrUoZeBECsGKFIoXKcphAzaSuT4d5aYAyi0BZBoCHNoBNDcDkLQCmDQCWN8GILkJira/cdk16uAkI2pjE3RQkxd/hhU6qIk7CHbdWh50XBN1XBN13EQyNh3lugMy1QQOtQSaKwNI6gJMqqKsldVaOrJru4RMTYC75V6iuSaAaMoFReoILN8GAMr5oKj/EVOTEDMzfmd2tCck9wKA7G1AEs6Ns557Uz33fnpesNLz0EXPvYGeB955HtjmuXPMc2+W5/2gP5T2jGyKneOgBxRk3TkNeqA2687NoAdGWXcOgx5IboEiGfRCrN74NsmIRxS3qQnbZIY7YN/UJmhqEzS1tUe+zm2hgm1YwdbXhAcYKEEdZYAB8rHXASZoaQosfUOWhYYsw4YsfUP4fgyUoCHLINhLk1cfq+2TkHd6ZO8sEwpuKhN395OJ2lvJhMK7yKTQDWRiOfyAcvgV6VD+iIkOKCc6Im8/HynRkUKiA7au9NEkOjBypY99osORr3NbqGAbVrD1NeFEByWooyQ6IGuTH/usPpC4S1YDsrVWjrVWKrVWxLVWRWutTCOrLPu9kLU98rVe+9qZqQ7HBQk0REiNRgsV8QOHCtAYIjUeTlSIRxbJNMhIpfFmVUgPEiijSaUByWqQ+lTEjwIu4EcslaAhQyqPEZJ5SFu5LQo7wxKOeSryrYazE5AamwIV2t12tgpSyTWsuiyNMPYSUiNboSLfGsNsNqTGvkOF2IJIZjci2RqTFddFYWdgvHP9Vm0f7b/9IEdyYwfIrORV2DwveHecj4bmqLZH4nyK0MuEmsfZ268OfusbrIXW/mxrfzbcc9/X2e25dzxqKW5Ip3MPPaoDRPWN9qOTFMUBt2FTcY5ItA27l2xKQHBIoBCxGgXKlrkqXXNYEuqiQM0j9VuNjILpB1T4UQ5seUD1BXq7w8AKopAqj4KZ1St/7qFHdYCo6sLLlY4ClbW1L87BEe6u8Kna3vdvlwXpyK6FEsp3zYCCNVHibiGUqF39JESrmcToO6bEzNdLidilzKc8pE4DRG0RTg0SHrVKRN80kah9wrmRInBLRbDNFUxtxi8bGFGb3ZcNzKM2R182sERt9l82sMBt5i8bGHObzQg/LQrcfqtyFKwaxsIWCSJiC3BcrOqiY2UXIytTpKxI8cpfnJ4GiGIknKIjPIqLiD4iIlEshHMUROD2i2BbLti2+aJv7qEe2Uc2F9hIQMFTnAtqGlD7FOfCNAgYPau5gGYAsc+hLvoZCo7s470LPy+poN8TXfSzkR59NSVro9HXRBdV9A3RBRrtISEKszNa5lHAI6NliULvjZYF7gQ2WsbUHbhWZUQdU1irknrl4zn06Kv/YO1LcbdFy9deMtu5oQMtp160InWlFaP+tCV8p1qdetaK3L1W5T62qu1oq1Fvux+eCDn1+64fnoiKXBV6ZVjgXwvnqQvlOSuKv7/Q67BpFRIDKaUFSpQUKEUpgbpPCFQpHVDiZECNUwE1mwioUBrQZviAUgqUN8P7Aldh5Ich/RqeoQ7LcrcX9oj3at4GCD0uiLpbOPW18KijRfS9LBJ1sXDuXxG4c0WwPSuYuhX3+DKiDi3s8SX1ysdz6NFX/8Hal+Lui7bE9pJ9xoVdyAr1JMvUoSxH/cplfPdyCepllrmzWec+Z912PauUASRflhXKBydHaUGFroo9NiwqX4tnq4uf4cxh2SeQ7JmD1FFGSaMCpYsKUaKo6lNENUoOFTgtVOGEUMWmgnJKArNz1jHq+NLOWZavgugOA/Y1+GwdlONODTeY9lp+ugO9KYg6Uzj1pfCoK0X0PSkSdaRw7kcRuBtFsL0omDoRn+Yxoi4sPM0j9crHc+jRV//B2pfizose8PUS3qQfEqK+czfpzKO+i27SWaK+8zfpLHDf8U06Y+o73LrAiPqusHWB1Csfz6FHX/0Ha1+K+y56038r/d5324cjOcqfBZQ7C5DpJ+BwBaC5dwBJxwCTPgHWdweQ3BOK9JWpdGRzLiGbbgkFmZa4S7JEbX4lRKmVGGVVYiahErG5tEH0nuQGNaaTGtulCdnX4rbIb2pJPOx488U0YLvDJSHavZIYbVzZsM2XzUfSLfINMyBbQeVYQaVSE0W8zUYVraMy2ZukSLYlCeKXEv9R4Y6GdGR3NCQU7GhI3O1oSNTuaEgo3NGQFNrRkBjtaEjM7Gj4XG1fDjnUIzsQEgqyPnGX9YnarE8ofNUrKTQeErPvrCVkk/9z76Hv9CinNSLjnCoMzHkGvr2DQnsHYXsHvr3cS6AE7R3Q+P8MvaRkY/Xb7+E+9y6vR7U9krxThPm1pfmRGfS+IAqJ8CguIvrgiEQREh6HSWSOlQiUIMIpS/AR5jtClC+FR5ikDvy5OX2E74pVkEgiFWJVSCmRS7FyySWCzTB8SksZMvSoDhBlXfRItpfy91yQeoIonMKjcIrowykShVN4HE6ROZwiUOoJp9TLHFJPEKWe8ij1sjrw5+bUE74rVkHqiVSIVSH1RC7FyqWeCDb1cC8VZcjQozpAlHrRXqosudcicyXi1yJjNQxw8bXIuAAHe+drkXEhF/j4tchY5YR17+C8CwVO3l3v4IRlBqVrunS26rdjHqW2LbAz5qU0t4V2x9ynvJUp8d3LSWGWDktCXRR4QBRfTtoW6Lo73dBtV7fpyK7CE8q3Q4CChXnibmGeqF2YJ0TL78T0FkFZ3tauxK7IL/vRrO25sDG4dOMWeBgQGaGAePWtiq6+leUBCEj26wlK2/UO5CjXGpBs11Nkt+spx+16SmW7niLdrqdMt+spy9v1lMh2PUHjdrrd1nWoZHtjqmXsJxrfSrkvRRS30tyXAoX7UigsSadIk05Z0Pj79fN9Y6u02cm3fX0sHdmXzRLS1ziEbe5vTyRL5f4WULD7MnG3+zJRu/syIcpLUGhfZmI5LwHZTZgbJPe32vqZadbMt1723CGyU4II8+Zx4jNnacos/SXoVyGUuxf8EpXXcBTxjgNV9N0cZUF/yu8+CFmZo7U98m3wLyPmaRVd2L3Wxpz8OH6tjUXvzO61Nubs0f61NhasW7vX2oiDb7vbAOaRg0e3ASyRl5duA1hmV3e3AczJ3zMHMxREHiic7F545IYieuMXidxfOE8BIrAVimAnA8E0I2ROg1uxmRsyDk7As4RwmiqU74hQMGmo5GcO0Wj6EM5ziAil6PFskjlMKYLIMoSzGWUBZhhBNM0Ij+YaEf2EIxLNOsLjqUdknn9EoElIOM1EmfN0lPnMR4MnJuE0OymPpqisBvNUlpa+NM9YwqNpS8TyfMATmPB4FhOZpzIRSilEk1rGK4/WASq0Opro3LvMeTaI32WOVZ76drzLHBcJpsH4XeZYdVNi4V3mWKbpMX6XOVRxqowfWMRqOG0WH1jEBXgK3fnAIi7kptP4gUWs8tRqVJxRrMCTiFV5srVqOKHYIsHEawvw9GtVNwlb2U0mVqYJ2Yo8LRuVHY1EO0XbnaNFYWek3aRN6jcjHU3gVCCYxm0Jnsyt6qZ0K+/uCze9GxUneSuwc1rVubXdqgrTpBV48rdquASwRYKFgC3AywGrFhYFtpBbGliZFwhW5WWCUd1iwaizUjzdwsGqvHwgNVxEmDLRUsIUWJY+6ZYVVg0XF7bIt2Zit9CwamG5YQu5RYeVdyczL0CMuCoJ66KwM2J+YTLoVyOHR3Ikz6MVyRshiuxzaeX4MFqpPIFWpE+UleljZGX52bESeYS/RWaXCiFqi9+lQjxqVbhLhSRqX7BLhQRuqdulQpja7Hd3RJxaX9jdEYlRHMq7OyKdIlLa3RGpHJt4d0ekUZR4o4OnFKFwo4OXouiUNjp4lSITb3TwGkcl2ujgFYqI2QVAiGLhdwEQj6IQ7gIgidof7AIggVvudgEQpjZHb8/HCkWg+PZ8LEfx2PX2fFyColN+ez7WOValt+djlSJnXxtnRtEKXhtnIYpQ/No4axSV6LVxVjgS/rVx5tR6+bsMpxGj1qtArVchar2qvvWqUetV4Narwq1XxbZeObW+/5H4U0+o5RlTuzOOWp013+asUIsz5vZmzq3N3LY1U9vSq76VH/TIvtV7ha0DFLzVe0WtAmrf6r0yrQFGb/VeQSuA2Ld6N2jzo/rbVxvTkf5oqyC7UFdBfyMrHdmN4gkFe8ETd9vAE7U7wBMKf+wqKbQtPDH7s1YJ2U3fG5Te/337Vg7lORAwCQIw+0QIBHwOBFie/gDTxzkA9ZVTgPmdU0DyOEeZvTfaEvOG8wbRZ5qgwfpLsMgKDcbnCsdA8YdgobT84qki/V1TZVEU5BHBsfTe5rnAkeTuxD70TIgeJW5Ya0/bBhFoS61t4+5tg+7lm3iUop6XG3ZkQS/zi9Mb5u+MN3Rpmr300VkGT3oTd493E7XPdBMKXwxPCj3iTSzojKV5mDvsPXTbhiF6KKA8HgHZn91VjsmpVJJQkSahMqkusL66QOT3dgWlp8zSHn20rMiml3LMLqWSXIo4t1TR1FImmaVIEkvQSOaBIRohIDt3DZ0NAndz1xBNEBDNXUNjgcDM3DVEA1SUR8ARkK3/ad+kZ15v5Ege9CmSB62AzAM/5W6Dx5CtDwrbDR5D43zA9DGpMDE+LaYPRIeVewo6rPyjz2FvfB/kFOJ7gGx3KsfuVCrdqYjyEhTtaGU5LwFJrwoSv9NORLvTzl7aI2t3w4LdDUO7G3q7GxbtbhjY3TCwu2Fod2t75Gu9drWrjUvW3iVr75J1wSXr0CVr75J14JJ14JK1c8nau2Tdu+SBtEdcElDwa5g1uSRQ+7uXdeCSoNAvXNbokoDsb1nWFX5RVlfu27G6cl+J1c4lgbsvv+rKfeNVV/5rrrry323VFX+hVVfuW6waXBIJfl9VV2aRWFd+kVhXfpFYO6M8Vu7WiDUbJZ7FrhHryq8R6ypYI9aV+xqprnCNWFdujVhXfo1YV2aNWFd+jVg7s0TBrxHryq8R68AvUeI1Yl35NWJd+TVi7T2zJs/U4CztkU/nZSF3l2HuLn3usmeCEmT1Msjqpc1qfEzfN889pmdOXhg/pmfRu6J7TM+c/dE/pmfBOqV7TE8cPNNtNmMeuWe02Ywl8tHSZjOW2VHdZjPm5K2Zj3xPs8sKJ6sVHuWsiD5xRaLsFc6JKgJnqwhxyrIbZ07jUrHx5YxxrAtjgxKBbVqFwKtF9IatUuDaIpJ1C2f/FsGZeFbYyTMHOxdEni6cjT0LbXA9Z/EihD4vamD2orHji1CwfdGd94vCE4AIPAtkgaeCzIP5IEvLABWGYDg9iFgeajxRCI9nC5FLI9HNGyLYkUjf5PUxib7JCySaRYrf5AW6n0uib/ICiWeU8Ju8QLPzSvRNnpdgdkFKEwxK0RyDup9mUKWZBqV4ssESPN+gRlMOSjTrgDQKs4TnHpRo+kEpGhao+5GBKg0OlHgAoMZjALXiMOA5CSSyB6OYmQkUtCDE7K6o8RRltGCWQt1PVEYN5irUabpCiWcs1NykBSLPWyDB1IWUZi+UeAIDrY0v76Yx1MKZDAsEkxnKPJ+hVpjSsIib1VDkiQ01nttA4+kNpGCGA3UZ0/JwD6c61HeOaZ7wUIrnPCyxY9S7mQ81M+qvO3Jd5a/srjF4h4L0D3RcYzgABX+K45qaD9T+0Y3roLmg0J/XuDbNA2b+kMZ4M+ikWZujB3sUfWE5lmWmRw8BCs8hW1M8eghQfI78183NWQQ+hDA809aStz/4f3M9zb/5v33B06hWakxaZKNGlFuACF+XAg7Jh1RtGHF+0QaQvEQBTF4tUHZb8R+825DuMtNmPk/PxgU2pgj84UtB9m9WCqbf/tmw2yq/Pn+bHVi01p+Z/Fa5/V2i28g+VRFjVKR/tTQj+gt0t9TV2+njoQ/HNjgPGA5A9hcKHtwkDNx9cf/A8QRsv89/MHMsMPod9wcT6Acf6IdCoB94PlNqw/9QDP+DnbSU2S558F1iRygGvfDOf6xSV+x65z8u4jtoxzv/cQnqttI7/7HMnenfvw/jxV286/37uIjv+ML797Eap0Pp/ftYpiQpvH+/VTeO9yLz8FP2YEDZgxGZM4KQf3lQUdsfbb/t3Rxt3gg/kCMN5OZobY9sZyTkwttilfurZASXyujVf3AdILqycH95Mx9BHQyHihj+WjjPusSpXlb0lYNJEaoGFCoG9DU8wzqmVCWUfIXyxAu1yQiqktGr/+A6QFQD4f7y9LYo1IIUqAwpr8WzrcsK1ZBlX1FZjUAVhUHlhL0Gn11HjKqigq9E/g1YqENGUIWMXv0H1wGi60d/5qmX0Ez6y2cEl8/o1X9wHSC6vHB3+byuKSxrrWy1hKbN7SLL2//3N4r4gepG2mbxePtH7yPNXDA45Sz+mGyRijR5DhJpdsnvS8zjeszt80yr5QuGWr7diFVTnajE82hcuKxugLI42gFmSmgKdtGV9f97IbII7hF/j0KYi/MvLBB2xcM9n6FIH+1js/37SseG2Bd5BMtfV7I42LcmGi79rGJ3qgmm3WfC6UUi4Wa/mVB5w9bgzW9zbd/azGToSO2J5K7F+MwvKS/QAdsLv/Sr7m26vOBSG5AdcC9uUQ3cvZn3wstnwPaFvRezUAamd5jCWnvk69wWKtiGFWx9TdzaVpWgjq19dfDFLF0FSX5vg9/NC5Xemacja/gJ2VfLEwoW9om7aSFRu4RPiJbkidF9fGLmN3wTsevxlUuoVYWPElaVe5SwMgkFKG5TE7YpeBaxMgmlKGgqP7JYmYRa+YRaFRJqFSbUyifUqphQqyChVj6hVj6hVj6hXk3wX33wX33wXwvBfw2D/xoH/9UH/zUI/msQ/LVLobVv2JqnKMJcPPgKxiv4oT/++/9jjgIE"'), BM = JSON.parse('"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"'), LM = JSON.parse('"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"'), jM = "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", IM = "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w=="; var zM = { Courier: FM, "Courier-Bold": kM, "Courier-Oblique": EM, "Courier-BoldOblique": AM, Helvetica: MM, "Helvetica-Bold": RM, "Helvetica-Oblique": OM, "Helvetica-BoldOblique": DM, "Times-Roman": LM, "Times-Bold": VM, "Times-Italic": BM, "Times-BoldItalic": NM, Symbol: jM, ZapfDingbats: IM }, Il; (function (t) { t.Courier = "Courier", t.CourierBold = "Courier-Bold", t.CourierOblique = "Courier-Oblique", t.CourierBoldOblique = "Courier-BoldOblique", t.Helvetica = "Helvetica", t.HelveticaBold = "Helvetica-Bold", t.HelveticaOblique = "Helvetica-Oblique", t.HelveticaBoldOblique = "Helvetica-BoldOblique", t.TimesRoman = "Times-Roman", t.TimesRomanBold = "Times-Bold", t.TimesRomanItalic = "Times-Italic", t.TimesRomanBoldItalic = "Times-BoldItalic", t.Symbol = "Symbol", t.ZapfDingbats = "ZapfDingbats" })(Il || (Il = {})); var uw = {}, UM = function () { function t() { var e = this; this.getWidthOfGlyph = function (n) { return e.CharWidths[n] }, this.getXAxisKerningForPair = function (n, r) { return (e.KernPairXAmounts[n] || {})[r] } } return t.load = function (e) { var n = uw[e]; if (n) return n; var r = fP(zM[e]), i = Object.assign(new t, JSON.parse(r)); return i.CharWidths = i.CharMetrics.reduce(function (s, a) { return s[a.N] = a.WX, s }, {}), i.KernPairXAmounts = i.KernPairs.reduce(function (s, a) { var u = a[0], c = a[1], f = a[2]; return s[u] || (s[u] = {}), s[u][c] = f, s }, {}), uw[e] = i, i }, t }(); const WM = "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"; var KM = fP(WM), Pp = JSON.parse(KM), Tp = function () { function t(e, n) { var r = this; this.canEncodeUnicodeCodePoint = function (i) { return i in r.unicodeMappings }, this.encodeUnicodeCodePoint = function (i) { var s = r.unicodeMappings[i]; if (!s) { var a = String.fromCharCode(i), u = "0x" + TM(i.toString(16), 4, "0"), c = r.name + ' cannot encode "' + a + '" (' + u + ")"; throw new Error(c) } return { code: s[0], name: s[1] } }, this.name = e, this.supportedCodePoints = Object.keys(n).map(Number).sort(function (i, s) { return i - s }), this.unicodeMappings = n } return t }(), kc = { Symbol: new Tp("Symbol", Pp.symbol), ZapfDingbats: new Tp("ZapfDingbats", Pp.zapfdingbats), WinAnsi: new Tp("WinAnsi", Pp.win1252) }, zf = function (t) { return Object.keys(t).map(function (e) { return t[e] }) }, HM = zf(Il), cw = function (t) { return HM.includes(t) }, Ac = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height }, rn = function (t) { return "`" + t + "`" }, qM = function (t) { return "'" + t + "'" }, fw = function (t) { var e = typeof t; return e === "string" ? qM(t) : e === "undefined" ? rn(t) : t }, GM = function (t, e, n) { for (var r = new Array(n.length), i = 0, s = n.length; i < s; i++) { var a = n[i]; r[i] = fw(a) } var u = r.join(" or "); return rn(e) + " must be one of " + u + ", but was actually " + fw(t) }, ao = function (t, e, n) { Array.isArray(n) || (n = zf(n)); for (var r = 0, i = n.length; r < i; r++)if (t === n[r]) return; throw new TypeError(GM(t, e, n)) }, br = function (t, e, n) { Array.isArray(n) || (n = zf(n)), ao(t, e, n.concat(void 0)) }, XM = function (t, e, n) { Array.isArray(n) || (n = zf(n)); for (var r = 0, i = t.length; r < i; r++)ao(t[r], e, n) }, ZM = function (t) { return t === null ? "null" : t === void 0 ? "undefined" : typeof t == "string" ? "string" : isNaN(t) ? "NaN" : typeof t == "number" ? "number" : typeof t == "boolean" ? "boolean" : typeof t == "symbol" ? "symbol" : typeof t == "bigint" ? "bigint" : t.constructor && t.constructor.name ? t.constructor.name : t.name ? t.name : t.constructor ? String(t.constructor) : String(t) }, YM = function (t, e) { return e === "null" ? t === null : e === "undefined" ? t === void 0 : e === "string" ? typeof t == "string" : e === "number" ? typeof t == "number" && !isNaN(t) : e === "boolean" ? typeof t == "boolean" : e === "symbol" ? typeof t == "symbol" : e === "bigint" ? typeof t == "bigint" : e === Date ? t instanceof Date : e === Array ? t instanceof Array : e === Uint8Array ? t instanceof Uint8Array : e === ArrayBuffer ? t instanceof ArrayBuffer : e === Function ? t instanceof Function : t instanceof e[0] }, QM = function (t, e, n) { for (var r = new Array(n.length), i = 0, s = n.length; i < s; i++) { var a = n[i]; a === "null" && (r[i] = rn("null")), a === "undefined" && (r[i] = rn("undefined")), a === "string" ? r[i] = rn("string") : a === "number" ? r[i] = rn("number") : a === "boolean" ? r[i] = rn("boolean") : a === "symbol" ? r[i] = rn("symbol") : a === "bigint" ? r[i] = rn("bigint") : a === Array ? r[i] = rn("Array") : a === Uint8Array ? r[i] = rn("Uint8Array") : a === ArrayBuffer ? r[i] = rn("ArrayBuffer") : r[i] = rn(a[1]) } var u = r.join(" or "); return rn(e) + " must be of type " + u + ", but was actually of type " + rn(ZM(t)) }, G = function (t, e, n) { for (var r = 0, i = n.length; r < i; r++)if (YM(t, n[r])) return; throw new TypeError(QM(t, e, n)) }, xe = function (t, e, n) { G(t, e, n.concat("undefined")) }, dP = function (t, e, n) { for (var r = 0, i = t.length; r < i; r++)G(t[r], e, n) }, nr = function (t, e, n, r) { if (G(t, e, ["number"]), G(n, "min", ["number"]), G(r, "max", ["number"]), r = Math.max(n, r), t < n || t > r) throw new Error(rn(e) + " must be at least " + n + " and at most " + r + ", but was actually " + t) }, Ur = function (t, e, n, r) { G(t, e, ["number", "undefined"]), typeof t == "number" && nr(t, e, n, r) }, hP = function (t, e, n) { if (G(t, e, ["number"]), t % n !== 0) throw new Error(rn(e) + " must be a multiple of " + n + ", but was actually " + t) }, JM = function (t, e) { if (!Number.isInteger(t)) throw new Error(rn(e) + " must be an integer, but was actually " + t) }, Uf = function (t, e) { if (![1, 0].includes(Math.sign(t))) throw new Error(rn(e) + " must be a positive number or 0, but was actually " + t) }, $e = new Uint16Array(256); for (var Ec = 0; Ec < 256; Ec++)$e[Ec] = Ec; $e[22] = Qe(""); $e[24] = Qe("˘"); $e[25] = Qe("ˇ"); $e[26] = Qe("ˆ"); $e[27] = Qe("˙"); $e[28] = Qe("˝"); $e[29] = Qe("˛"); $e[30] = Qe("˚"); $e[31] = Qe("˜"); $e[127] = Qe("�"); $e[128] = Qe("•"); $e[129] = Qe("†"); $e[130] = Qe("‡"); $e[131] = Qe("…"); $e[132] = Qe("—"); $e[133] = Qe("–"); $e[134] = Qe("ƒ"); $e[135] = Qe("⁄"); $e[136] = Qe("‹"); $e[137] = Qe("›"); $e[138] = Qe("−"); $e[139] = Qe("‰"); $e[140] = Qe("„"); $e[141] = Qe("“"); $e[142] = Qe("”"); $e[143] = Qe("‘"); $e[144] = Qe("’"); $e[145] = Qe("‚"); $e[146] = Qe("™"); $e[147] = Qe("ﬁ"); $e[148] = Qe("ﬂ"); $e[149] = Qe("Ł"); $e[150] = Qe("Œ"); $e[151] = Qe("Š"); $e[152] = Qe("Ÿ"); $e[153] = Qe("Ž"); $e[154] = Qe("ı"); $e[155] = Qe("ł"); $e[156] = Qe("œ"); $e[157] = Qe("š"); $e[158] = Qe("ž"); $e[159] = Qe("�"); $e[160] = Qe("€"); $e[173] = Qe("�"); var pP = function (t) { for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++)e[n] = $e[t[n]]; return String.fromCodePoint.apply(String, e) }, ki = function () { function t(e) { this.populate = e, this.value = void 0 } return t.prototype.getValue = function () { return this.value }, t.prototype.access = function () { return this.value || (this.value = this.populate()), this.value }, t.prototype.invalidate = function () { this.value = void 0 }, t.populatedBy = function (e) { return new t(e) }, t }(), Ar = function (t) { we(e, t); function e(n, r) { var i = this, s = "Method " + n + "." + r + "() not implemented"; return i = t.call(this, s) || this, i } return e }(Error), Dv = function (t) { we(e, t); function e(n) { var r = this, i = "Cannot construct " + n + " - it has a private constructor"; return r = t.call(this, i) || this, r } return e }(Error), cf = function (t) { we(e, t); function e(n, r) { var i = this, s = function (c) { var f, h; return (f = c == null ? void 0 : c.name) !== null && f !== void 0 ? f : (h = c == null ? void 0 : c.constructor) === null || h === void 0 ? void 0 : h.name }, a = Array.isArray(n) ? n.map(s) : [s(n)], u = "Expected instance of " + a.join(" or ") + ", " + ("but got instance of " + (r && s(r))); return i = t.call(this, u) || this, i } return e }(Error), _M = function (t) { we(e, t); function e(n) { var r = this, i = n + " stream encoding not supported"; return r = t.call(this, i) || this, r } return e }(Error), Ov = function (t) { we(e, t); function e(n, r) { var i = this, s = "Cannot call " + n + "." + r + "() more than once"; return i = t.call(this, s) || this, i } return e }(Error); (function (t) { we(e, t); function e(n) { var r = this, i = "Missing catalog (ref=" + n + ")"; return r = t.call(this, i) || this, r } return e })(Error); var $M = function (t) { we(e, t); function e() { var n = this, r = "Can't embed page with missing Contents"; return n = t.call(this, r) || this, n } return e }(Error), e3 = function (t) { we(e, t); function e(n) { var r, i, s, a = this, u = (s = (i = (r = n == null ? void 0 : n.contructor) === null || r === void 0 ? void 0 : r.name) !== null && i !== void 0 ? i : n == null ? void 0 : n.name) !== null && s !== void 0 ? s : n, c = "Unrecognized stream type: " + u; return a = t.call(this, c) || this, a } return e }(Error), t3 = function (t) { we(e, t); function e() { var n = this, r = "Found mismatched contexts while embedding pages. All pages in the array passed to `PDFDocument.embedPages()` must be from the same document."; return n = t.call(this, r) || this, n } return e }(Error), n3 = function (t) { we(e, t); function e(n) { var r = this, i = "Attempted to convert PDFArray with " + n + " elements to rectangle, but must have exactly 4 elements."; return r = t.call(this, i) || this, r } return e }(Error), vP = function (t) { we(e, t); function e(n) { var r = this, i = 'Attempted to convert "' + n + '" to a date, but it does not match the PDF date string format.'; return r = t.call(this, i) || this, r } return e }(Error), dw = function (t) { we(e, t); function e(n, r) { var i = this, s = "Invalid targetIndex specified: targetIndex=" + n + " must be less than Count=" + r; return i = t.call(this, s) || this, i } return e }(Error), hw = function (t) { we(e, t); function e(n, r) { var i = this, s = "Failed to " + r + " at targetIndex=" + n + " due to corrupt page tree: It is likely that one or more 'Count' entries are invalid"; return i = t.call(this, s) || this, i } return e }(Error), ff = function (t) { we(e, t); function e(n, r, i) { var s = this, a = "index should be at least " + r + " and at most " + i + ", but was actually " + n; return s = t.call(this, a) || this, s } return e }(Error), Mv = function (t) { we(e, t); function e() { var n = this, r = "Attempted to set invalid field value"; return n = t.call(this, r) || this, n } return e }(Error), r3 = function (t) { we(e, t); function e() { var n = this, r = "Attempted to select multiple values for single-select field"; return n = t.call(this, r) || this, n } return e }(Error), i3 = function (t) { we(e, t); function e(n) { var r = this, i = "No /DA (default appearance) entry found for field: " + n; return r = t.call(this, i) || this, r } return e }(Error), o3 = function (t) { we(e, t); function e(n) { var r = this, i = "No Tf operator found for DA of field: " + n; return r = t.call(this, i) || this, r } return e }(Error), pw = function (t) { we(e, t); function e(n, r) { var i = this, s = "Failed to parse number " + ("(line:" + n.line + " col:" + n.column + " offset=" + n.offset + '): "' + r + '"'); return i = t.call(this, s) || this, i } return e }(Error), bo = function (t) { we(e, t); function e(n, r) { var i = this, s = "Failed to parse PDF document " + ("(line:" + n.line + " col:" + n.column + " offset=" + n.offset + "): " + r); return i = t.call(this, s) || this, i } return e }(Error), s3 = function (t) { we(e, t); function e(n, r, i) { var s = this, a = "Expected next byte to be " + r + " but it was actually " + i; return s = t.call(this, n, a) || this, s } return e }(bo), a3 = function (t) { we(e, t); function e(n, r) { var i = this, s = "Failed to parse PDF object starting with the following byte: " + r; return i = t.call(this, n, s) || this, i } return e }(bo), l3 = function (t) { we(e, t); function e(n) { var r = this, i = "Failed to parse invalid PDF object"; return r = t.call(this, n, i) || this, r } return e }(bo), u3 = function (t) { we(e, t); function e(n) { var r = this, i = "Failed to parse PDF stream"; return r = t.call(this, n, i) || this, r } return e }(bo), c3 = function (t) { we(e, t); function e(n) { var r = this, i = "Failed to parse PDF literal string due to unbalanced parenthesis"; return r = t.call(this, n, i) || this, r } return e }(bo), f3 = function (t) { we(e, t); function e(n) { var r = this, i = "Parser stalled"; return r = t.call(this, n, i) || this, r } return e }(bo), d3 = function (t) { we(e, t); function e(n) { var r = this, i = "No PDF header found"; return r = t.call(this, n, i) || this, r } return e }(bo), h3 = function (t) { we(e, t); function e(n, r) { var i = this, s = "Did not find expected keyword '" + $C(r) + "'"; return i = t.call(this, n, s) || this, i } return e }(bo), d0; (function (t) { t[t.Null = 0] = "Null", t[t.Backspace = 8] = "Backspace", t[t.Tab = 9] = "Tab", t[t.Newline = 10] = "Newline", t[t.FormFeed = 12] = "FormFeed", t[t.CarriageReturn = 13] = "CarriageReturn", t[t.Space = 32] = "Space", t[t.ExclamationPoint = 33] = "ExclamationPoint", t[t.Hash = 35] = "Hash", t[t.Percent = 37] = "Percent", t[t.LeftParen = 40] = "LeftParen", t[t.RightParen = 41] = "RightParen", t[t.Plus = 43] = "Plus", t[t.Minus = 45] = "Minus", t[t.Dash = 45] = "Dash", t[t.Period = 46] = "Period", t[t.ForwardSlash = 47] = "ForwardSlash", t[t.Zero = 48] = "Zero", t[t.One = 49] = "One", t[t.Two = 50] = "Two", t[t.Three = 51] = "Three", t[t.Four = 52] = "Four", t[t.Five = 53] = "Five", t[t.Six = 54] = "Six", t[t.Seven = 55] = "Seven", t[t.Eight = 56] = "Eight", t[t.Nine = 57] = "Nine", t[t.LessThan = 60] = "LessThan", t[t.GreaterThan = 62] = "GreaterThan", t[t.A = 65] = "A", t[t.D = 68] = "D", t[t.E = 69] = "E", t[t.F = 70] = "F", t[t.O = 79] = "O", t[t.P = 80] = "P", t[t.R = 82] = "R", t[t.LeftSquareBracket = 91] = "LeftSquareBracket", t[t.BackSlash = 92] = "BackSlash", t[t.RightSquareBracket = 93] = "RightSquareBracket", t[t.a = 97] = "a", t[t.b = 98] = "b", t[t.d = 100] = "d", t[t.e = 101] = "e", t[t.f = 102] = "f", t[t.i = 105] = "i", t[t.j = 106] = "j", t[t.l = 108] = "l", t[t.m = 109] = "m", t[t.n = 110] = "n", t[t.o = 111] = "o", t[t.r = 114] = "r", t[t.s = 115] = "s", t[t.t = 116] = "t", t[t.u = 117] = "u", t[t.x = 120] = "x", t[t.LeftCurly = 123] = "LeftCurly", t[t.RightCurly = 125] = "RightCurly", t[t.Tilde = 126] = "Tilde" })(d0 || (d0 = {})); const M = d0; var Wf = function () {
  function t(e, n) { this.major = String(e), this.minor = String(n) } return t.prototype.toString = function () {
    var e = Ti(129); return "%PDF-" + this.major + "." + this.minor + `
%`+ e + e + e + e
  }, t.prototype.sizeInBytes = function () { return 12 + this.major.length + this.minor.length }, t.prototype.copyBytesInto = function (e, n) { var r = n; return e[n++] = M.Percent, e[n++] = M.P, e[n++] = M.D, e[n++] = M.F, e[n++] = M.Dash, n += wn(this.major, e, n), e[n++] = M.Period, n += wn(this.minor, e, n), e[n++] = M.Newline, e[n++] = M.Percent, e[n++] = 129, e[n++] = 129, e[n++] = 129, e[n++] = 129, n - r }, t.forVersion = function (e, n) { return new t(e, n) }, t
}(), Nn = function () { function t() { } return t.prototype.clone = function (e) { throw new Ar(this.constructor.name, "clone") }, t.prototype.toString = function () { throw new Ar(this.constructor.name, "toString") }, t.prototype.sizeInBytes = function () { throw new Ar(this.constructor.name, "sizeInBytes") }, t.prototype.copyBytesInto = function (e, n) { throw new Ar(this.constructor.name, "copyBytesInto") }, t }(), Xe = function (t) { we(e, t); function e(n) { var r = t.call(this) || this; return r.numberValue = n, r.stringValue = dM(n), r } return e.prototype.asNumber = function () { return this.numberValue }, e.prototype.value = function () { return this.numberValue }, e.prototype.clone = function () { return e.of(this.numberValue) }, e.prototype.toString = function () { return this.stringValue }, e.prototype.sizeInBytes = function () { return this.stringValue.length }, e.prototype.copyBytesInto = function (n, r) { return r += wn(this.stringValue, n, r), this.stringValue.length }, e.of = function (n) { return new e(n) }, e }(Nn), mt = function (t) { we(e, t); function e(n) { var r = t.call(this) || this; return r.array = [], r.context = n, r } return e.prototype.size = function () { return this.array.length }, e.prototype.push = function (n) { this.array.push(n) }, e.prototype.insert = function (n, r) { this.array.splice(n, 0, r) }, e.prototype.indexOf = function (n) { var r = this.array.indexOf(n); return r === -1 ? void 0 : r }, e.prototype.remove = function (n) { this.array.splice(n, 1) }, e.prototype.set = function (n, r) { this.array[n] = r }, e.prototype.get = function (n) { return this.array[n] }, e.prototype.lookupMaybe = function (n) { for (var r, i = [], s = 1; s < arguments.length; s++)i[s - 1] = arguments[s]; return (r = this.context).lookupMaybe.apply(r, ft([this.get(n)], i)) }, e.prototype.lookup = function (n) { for (var r, i = [], s = 1; s < arguments.length; s++)i[s - 1] = arguments[s]; return (r = this.context).lookup.apply(r, ft([this.get(n)], i)) }, e.prototype.asRectangle = function () { if (this.size() !== 4) throw new n3(this.size()); var n = this.lookup(0, Xe).asNumber(), r = this.lookup(1, Xe).asNumber(), i = this.lookup(2, Xe).asNumber(), s = this.lookup(3, Xe).asNumber(), a = n, u = r, c = i - n, f = s - r; return { x: a, y: u, width: c, height: f } }, e.prototype.asArray = function () { return this.array.slice() }, e.prototype.clone = function (n) { for (var r = e.withContext(n || this.context), i = 0, s = this.size(); i < s; i++)r.push(this.array[i]); return r }, e.prototype.toString = function () { for (var n = "[ ", r = 0, i = this.size(); r < i; r++)n += this.get(r).toString(), n += " "; return n += "]", n }, e.prototype.sizeInBytes = function () { for (var n = 3, r = 0, i = this.size(); r < i; r++)n += this.get(r).sizeInBytes() + 1; return n }, e.prototype.copyBytesInto = function (n, r) { var i = r; n[r++] = M.LeftSquareBracket, n[r++] = M.Space; for (var s = 0, a = this.size(); s < a; s++)r += this.get(s).copyBytesInto(n, r), n[r++] = M.Space; return n[r++] = M.RightSquareBracket, r - i }, e.prototype.scalePDFNumbers = function (n, r) { for (var i = 0, s = this.size(); i < s; i++) { var a = this.lookup(i); if (a instanceof Xe) { var u = i % 2 === 0 ? n : r; this.set(i, Xe.of(a.asNumber() * u)) } } }, e.withContext = function (n) { return new e(n) }, e }(Nn), kp = {}, zl = function (t) { we(e, t); function e(n, r) { var i = this; if (n !== kp) throw new Dv("PDFBool"); return i = t.call(this) || this, i.value = r, i } return e.prototype.asBoolean = function () { return this.value }, e.prototype.clone = function () { return this }, e.prototype.toString = function () { return String(this.value) }, e.prototype.sizeInBytes = function () { return this.value ? 4 : 5 }, e.prototype.copyBytesInto = function (n, r) { return this.value ? (n[r++] = M.t, n[r++] = M.r, n[r++] = M.u, n[r++] = M.e, 4) : (n[r++] = M.f, n[r++] = M.a, n[r++] = M.l, n[r++] = M.s, n[r++] = M.e, 5) }, e.True = new e(kp, !0), e.False = new e(kp, !1), e }(Nn), Dr = new Uint8Array(256); Dr[M.LeftParen] = 1; Dr[M.RightParen] = 1; Dr[M.LessThan] = 1; Dr[M.GreaterThan] = 1; Dr[M.LeftSquareBracket] = 1; Dr[M.RightSquareBracket] = 1; Dr[M.LeftCurly] = 1; Dr[M.RightCurly] = 1; Dr[M.ForwardSlash] = 1; Dr[M.Percent] = 1; var Vi = new Uint8Array(256); Vi[M.Null] = 1; Vi[M.Tab] = 1; Vi[M.Newline] = 1; Vi[M.FormFeed] = 1; Vi[M.CarriageReturn] = 1; Vi[M.Space] = 1; var Vv = new Uint8Array(256); for (var el = 0, p3 = 256; el < p3; el++)Vv[el] = Vi[el] || Dr[el] ? 1 : 0; Vv[M.Hash] = 1; var v3 = function (t) { return t.replace(/#([\dABCDEF]{2})/g, function (e, n) { return GO(n) }) }, m3 = function (t) { return t >= M.ExclamationPoint && t <= M.Tilde && !Vv[t] }, vw = {}, mw = new Map, O = function (t) { we(e, t); function e(n, r) { var i = this; if (n !== vw) throw new Dv("PDFName"); i = t.call(this) || this; for (var s = "/", a = 0, u = r.length; a < u; a++) { var c = r[a], f = Qe(c); s += m3(f) ? c : "#" + jf(f) } return i.encodedName = s, i } return e.prototype.asBytes = function () { for (var n = [], r = "", i = !1, s = function (v) { v !== void 0 && n.push(v), i = !1 }, a = 1, u = this.encodedName.length; a < u; a++) { var c = this.encodedName[a], f = Qe(c), h = this.encodedName[a + 1]; i ? f >= M.Zero && f <= M.Nine || f >= M.a && f <= M.f || f >= M.A && f <= M.F ? (r += c, (r.length === 2 || !(h >= "0" && h <= "9" || h >= "a" && h <= "f" || h >= "A" && h <= "F")) && (s(parseInt(r, 16)), r = "")) : s(f) : f === M.Hash ? i = !0 : s(f) } return new Uint8Array(n) }, e.prototype.decodeText = function () { var n = this.asBytes(); return String.fromCharCode.apply(String, Array.from(n)) }, e.prototype.asString = function () { return this.encodedName }, e.prototype.value = function () { return this.encodedName }, e.prototype.clone = function () { return this }, e.prototype.toString = function () { return this.encodedName }, e.prototype.sizeInBytes = function () { return this.encodedName.length }, e.prototype.copyBytesInto = function (n, r) { return r += wn(this.encodedName, n, r), this.encodedName.length }, e.of = function (n) { var r = v3(n), i = mw.get(r); return i || (i = new e(vw, r), mw.set(r, i)), i }, e.Length = e.of("Length"), e.FlateDecode = e.of("FlateDecode"), e.Resources = e.of("Resources"), e.Font = e.of("Font"), e.XObject = e.of("XObject"), e.ExtGState = e.of("ExtGState"), e.Contents = e.of("Contents"), e.Type = e.of("Type"), e.Parent = e.of("Parent"), e.MediaBox = e.of("MediaBox"), e.Page = e.of("Page"), e.Annots = e.of("Annots"), e.TrimBox = e.of("TrimBox"), e.ArtBox = e.of("ArtBox"), e.BleedBox = e.of("BleedBox"), e.CropBox = e.of("CropBox"), e.Rotate = e.of("Rotate"), e.Title = e.of("Title"), e.Author = e.of("Author"), e.Subject = e.of("Subject"), e.Creator = e.of("Creator"), e.Keywords = e.of("Keywords"), e.Producer = e.of("Producer"), e.CreationDate = e.of("CreationDate"), e.ModDate = e.of("ModDate"), e }(Nn), g3 = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.asNull = function () { return null }, e.prototype.clone = function () { return this }, e.prototype.toString = function () { return "null" }, e.prototype.sizeInBytes = function () { return 4 }, e.prototype.copyBytesInto = function (n, r) { return n[r++] = M.n, n[r++] = M.u, n[r++] = M.l, n[r++] = M.l, 4 }, e }(Nn); const Xn = new g3; var et = function (t) {
  we(e, t); function e(n, r) { var i = t.call(this) || this; return i.dict = n, i.context = r, i } return e.prototype.keys = function () { return Array.from(this.dict.keys()) }, e.prototype.values = function () { return Array.from(this.dict.values()) }, e.prototype.entries = function () { return Array.from(this.dict.entries()) }, e.prototype.set = function (n, r) { this.dict.set(n, r) }, e.prototype.get = function (n, r) { r === void 0 && (r = !1); var i = this.dict.get(n); if (!(i === Xn && !r)) return i }, e.prototype.has = function (n) { var r = this.dict.get(n); return r !== void 0 && r !== Xn }, e.prototype.lookupMaybe = function (n) { for (var r, i = [], s = 1; s < arguments.length; s++)i[s - 1] = arguments[s]; var a = i.includes(Xn), u = (r = this.context).lookupMaybe.apply(r, ft([this.get(n, a)], i)); if (!(u === Xn && !a)) return u }, e.prototype.lookup = function (n) { for (var r, i = [], s = 1; s < arguments.length; s++)i[s - 1] = arguments[s]; var a = i.includes(Xn), u = (r = this.context).lookup.apply(r, ft([this.get(n, a)], i)); if (!(u === Xn && !a)) return u }, e.prototype.delete = function (n) { return this.dict.delete(n) }, e.prototype.asMap = function () { return new Map(this.dict) }, e.prototype.uniqueKey = function (n) { n === void 0 && (n = ""); for (var r = this.keys(), i = O.of(this.context.addRandomSuffix(n, 10)); r.includes(i);)i = O.of(this.context.addRandomSuffix(n, 10)); return i }, e.prototype.clone = function (n) { for (var r = e.withContext(n || this.context), i = this.entries(), s = 0, a = i.length; s < a; s++) { var u = i[s], c = u[0], f = u[1]; r.set(c, f) } return r }, e.prototype.toString = function () {
    for (var n = `<<
`, r = this.entries(), i = 0, s = r.length; i < s; i++) {
      var a = r[i], u = a[0], c = a[1]; n += u.toString() + " " + c.toString() + `
`} return n += ">>", n
  }, e.prototype.sizeInBytes = function () { for (var n = 5, r = this.entries(), i = 0, s = r.length; i < s; i++) { var a = r[i], u = a[0], c = a[1]; n += u.sizeInBytes() + c.sizeInBytes() + 2 } return n }, e.prototype.copyBytesInto = function (n, r) { var i = r; n[r++] = M.LessThan, n[r++] = M.LessThan, n[r++] = M.Newline; for (var s = this.entries(), a = 0, u = s.length; a < u; a++) { var c = s[a], f = c[0], h = c[1]; r += f.copyBytesInto(n, r), n[r++] = M.Space, r += h.copyBytesInto(n, r), n[r++] = M.Newline } return n[r++] = M.GreaterThan, n[r++] = M.GreaterThan, r - i }, e.withContext = function (n) { return new e(new Map, n) }, e.fromMapWithContext = function (n, r) { return new e(n, r) }, e
}(Nn), or = function (t) {
  we(e, t); function e(n) { var r = t.call(this) || this; return r.dict = n, r } return e.prototype.clone = function (n) { throw new Ar(this.constructor.name, "clone") }, e.prototype.getContentsString = function () { throw new Ar(this.constructor.name, "getContentsString") }, e.prototype.getContents = function () { throw new Ar(this.constructor.name, "getContents") }, e.prototype.getContentsSize = function () { throw new Ar(this.constructor.name, "getContentsSize") }, e.prototype.updateDict = function () { var n = this.getContentsSize(); this.dict.set(O.Length, Xe.of(n)) }, e.prototype.sizeInBytes = function () { return this.updateDict(), this.dict.sizeInBytes() + this.getContentsSize() + 18 }, e.prototype.toString = function () {
    this.updateDict(); var n = this.dict.toString(); return n += `
stream
`, n += this.getContentsString(), n += `
endstream`, n
  }, e.prototype.copyBytesInto = function (n, r) { this.updateDict(); var i = r; r += this.dict.copyBytesInto(n, r), n[r++] = M.Newline, n[r++] = M.s, n[r++] = M.t, n[r++] = M.r, n[r++] = M.e, n[r++] = M.a, n[r++] = M.m, n[r++] = M.Newline; for (var s = this.getContents(), a = 0, u = s.length; a < u; a++)n[r++] = s[a]; return n[r++] = M.Newline, n[r++] = M.e, n[r++] = M.n, n[r++] = M.d, n[r++] = M.s, n[r++] = M.t, n[r++] = M.r, n[r++] = M.e, n[r++] = M.a, n[r++] = M.m, r - i }, e
}(Nn), Ul = function (t) { we(e, t); function e(n, r) { var i = t.call(this, n) || this; return i.contents = r, i } return e.prototype.asUint8Array = function () { return this.contents.slice() }, e.prototype.clone = function (n) { return e.of(this.dict.clone(n), this.contents.slice()) }, e.prototype.getContentsString = function () { return $C(this.contents) }, e.prototype.getContents = function () { return this.contents }, e.prototype.getContentsSize = function () { return this.contents.length }, e.of = function (n, r) { return new e(n, r) }, e }(or), gw = {}, yw = new Map, wt = function (t) { we(e, t); function e(n, r, i) { var s = this; if (n !== gw) throw new Dv("PDFRef"); return s = t.call(this) || this, s.objectNumber = r, s.generationNumber = i, s.tag = r + " " + i + " R", s } return e.prototype.clone = function () { return this }, e.prototype.toString = function () { return this.tag }, e.prototype.sizeInBytes = function () { return this.tag.length }, e.prototype.copyBytesInto = function (n, r) { return r += wn(this.tag, n, r), this.tag.length }, e.of = function (n, r) { r === void 0 && (r = 0); var i = n + " " + r + " R", s = yw.get(i); return s || (s = new e(gw, n, r), yw.set(i, s)), s }, e }(Nn), ct = function () { function t(e, n) { this.name = e, this.args = n || [] } return t.prototype.clone = function (e) { for (var n = new Array(this.args.length), r = 0, i = n.length; r < i; r++) { var s = this.args[r]; n[r] = s instanceof Nn ? s.clone(e) : s } return t.of(this.name, n) }, t.prototype.toString = function () { for (var e = "", n = 0, r = this.args.length; n < r; n++)e += String(this.args[n]) + " "; return e += this.name, e }, t.prototype.sizeInBytes = function () { for (var e = 0, n = 0, r = this.args.length; n < r; n++) { var i = this.args[n]; e += (i instanceof Nn ? i.sizeInBytes() : i.length) + 1 } return e += this.name.length, e }, t.prototype.copyBytesInto = function (e, n) { for (var r = n, i = 0, s = this.args.length; i < s; i++) { var a = this.args[i]; a instanceof Nn ? n += a.copyBytesInto(e, n) : n += wn(a, e, n), e[n++] = M.Space } return n += wn(this.name, e, n), n - r }, t.of = function (e, n) { return new t(e, n) }, t }(), h0; (function (t) { t.NonStrokingColor = "sc", t.NonStrokingColorN = "scn", t.NonStrokingColorRgb = "rg", t.NonStrokingColorGray = "g", t.NonStrokingColorCmyk = "k", t.NonStrokingColorspace = "cs", t.StrokingColor = "SC", t.StrokingColorN = "SCN", t.StrokingColorRgb = "RG", t.StrokingColorGray = "G", t.StrokingColorCmyk = "K", t.StrokingColorspace = "CS", t.BeginMarkedContentSequence = "BDC", t.BeginMarkedContent = "BMC", t.EndMarkedContent = "EMC", t.MarkedContentPointWithProps = "DP", t.MarkedContentPoint = "MP", t.DrawObject = "Do", t.ConcatTransformationMatrix = "cm", t.PopGraphicsState = "Q", t.PushGraphicsState = "q", t.SetFlatness = "i", t.SetGraphicsStateParams = "gs", t.SetLineCapStyle = "J", t.SetLineDashPattern = "d", t.SetLineJoinStyle = "j", t.SetLineMiterLimit = "M", t.SetLineWidth = "w", t.SetTextMatrix = "Tm", t.SetRenderingIntent = "ri", t.AppendRectangle = "re", t.BeginInlineImage = "BI", t.BeginInlineImageData = "ID", t.EndInlineImage = "EI", t.ClipEvenOdd = "W*", t.ClipNonZero = "W", t.CloseAndStroke = "s", t.CloseFillEvenOddAndStroke = "b*", t.CloseFillNonZeroAndStroke = "b", t.ClosePath = "h", t.AppendBezierCurve = "c", t.CurveToReplicateFinalPoint = "y", t.CurveToReplicateInitialPoint = "v", t.EndPath = "n", t.FillEvenOddAndStroke = "B*", t.FillEvenOdd = "f*", t.FillNonZeroAndStroke = "B", t.FillNonZero = "f", t.LegacyFillNonZero = "F", t.LineTo = "l", t.MoveTo = "m", t.ShadingFill = "sh", t.StrokePath = "S", t.BeginText = "BT", t.EndText = "ET", t.MoveText = "Td", t.MoveTextSetLeading = "TD", t.NextLine = "T*", t.SetCharacterSpacing = "Tc", t.SetFontAndSize = "Tf", t.SetTextHorizontalScaling = "Tz", t.SetTextLineHeight = "TL", t.SetTextRenderingMode = "Tr", t.SetTextRise = "Ts", t.SetWordSpacing = "Tw", t.ShowText = "Tj", t.ShowTextAdjusted = "TJ", t.ShowTextLine = "'", t.ShowTextLineAndSpace = '"', t.Type3D0 = "d0", t.Type3D1 = "d1", t.BeginCompatibilitySection = "BX", t.EndCompatibilitySection = "EX" })(h0 || (h0 = {})); const dt = h0; var Nv = function (t) { we(e, t); function e(n, r) { var i = t.call(this, n) || this; return i.computeContents = function () { var s = i.getUnencodedContents(); return i.encode ? If.deflate(s) : s }, i.encode = r, r && n.set(O.of("Filter"), O.of("FlateDecode")), i.contentsCache = ki.populatedBy(i.computeContents), i } return e.prototype.getContents = function () { return this.contentsCache.access() }, e.prototype.getContentsSize = function () { return this.contentsCache.access().length }, e.prototype.getUnencodedContents = function () { throw new Ar(this.constructor.name, "getUnencodedContents") }, e }(or), Cl = function (t) {
  we(e, t); function e(n, r, i) { i === void 0 && (i = !0); var s = t.call(this, n, i) || this; return s.operators = r, s } return e.prototype.push = function () { for (var n, r = [], i = 0; i < arguments.length; i++)r[i] = arguments[i]; (n = this.operators).push.apply(n, r) }, e.prototype.clone = function (n) { for (var r = new Array(this.operators.length), i = 0, s = this.operators.length; i < s; i++)r[i] = this.operators[i].clone(n); var a = this, u = a.dict, c = a.encode; return e.of(u.clone(n), r, c) }, e.prototype.getContentsString = function () {
    for (var n = "", r = 0, i = this.operators.length; r < i; r++)n += this.operators[r] + `
`; return n
  }, e.prototype.getUnencodedContents = function () { for (var n = new Uint8Array(this.getUnencodedContentsSize()), r = 0, i = 0, s = this.operators.length; i < s; i++)r += this.operators[i].copyBytesInto(n, r), n[r++] = M.Newline; return n }, e.prototype.getUnencodedContentsSize = function () { for (var n = 0, r = 0, i = this.operators.length; r < i; r++)n += this.operators[r].sizeInBytes() + 1; return n }, e.of = function (n, r, i) { return i === void 0 && (i = !0), new e(n, r, i) }, e
}(Nv), y3 = function () { function t(e) { this.seed = e } return t.prototype.nextInt = function () { var e = Math.sin(this.seed++) * 1e4; return e - Math.floor(e) }, t.withSeed = function (e) { return new t(e) }, t }(), x3 = function (t, e) { var n = t[0], r = e[0]; return n.objectNumber - r.objectNumber }, p0 = function () { function t() { this.largestObjectNumber = 0, this.header = Wf.forVersion(1, 7), this.trailerInfo = {}, this.indirectObjects = new Map, this.rng = y3.withSeed(1) } return t.prototype.assign = function (e, n) { this.indirectObjects.set(e, n), e.objectNumber > this.largestObjectNumber && (this.largestObjectNumber = e.objectNumber) }, t.prototype.nextRef = function () { return this.largestObjectNumber += 1, wt.of(this.largestObjectNumber) }, t.prototype.register = function (e) { var n = this.nextRef(); return this.assign(n, e), n }, t.prototype.delete = function (e) { return this.indirectObjects.delete(e) }, t.prototype.lookupMaybe = function (e) { for (var n = [], r = 1; r < arguments.length; r++)n[r - 1] = arguments[r]; var i = n.includes(Xn), s = e instanceof wt ? this.indirectObjects.get(e) : e; if (!(!s || s === Xn && !i)) { for (var a = 0, u = n.length; a < u; a++) { var c = n[a]; if (c === Xn) { if (s === Xn) return s } else if (s instanceof c) return s } throw new cf(n, s) } }, t.prototype.lookup = function (e) { for (var n = [], r = 1; r < arguments.length; r++)n[r - 1] = arguments[r]; var i = e instanceof wt ? this.indirectObjects.get(e) : e; if (n.length === 0) return i; for (var s = 0, a = n.length; s < a; s++) { var u = n[s]; if (u === Xn) { if (i === Xn) return i } else if (i instanceof u) return i } throw new cf(n, i) }, t.prototype.getObjectRef = function (e) { for (var n = Array.from(this.indirectObjects.entries()), r = 0, i = n.length; r < i; r++) { var s = n[r], a = s[0], u = s[1]; if (u === e) return a } }, t.prototype.enumerateIndirectObjects = function () { return Array.from(this.indirectObjects.entries()).sort(x3) }, t.prototype.obj = function (e) { if (e instanceof Nn) return e; if (e == null) return Xn; if (typeof e == "string") return O.of(e); if (typeof e == "number") return Xe.of(e); if (typeof e == "boolean") return e ? zl.True : zl.False; if (Array.isArray(e)) { for (var n = mt.withContext(this), r = 0, i = e.length; r < i; r++)n.push(this.obj(e[r])); return n } else { for (var s = et.withContext(this), a = Object.keys(e), r = 0, i = a.length; r < i; r++) { var u = a[r], c = e[u]; c !== void 0 && s.set(O.of(u), this.obj(c)) } return s } }, t.prototype.stream = function (e, n) { return n === void 0 && (n = {}), Ul.of(this.obj(n), f0(e)) }, t.prototype.flateStream = function (e, n) { return n === void 0 && (n = {}), this.stream(If.deflate(f0(e)), _e(_e({}, n), { Filter: "FlateDecode" })) }, t.prototype.contentStream = function (e, n) { return n === void 0 && (n = {}), Cl.of(this.obj(n), e) }, t.prototype.formXObject = function (e, n) { return n === void 0 && (n = {}), this.contentStream(e, _e(_e({ BBox: this.obj([0, 0, 0, 0]), Matrix: this.obj([1, 0, 0, 1, 0, 0]) }, n), { Type: "XObject", Subtype: "Form" })) }, t.prototype.getPushGraphicsStateContentStream = function () { if (this.pushGraphicsStateContentStreamRef) return this.pushGraphicsStateContentStreamRef; var e = this.obj({}), n = ct.of(dt.PushGraphicsState), r = Cl.of(e, [n]); return this.pushGraphicsStateContentStreamRef = this.register(r), this.pushGraphicsStateContentStreamRef }, t.prototype.getPopGraphicsStateContentStream = function () { if (this.popGraphicsStateContentStreamRef) return this.popGraphicsStateContentStreamRef; var e = this.obj({}), n = ct.of(dt.PopGraphicsState), r = Cl.of(e, [n]); return this.popGraphicsStateContentStreamRef = this.register(r), this.popGraphicsStateContentStreamRef }, t.prototype.addRandomSuffix = function (e, n) { return n === void 0 && (n = 4), e + "-" + Math.floor(this.rng.nextInt() * Math.pow(10, n)) }, t.create = function () { return new t }, t }(), Ai = function (t) { we(e, t); function e(n, r, i) { i === void 0 && (i = !0); var s = t.call(this, n, r) || this; return s.normalized = !1, s.autoNormalizeCTM = i, s } return e.prototype.clone = function (n) { for (var r = e.fromMapWithContext(new Map, n || this.context, this.autoNormalizeCTM), i = this.entries(), s = 0, a = i.length; s < a; s++) { var u = i[s], c = u[0], f = u[1]; r.set(c, f) } return r }, e.prototype.Parent = function () { return this.lookupMaybe(O.Parent, et) }, e.prototype.Contents = function () { return this.lookup(O.of("Contents")) }, e.prototype.Annots = function () { return this.lookupMaybe(O.Annots, mt) }, e.prototype.BleedBox = function () { return this.lookupMaybe(O.BleedBox, mt) }, e.prototype.TrimBox = function () { return this.lookupMaybe(O.TrimBox, mt) }, e.prototype.ArtBox = function () { return this.lookupMaybe(O.ArtBox, mt) }, e.prototype.Resources = function () { var n = this.getInheritableAttribute(O.Resources); return this.context.lookupMaybe(n, et) }, e.prototype.MediaBox = function () { var n = this.getInheritableAttribute(O.MediaBox); return this.context.lookup(n, mt) }, e.prototype.CropBox = function () { var n = this.getInheritableAttribute(O.CropBox); return this.context.lookupMaybe(n, mt) }, e.prototype.Rotate = function () { var n = this.getInheritableAttribute(O.Rotate); return this.context.lookupMaybe(n, Xe) }, e.prototype.getInheritableAttribute = function (n) { var r; return this.ascend(function (i) { r || (r = i.get(n)) }), r }, e.prototype.setParent = function (n) { this.set(O.Parent, n) }, e.prototype.addContentStream = function (n) { var r = this.normalizedEntries().Contents || this.context.obj([]); this.set(O.Contents, r), r.push(n) }, e.prototype.wrapContentStreams = function (n, r) { var i = this.Contents(); return i instanceof mt ? (i.insert(0, n), i.push(r), !0) : !1 }, e.prototype.addAnnot = function (n) { var r = this.normalizedEntries().Annots; r.push(n) }, e.prototype.removeAnnot = function (n) { var r = this.normalizedEntries().Annots, i = r.indexOf(n); i !== void 0 && r.remove(i) }, e.prototype.setFontDictionary = function (n, r) { var i = this.normalizedEntries().Font; i.set(n, r) }, e.prototype.newFontDictionaryKey = function (n) { var r = this.normalizedEntries().Font; return r.uniqueKey(n) }, e.prototype.newFontDictionary = function (n, r) { var i = this.newFontDictionaryKey(n); return this.setFontDictionary(i, r), i }, e.prototype.setXObject = function (n, r) { var i = this.normalizedEntries().XObject; i.set(n, r) }, e.prototype.newXObjectKey = function (n) { var r = this.normalizedEntries().XObject; return r.uniqueKey(n) }, e.prototype.newXObject = function (n, r) { var i = this.newXObjectKey(n); return this.setXObject(i, r), i }, e.prototype.setExtGState = function (n, r) { var i = this.normalizedEntries().ExtGState; i.set(n, r) }, e.prototype.newExtGStateKey = function (n) { var r = this.normalizedEntries().ExtGState; return r.uniqueKey(n) }, e.prototype.newExtGState = function (n, r) { var i = this.newExtGStateKey(n); return this.setExtGState(i, r), i }, e.prototype.ascend = function (n) { n(this); var r = this.Parent(); r && r.ascend(n) }, e.prototype.normalize = function () { if (!this.normalized) { var n = this.context, r = this.get(O.Contents), i = this.context.lookup(r); i instanceof or && this.set(O.Contents, n.obj([r])), this.autoNormalizeCTM && this.wrapContentStreams(this.context.getPushGraphicsStateContentStream(), this.context.getPopGraphicsStateContentStream()); var s = this.getInheritableAttribute(O.Resources), a = n.lookupMaybe(s, et) || n.obj({}); this.set(O.Resources, a); var u = a.lookupMaybe(O.Font, et) || n.obj({}); a.set(O.Font, u); var c = a.lookupMaybe(O.XObject, et) || n.obj({}); a.set(O.XObject, c); var f = a.lookupMaybe(O.ExtGState, et) || n.obj({}); a.set(O.ExtGState, f); var h = this.Annots() || n.obj([]); this.set(O.Annots, h), this.normalized = !0 } }, e.prototype.normalizedEntries = function () { this.normalize(); var n = this.Annots(), r = this.Resources(), i = this.Contents(); return { Annots: n, Resources: r, Contents: i, Font: r.lookup(O.Font, et), XObject: r.lookup(O.XObject, et), ExtGState: r.lookup(O.ExtGState, et) } }, e.InheritableEntries = ["Resources", "MediaBox", "CropBox", "Rotate"], e.withContextAndParent = function (n, r) { var i = new Map; return i.set(O.Type, O.Page), i.set(O.Parent, r), i.set(O.Resources, n.obj({})), i.set(O.MediaBox, n.obj([0, 0, 612, 792])), new e(i, n, !1) }, e.fromMapWithContext = function (n, r, i) { return i === void 0 && (i = !0), new e(n, r, i) }, e }(et), xw = function () { function t(e, n) { var r = this; this.traversedObjects = new Map, this.copy = function (i) { return i instanceof Ai ? r.copyPDFPage(i) : i instanceof et ? r.copyPDFDict(i) : i instanceof mt ? r.copyPDFArray(i) : i instanceof or ? r.copyPDFStream(i) : i instanceof wt ? r.copyPDFIndirectObject(i) : i.clone() }, this.copyPDFPage = function (i) { for (var s = i.clone(), a = Ai.InheritableEntries, u = 0, c = a.length; u < c; u++) { var f = O.of(a[u]), h = s.getInheritableAttribute(f); !s.get(f) && h && s.set(f, h) } return s.delete(O.of("Parent")), r.copyPDFDict(s) }, this.copyPDFDict = function (i) { if (r.traversedObjects.has(i)) return r.traversedObjects.get(i); var s = i.clone(r.dest); r.traversedObjects.set(i, s); for (var a = i.entries(), u = 0, c = a.length; u < c; u++) { var f = a[u], h = f[0], v = f[1]; s.set(h, r.copy(v)) } return s }, this.copyPDFArray = function (i) { if (r.traversedObjects.has(i)) return r.traversedObjects.get(i); var s = i.clone(r.dest); r.traversedObjects.set(i, s); for (var a = 0, u = i.size(); a < u; a++) { var c = i.get(a); s.set(a, r.copy(c)) } return s }, this.copyPDFStream = function (i) { if (r.traversedObjects.has(i)) return r.traversedObjects.get(i); var s = i.clone(r.dest); r.traversedObjects.set(i, s); for (var a = i.dict.entries(), u = 0, c = a.length; u < c; u++) { var f = a[u], h = f[0], v = f[1]; s.dict.set(h, r.copy(v)) } return s }, this.copyPDFIndirectObject = function (i) { var s = r.traversedObjects.has(i); if (!s) { var a = r.dest.nextRef(); r.traversedObjects.set(i, a); var u = r.src.lookup(i); if (u) { var c = r.copy(u); r.dest.assign(a, c) } } return r.traversedObjects.get(i) }, this.src = e, this.dest = n } return t.for = function (e, n) { return new t(e, n) }, t }(), mP = function () {
  function t(e) { this.subsections = e ? [[e]] : [], this.chunkIdx = 0, this.chunkLength = e ? 1 : 0 } return t.prototype.addEntry = function (e, n) { this.append({ ref: e, offset: n, deleted: !1 }) }, t.prototype.addDeletedEntry = function (e, n) { this.append({ ref: e, offset: n, deleted: !0 }) }, t.prototype.toString = function () {
    for (var e = `xref
`, n = 0, r = this.subsections.length; n < r; n++) {
      var i = this.subsections[n]; e += i[0].ref.objectNumber + " " + i.length + `
`; for (var s = 0, a = i.length; s < a; s++) {
        var u = i[s]; e += qr(String(u.offset), 10, "0"), e += " ", e += qr(String(u.ref.generationNumber), 5, "0"), e += " ", e += u.deleted ? "f" : "n", e += ` 
`}
    } return e
  }, t.prototype.sizeInBytes = function () { for (var e = 5, n = 0, r = this.subsections.length; n < r; n++) { var i = this.subsections[n], s = i.length, a = i[0]; e += 2, e += String(a.ref.objectNumber).length, e += String(s).length, e += 20 * s } return e }, t.prototype.copyBytesInto = function (e, n) { var r = n; return e[n++] = M.x, e[n++] = M.r, e[n++] = M.e, e[n++] = M.f, e[n++] = M.Newline, n += this.copySubsectionsIntoBuffer(this.subsections, e, n), n - r }, t.prototype.copySubsectionsIntoBuffer = function (e, n, r) { for (var i = r, s = e.length, a = 0; a < s; a++) { var u = this.subsections[a], c = String(u[0].ref.objectNumber); r += wn(c, n, r), n[r++] = M.Space; var f = String(u.length); r += wn(f, n, r), n[r++] = M.Newline, r += this.copyEntriesIntoBuffer(u, n, r) } return r - i }, t.prototype.copyEntriesIntoBuffer = function (e, n, r) { for (var i = e.length, s = 0; s < i; s++) { var a = e[s], u = qr(String(a.offset), 10, "0"); r += wn(u, n, r), n[r++] = M.Space; var c = qr(String(a.ref.generationNumber), 5, "0"); r += wn(c, n, r), n[r++] = M.Space, n[r++] = a.deleted ? M.f : M.n, n[r++] = M.Space, n[r++] = M.Newline } return 20 * i }, t.prototype.append = function (e) { if (this.chunkLength === 0) { this.subsections.push([e]), this.chunkIdx = 0, this.chunkLength = 1; return } var n = this.subsections[this.chunkIdx], r = n[this.chunkLength - 1]; e.ref.objectNumber - r.ref.objectNumber > 1 ? (this.subsections.push([e]), this.chunkIdx += 1, this.chunkLength = 1) : (n.push(e), this.chunkLength += 1) }, t.create = function () { return new t({ ref: wt.of(0, 65535), offset: 0, deleted: !0 }) }, t.createEmpty = function () { return new t }, t
}(), Bv = function () {
  function t(e) { this.lastXRefOffset = String(e) } return t.prototype.toString = function () {
    return `startxref
`+ this.lastXRefOffset + `
%%EOF`}, t.prototype.sizeInBytes = function () { return 16 + this.lastXRefOffset.length }, t.prototype.copyBytesInto = function (e, n) { var r = n; return e[n++] = M.s, e[n++] = M.t, e[n++] = M.a, e[n++] = M.r, e[n++] = M.t, e[n++] = M.x, e[n++] = M.r, e[n++] = M.e, e[n++] = M.f, e[n++] = M.Newline, n += wn(this.lastXRefOffset, e, n), e[n++] = M.Newline, e[n++] = M.Percent, e[n++] = M.Percent, e[n++] = M.E, e[n++] = M.O, e[n++] = M.F, n - r }, t.forLastCrossRefSectionOffset = function (e) { return new t(e) }, t
}(), w3 = function () {
  function t(e) { this.dict = e } return t.prototype.toString = function () {
    return `trailer
`+ this.dict.toString()
  }, t.prototype.sizeInBytes = function () { return 8 + this.dict.sizeInBytes() }, t.prototype.copyBytesInto = function (e, n) { var r = n; return e[n++] = M.t, e[n++] = M.r, e[n++] = M.a, e[n++] = M.i, e[n++] = M.l, e[n++] = M.e, e[n++] = M.r, e[n++] = M.Newline, n += this.dict.copyBytesInto(e, n), n - r }, t.of = function (e) { return new t(e) }, t
}(), gP = function (t) {
  we(e, t); function e(n, r, i) { i === void 0 && (i = !0); var s = t.call(this, n.obj({}), i) || this; return s.objects = r, s.offsets = s.computeObjectOffsets(), s.offsetsString = s.computeOffsetsString(), s.dict.set(O.of("Type"), O.of("ObjStm")), s.dict.set(O.of("N"), Xe.of(s.objects.length)), s.dict.set(O.of("First"), Xe.of(s.offsetsString.length)), s } return e.prototype.getObjectsCount = function () { return this.objects.length }, e.prototype.clone = function (n) { return e.withContextAndObjects(n || this.dict.context, this.objects.slice(), this.encode) }, e.prototype.getContentsString = function () {
    for (var n = this.offsetsString, r = 0, i = this.objects.length; r < i; r++) {
      var s = this.objects[r], a = s[1]; n += a + `
`} return n
  }, e.prototype.getUnencodedContents = function () { for (var n = new Uint8Array(this.getUnencodedContentsSize()), r = wn(this.offsetsString, n, 0), i = 0, s = this.objects.length; i < s; i++) { var a = this.objects[i], u = a[1]; r += u.copyBytesInto(n, r), n[r++] = M.Newline } return n }, e.prototype.getUnencodedContentsSize = function () { return this.offsetsString.length + uf(this.offsets)[1] + uf(this.objects)[1].sizeInBytes() + 1 }, e.prototype.computeOffsetsString = function () { for (var n = "", r = 0, i = this.offsets.length; r < i; r++) { var s = this.offsets[r], a = s[0], u = s[1]; n += a + " " + u + " " } return n }, e.prototype.computeObjectOffsets = function () { for (var n = 0, r = new Array(this.objects.length), i = 0, s = this.objects.length; i < s; i++) { var a = this.objects[i], u = a[0], c = a[1]; r[i] = [u.objectNumber, n], n += c.sizeInBytes() + 1 } return r }, e.withContextAndObjects = function (n, r, i) { return i === void 0 && (i = !0), new e(n, r, i) }, e
}(Nv), yP = function () { function t(e, n) { var r = this; this.parsedObjects = 0, this.shouldWaitForTick = function (i) { return r.parsedObjects += i, r.parsedObjects % r.objectsPerTick === 0 }, this.context = e, this.objectsPerTick = n } return t.prototype.serializeToBuffer = function () { return tt(this, void 0, void 0, function () { var e, n, r, i, s, a, u, c, f, h, v, m, g, S, b, P, C; return nt(this, function (F) { switch (F.label) { case 0: return [4, this.computeBufferSize()]; case 1: e = F.sent(), n = e.size, r = e.header, i = e.indirectObjects, s = e.xref, a = e.trailerDict, u = e.trailer, c = 0, f = new Uint8Array(n), c += r.copyBytesInto(f, c), f[c++] = M.Newline, f[c++] = M.Newline, h = 0, v = i.length, F.label = 2; case 2: return h < v ? (m = i[h], g = m[0], S = m[1], b = String(g.objectNumber), c += wn(b, f, c), f[c++] = M.Space, P = String(g.generationNumber), c += wn(P, f, c), f[c++] = M.Space, f[c++] = M.o, f[c++] = M.b, f[c++] = M.j, f[c++] = M.Newline, c += S.copyBytesInto(f, c), f[c++] = M.Newline, f[c++] = M.e, f[c++] = M.n, f[c++] = M.d, f[c++] = M.o, f[c++] = M.b, f[c++] = M.j, f[c++] = M.Newline, f[c++] = M.Newline, C = S instanceof gP ? S.getObjectsCount() : 1, this.shouldWaitForTick(C) ? [4, na()] : [3, 4]) : [3, 5]; case 3: F.sent(), F.label = 4; case 4: return h++, [3, 2]; case 5: return s && (c += s.copyBytesInto(f, c), f[c++] = M.Newline), a && (c += a.copyBytesInto(f, c), f[c++] = M.Newline, f[c++] = M.Newline), c += u.copyBytesInto(f, c), [2, f] } }) }) }, t.prototype.computeIndirectObjectSize = function (e) { var n = e[0], r = e[1], i = n.sizeInBytes() + 3, s = r.sizeInBytes() + 9; return i + s }, t.prototype.createTrailerDict = function () { return this.context.obj({ Size: this.context.largestObjectNumber + 1, Root: this.context.trailerInfo.Root, Encrypt: this.context.trailerInfo.Encrypt, Info: this.context.trailerInfo.Info, ID: this.context.trailerInfo.ID }) }, t.prototype.computeBufferSize = function () { return tt(this, void 0, void 0, function () { var e, n, r, i, s, a, u, c, f, h, v; return nt(this, function (m) { switch (m.label) { case 0: e = Wf.forVersion(1, 7), n = e.sizeInBytes() + 2, r = mP.create(), i = this.context.enumerateIndirectObjects(), s = 0, a = i.length, m.label = 1; case 1: return s < a ? (u = i[s], c = u[0], r.addEntry(c, n), n += this.computeIndirectObjectSize(u), this.shouldWaitForTick(1) ? [4, na()] : [3, 3]) : [3, 4]; case 2: m.sent(), m.label = 3; case 3: return s++, [3, 1]; case 4: return f = n, n += r.sizeInBytes() + 1, h = w3.of(this.createTrailerDict()), n += h.sizeInBytes() + 2, v = Bv.forLastCrossRefSectionOffset(f), n += v.sizeInBytes(), [2, { size: n, header: e, indirectObjects: i, xref: r, trailerDict: h, trailer: v }] } }) }) }, t.forContext = function (e, n) { return new t(e, n) }, t }(), xP = function (t) { we(e, t); function e(n) { var r = t.call(this) || this; return r.data = n, r } return e.prototype.clone = function () { return e.of(this.data.slice()) }, e.prototype.toString = function () { return "PDFInvalidObject(" + this.data.length + " bytes)" }, e.prototype.sizeInBytes = function () { return this.data.length }, e.prototype.copyBytesInto = function (n, r) { for (var i = this.data.length, s = 0; s < i; s++)n[r++] = this.data[s]; return i }, e.of = function (n) { return new e(n) }, e }(Nn), so; (function (t) { t[t.Deleted = 0] = "Deleted", t[t.Uncompressed = 1] = "Uncompressed", t[t.Compressed = 2] = "Compressed" })(so || (so = {})); var S3 = function (t) { we(e, t); function e(n, r, i) { i === void 0 && (i = !0); var s = t.call(this, n, i) || this; return s.computeIndex = function () { for (var a = [], u = 0, c = 0, f = s.entries.length; c < f; c++) { var h = s.entries[c], v = s.entries[c - 1]; c === 0 ? a.push(h.ref.objectNumber) : h.ref.objectNumber - v.ref.objectNumber > 1 && (a.push(u), a.push(h.ref.objectNumber), u = 0), u += 1 } return a.push(u), a }, s.computeEntryTuples = function () { for (var a = new Array(s.entries.length), u = 0, c = s.entries.length; u < c; u++) { var f = s.entries[u]; if (f.type === so.Deleted) { var h = f.type, v = f.nextFreeObjectNumber, m = f.ref; a[u] = [h, v, m.generationNumber] } if (f.type === so.Uncompressed) { var h = f.type, g = f.offset, m = f.ref; a[u] = [h, g, m.generationNumber] } if (f.type === so.Compressed) { var h = f.type, S = f.objectStreamRef, b = f.index; a[u] = [h, S.objectNumber, b] } } return a }, s.computeMaxEntryByteWidths = function () { for (var a = s.entryTuplesCache.access(), u = [0, 0, 0], c = 0, f = a.length; c < f; c++) { var h = a[c], v = h[0], m = h[1], g = h[2], S = Kc(v), b = Kc(m), P = Kc(g); S > u[0] && (u[0] = S), b > u[1] && (u[1] = b), P > u[2] && (u[2] = P) } return u }, s.entries = r || [], s.entryTuplesCache = ki.populatedBy(s.computeEntryTuples), s.maxByteWidthsCache = ki.populatedBy(s.computeMaxEntryByteWidths), s.indexCache = ki.populatedBy(s.computeIndex), n.set(O.of("Type"), O.of("XRef")), s } return e.prototype.addDeletedEntry = function (n, r) { var i = so.Deleted; this.entries.push({ type: i, ref: n, nextFreeObjectNumber: r }), this.entryTuplesCache.invalidate(), this.maxByteWidthsCache.invalidate(), this.indexCache.invalidate(), this.contentsCache.invalidate() }, e.prototype.addUncompressedEntry = function (n, r) { var i = so.Uncompressed; this.entries.push({ type: i, ref: n, offset: r }), this.entryTuplesCache.invalidate(), this.maxByteWidthsCache.invalidate(), this.indexCache.invalidate(), this.contentsCache.invalidate() }, e.prototype.addCompressedEntry = function (n, r, i) { var s = so.Compressed; this.entries.push({ type: s, ref: n, objectStreamRef: r, index: i }), this.entryTuplesCache.invalidate(), this.maxByteWidthsCache.invalidate(), this.indexCache.invalidate(), this.contentsCache.invalidate() }, e.prototype.clone = function (n) { var r = this, i = r.dict, s = r.entries, a = r.encode; return e.of(i.clone(n), s.slice(), a) }, e.prototype.getContentsString = function () { for (var n = this.entryTuplesCache.access(), r = this.maxByteWidthsCache.access(), i = "", s = 0, a = n.length; s < a; s++) { for (var u = n[s], c = u[0], f = u[1], h = u[2], v = Ds(Os(c)), m = Ds(Os(f)), g = Ds(Os(h)), S = r[0] - 1; S >= 0; S--)i += (v[S] || 0).toString(2); for (var S = r[1] - 1; S >= 0; S--)i += (m[S] || 0).toString(2); for (var S = r[2] - 1; S >= 0; S--)i += (g[S] || 0).toString(2) } return i }, e.prototype.getUnencodedContents = function () { for (var n = this.entryTuplesCache.access(), r = this.maxByteWidthsCache.access(), i = new Uint8Array(this.getUnencodedContentsSize()), s = 0, a = 0, u = n.length; a < u; a++) { for (var c = n[a], f = c[0], h = c[1], v = c[2], m = Ds(Os(f)), g = Ds(Os(h)), S = Ds(Os(v)), b = r[0] - 1; b >= 0; b--)i[s++] = m[b] || 0; for (var b = r[1] - 1; b >= 0; b--)i[s++] = g[b] || 0; for (var b = r[2] - 1; b >= 0; b--)i[s++] = S[b] || 0 } return i }, e.prototype.getUnencodedContentsSize = function () { var n = this.maxByteWidthsCache.access(), r = rM(n); return r * this.entries.length }, e.prototype.updateDict = function () { t.prototype.updateDict.call(this); var n = this.maxByteWidthsCache.access(), r = this.indexCache.access(), i = this.dict.context; this.dict.set(O.of("W"), i.obj(n)), this.dict.set(O.of("Index"), i.obj(r)) }, e.create = function (n, r) { r === void 0 && (r = !0); var i = new e(n, [], r); return i.addDeletedEntry(wt.of(0, 65535), 0), i }, e.of = function (n, r, i) { return i === void 0 && (i = !0), new e(n, r, i) }, e }(Nv), b3 = function (t) { we(e, t); function e(n, r, i, s) { var a = t.call(this, n, r) || this; return a.encodeStreams = i, a.objectsPerStream = s, a } return e.prototype.computeBufferSize = function () { return tt(this, void 0, void 0, function () { var n, r, i, s, a, u, c, f, S, b, h, C, v, m, P, g, S, b, P, C, F, A, N, D; return nt(this, function (V) { switch (V.label) { case 0: n = this.context.largestObjectNumber + 1, r = Wf.forVersion(1, 7), i = r.sizeInBytes() + 2, s = S3.create(this.createTrailerDict(), this.encodeStreams), a = [], u = [], c = [], f = this.context.enumerateIndirectObjects(), S = 0, b = f.length, V.label = 1; case 1: return S < b ? (h = f[S], C = h[0], v = h[1], m = C === this.context.trailerInfo.Encrypt || v instanceof or || v instanceof xP || C.generationNumber !== 0, m ? (a.push(h), s.addUncompressedEntry(C, i), i += this.computeIndirectObjectSize(h), this.shouldWaitForTick(1) ? [4, na()] : [3, 3]) : [3, 4]) : [3, 6]; case 2: V.sent(), V.label = 3; case 3: return [3, 5]; case 4: P = uf(u), g = uf(c), (!P || P.length % this.objectsPerStream === 0) && (P = [], u.push(P), g = wt.of(n++), c.push(g)), s.addCompressedEntry(C, g, P.length), P.push(h), V.label = 5; case 5: return S++, [3, 1]; case 6: S = 0, b = u.length, V.label = 7; case 7: return S < b ? (P = u[S], C = c[S], F = gP.withContextAndObjects(this.context, P, this.encodeStreams), s.addUncompressedEntry(C, i), i += this.computeIndirectObjectSize([C, F]), a.push([C, F]), this.shouldWaitForTick(P.length) ? [4, na()] : [3, 9]) : [3, 10]; case 8: V.sent(), V.label = 9; case 9: return S++, [3, 7]; case 10: return A = wt.of(n++), s.dict.set(O.of("Size"), Xe.of(n)), s.addUncompressedEntry(A, i), N = i, i += this.computeIndirectObjectSize([A, s]), a.push([A, s]), D = Bv.forLastCrossRefSectionOffset(N), i += D.sizeInBytes(), [2, { size: i, header: r, indirectObjects: a, trailer: D }] } }) }) }, e.forContext = function (n, r, i, s) { return i === void 0 && (i = !0), s === void 0 && (s = 50), new e(n, r, i, s) }, e }(yP), qe = function (t) { we(e, t); function e(n) { var r = t.call(this) || this; return r.value = n, r } return e.prototype.asBytes = function () { for (var n = this.value + (this.value.length % 2 === 1 ? "0" : ""), r = n.length, i = new Uint8Array(n.length / 2), s = 0, a = 0; s < r;) { var u = parseInt(n.substring(s, s + 2), 16); i[a] = u, s += 2, a += 1 } return i }, e.prototype.decodeText = function () { var n = this.asBytes(); return oP(n) ? nP(n) : pP(n) }, e.prototype.decodeDate = function () { var n = this.decodeText(), r = _C(n); if (!r) throw new vP(n); return r }, e.prototype.asString = function () { return this.value }, e.prototype.clone = function () { return e.of(this.value) }, e.prototype.toString = function () { return "<" + this.value + ">" }, e.prototype.sizeInBytes = function () { return this.value.length + 2 }, e.prototype.copyBytesInto = function (n, r) { return n[r++] = M.LessThan, r += wn(this.value, n, r), n[r++] = M.GreaterThan, this.value.length + 2 }, e.of = function (n) { return new e(n) }, e.fromText = function (n) { for (var r = aM(n), i = "", s = 0, a = r.length; s < a; s++)i += nu(r[s], 4); return new e(i) }, e }(Nn), df = function () { function t(e, n) { this.encoding = e === Il.ZapfDingbats ? kc.ZapfDingbats : e === Il.Symbol ? kc.Symbol : kc.WinAnsi, this.font = UM.load(e), this.fontName = this.font.FontName, this.customName = n } return t.prototype.encodeText = function (e) { for (var n = this.encodeTextAsGlyphs(e), r = new Array(n.length), i = 0, s = n.length; i < s; i++)r[i] = jf(n[i].code); return qe.of(r.join("")) }, t.prototype.widthOfTextAtSize = function (e, n) { for (var r = this.encodeTextAsGlyphs(e), i = 0, s = 0, a = r.length; s < a; s++) { var u = r[s].name, c = (r[s + 1] || {}).name, f = this.font.getXAxisKerningForPair(u, c) || 0; i += this.widthOfGlyph(u) + f } var h = n / 1e3; return i * h }, t.prototype.heightOfFontAtSize = function (e, n) { n === void 0 && (n = {}); var r = n.descender, i = r === void 0 ? !0 : r, s = this.font, a = s.Ascender, u = s.Descender, c = s.FontBBox, f = a || c[3], h = u || c[1], v = f - h; return i || (v += u || 0), v / 1e3 * e }, t.prototype.sizeOfFontAtHeight = function (e) { var n = this.font, r = n.Ascender, i = n.Descender, s = n.FontBBox, a = r || s[3], u = i || s[1]; return 1e3 * e / (a - u) }, t.prototype.embedIntoContext = function (e, n) { var r = e.obj({ Type: "Font", Subtype: "Type1", BaseFont: this.customName || this.fontName, Encoding: this.encoding === kc.WinAnsi ? "WinAnsiEncoding" : void 0 }); return n ? (e.assign(n, r), n) : e.register(r) }, t.prototype.widthOfGlyph = function (e) { return this.font.getWidthOfGlyph(e) || 250 }, t.prototype.encodeTextAsGlyphs = function (e) { for (var n = Array.from(e), r = new Array(n.length), i = 0, s = n.length; i < s; i++) { var a = qO(n[i]); r[i] = this.encoding.encodeUnicodeCodePoint(a) } return r }, t.for = function (e, n) { return new t(e, n) }, t }(), C3 = function (t, e) { for (var n = new Array(t.length), r = 0, i = t.length; r < i; r++) { var s = t[r], a = ww(Hc(e(s))), u = ww.apply(void 0, s.codePoints.map(T3)); n[r] = [a, u] } return P3(n) }, P3 = function (t) {
  return `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange
`+ t.length + ` beginbfchar
`+ t.map(function (e) { var n = e[0], r = e[1]; return n + " " + r }).join(`
`) + `
endbfchar
endcmap
CMapName currentdict /CMap defineresource pop
end
end`}, ww = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return "<" + t.join("") + ">" }, Hc = function (t) { return nu(t, 4) }, T3 = function (t) { if (lM(t)) return Hc(t); if (uM(t)) { var e = eP(t), n = tP(t); return "" + Hc(e) + Hc(n) } var r = jf(t), i = "0x" + r + " is not a valid UTF-8 or UTF-16 codepoint."; throw new Error(i) }, k3 = function (t) { var e = 0, n = function (r) { e |= 1 << r - 1 }; return t.fixedPitch && n(1), t.serif && n(2), n(3), t.script && n(4), t.nonsymbolic && n(6), t.italic && n(7), t.allCap && n(17), t.smallCap && n(18), t.forceBold && n(19), e }, A3 = function (t) { var e = t["OS/2"] ? t["OS/2"].sFamilyClass : 0, n = k3({ fixedPitch: t.post.isFixedPitch, serif: 1 <= e && e <= 7, symbolic: !0, script: e === 10, italic: t.head.macStyle.italic }); return n }, xt = function (t) { we(e, t); function e(n) { var r = t.call(this) || this; return r.value = n, r } return e.prototype.asBytes = function () { for (var n = [], r = "", i = !1, s = function (v) { v !== void 0 && n.push(v), i = !1 }, a = 0, u = this.value.length; a < u; a++) { var c = this.value[a], f = Qe(c), h = this.value[a + 1]; i ? f === M.Newline || f === M.CarriageReturn ? s() : f === M.n ? s(M.Newline) : f === M.r ? s(M.CarriageReturn) : f === M.t ? s(M.Tab) : f === M.b ? s(M.Backspace) : f === M.f ? s(M.FormFeed) : f === M.LeftParen ? s(M.LeftParen) : f === M.RightParen ? s(M.RightParen) : f === M.Backspace ? s(M.BackSlash) : f >= M.Zero && f <= M.Seven ? (r += c, (r.length === 3 || !(h >= "0" && h <= "7")) && (s(parseInt(r, 8)), r = "")) : s(f) : f === M.BackSlash ? i = !0 : s(f) } return new Uint8Array(n) }, e.prototype.decodeText = function () { var n = this.asBytes(); return oP(n) ? nP(n) : pP(n) }, e.prototype.decodeDate = function () { var n = this.decodeText(), r = _C(n); if (!r) throw new vP(n); return r }, e.prototype.asString = function () { return this.value }, e.prototype.clone = function () { return e.of(this.value) }, e.prototype.toString = function () { return "(" + this.value + ")" }, e.prototype.sizeInBytes = function () { return this.value.length + 2 }, e.prototype.copyBytesInto = function (n, r) { return n[r++] = M.LeftParen, r += wn(this.value, n, r), n[r++] = M.RightParen, this.value.length + 2 }, e.of = function (n) { return new e(n) }, e.fromDate = function (n) { var r = qr(String(n.getUTCFullYear()), 4, "0"), i = qr(String(n.getUTCMonth() + 1), 2, "0"), s = qr(String(n.getUTCDate()), 2, "0"), a = qr(String(n.getUTCHours()), 2, "0"), u = qr(String(n.getUTCMinutes()), 2, "0"), c = qr(String(n.getUTCSeconds()), 2, "0"); return new e("D:" + r + i + s + a + u + c + "Z") }, e }(Nn), Lv = function () { function t(e, n, r, i) { var s = this; this.allGlyphsInFontSortedById = function () { for (var a = new Array(s.font.characterSet.length), u = 0, c = a.length; u < c; u++) { var f = s.font.characterSet[u]; a[u] = s.font.glyphForCodePoint(f) } return nM(a.sort(tM), function (h) { return h.id }) }, this.font = e, this.scale = 1e3 / this.font.unitsPerEm, this.fontData = n, this.fontName = this.font.postscriptName || "Font", this.customName = r, this.fontFeatures = i, this.baseFontName = "", this.glyphCache = ki.populatedBy(this.allGlyphsInFontSortedById) } return t.for = function (e, n, r, i) { return tt(this, void 0, void 0, function () { var s; return nt(this, function (a) { switch (a.label) { case 0: return [4, e.create(n)]; case 1: return s = a.sent(), [2, new t(s, n, r, i)] } }) }) }, t.prototype.encodeText = function (e) { for (var n = this.font.layout(e, this.fontFeatures).glyphs, r = new Array(n.length), i = 0, s = n.length; i < s; i++)r[i] = nu(n[i].id, 4); return qe.of(r.join("")) }, t.prototype.widthOfTextAtSize = function (e, n) { for (var r = this.font.layout(e, this.fontFeatures).glyphs, i = 0, s = 0, a = r.length; s < a; s++)i += r[s].advanceWidth * this.scale; var u = n / 1e3; return i * u }, t.prototype.heightOfFontAtSize = function (e, n) { n === void 0 && (n = {}); var r = n.descender, i = r === void 0 ? !0 : r, s = this.font, a = s.ascent, u = s.descent, c = s.bbox, f = (a || c.maxY) * this.scale, h = (u || c.minY) * this.scale, v = f - h; return i || (v -= Math.abs(u) || 0), v / 1e3 * e }, t.prototype.sizeOfFontAtHeight = function (e) { var n = this.font, r = n.ascent, i = n.descent, s = n.bbox, a = (r || s.maxY) * this.scale, u = (i || s.minY) * this.scale; return 1e3 * e / (a - u) }, t.prototype.embedIntoContext = function (e, n) { return this.baseFontName = this.customName || e.addRandomSuffix(this.fontName), this.embedFontDict(e, n) }, t.prototype.embedFontDict = function (e, n) { return tt(this, void 0, void 0, function () { var r, i, s; return nt(this, function (a) { switch (a.label) { case 0: return [4, this.embedCIDFontDict(e)]; case 1: return r = a.sent(), i = this.embedUnicodeCmap(e), s = e.obj({ Type: "Font", Subtype: "Type0", BaseFont: this.baseFontName, Encoding: "Identity-H", DescendantFonts: [r], ToUnicode: i }), n ? (e.assign(n, s), [2, n]) : [2, e.register(s)] } }) }) }, t.prototype.isCFF = function () { return this.font.cff }, t.prototype.embedCIDFontDict = function (e) { return tt(this, void 0, void 0, function () { var n, r; return nt(this, function (i) { switch (i.label) { case 0: return [4, this.embedFontDescriptor(e)]; case 1: return n = i.sent(), r = e.obj({ Type: "Font", Subtype: this.isCFF() ? "CIDFontType0" : "CIDFontType2", CIDToGIDMap: "Identity", BaseFont: this.baseFontName, CIDSystemInfo: { Registry: xt.of("Adobe"), Ordering: xt.of("Identity"), Supplement: 0 }, FontDescriptor: n, W: this.computeWidths() }), [2, e.register(r)] } }) }) }, t.prototype.embedFontDescriptor = function (e) { return tt(this, void 0, void 0, function () { var n, r, i, s, a, u, c, f, h, v, m, g, S, b, P; return nt(this, function (C) { switch (C.label) { case 0: return [4, this.embedFontStream(e)]; case 1: return n = C.sent(), r = this.scale, i = this.font, s = i.italicAngle, a = i.ascent, u = i.descent, c = i.capHeight, f = i.xHeight, h = this.font.bbox, v = h.minX, m = h.minY, g = h.maxX, S = h.maxY, b = e.obj((P = { Type: "FontDescriptor", FontName: this.baseFontName, Flags: A3(this.font), FontBBox: [v * r, m * r, g * r, S * r], ItalicAngle: s, Ascent: a * r, Descent: u * r, CapHeight: (c || a) * r, XHeight: (f || 0) * r, StemV: 0 }, P[this.isCFF() ? "FontFile3" : "FontFile2"] = n, P)), [2, e.register(b)] } }) }) }, t.prototype.serializeFont = function () { return tt(this, void 0, void 0, function () { return nt(this, function (e) { return [2, this.fontData] }) }) }, t.prototype.embedFontStream = function (e) { return tt(this, void 0, void 0, function () { var n, r, i; return nt(this, function (s) { switch (s.label) { case 0: return i = (r = e).flateStream, [4, this.serializeFont()]; case 1: return n = i.apply(r, [s.sent(), { Subtype: this.isCFF() ? "CIDFontType0C" : void 0 }]), [2, e.register(n)] } }) }) }, t.prototype.embedUnicodeCmap = function (e) { var n = C3(this.glyphCache.access(), this.glyphId.bind(this)), r = e.flateStream(n); return e.register(r) }, t.prototype.glyphId = function (e) { return e ? e.id : -1 }, t.prototype.computeWidths = function () { for (var e = this.glyphCache.access(), n = [], r = [], i = 0, s = e.length; i < s; i++) { var a = e[i], u = e[i - 1], c = this.glyphId(a), f = this.glyphId(u); i === 0 ? n.push(c) : c - f !== 1 && (n.push(r), n.push(c), r = []), r.push(a.advanceWidth * this.scale) } return n.push(r), n }, t }(), E3 = function (t) { we(e, t); function e(n, r, i, s) { var a = t.call(this, n, r, i, s) || this; return a.subset = a.font.createSubset(), a.glyphs = [], a.glyphCache = ki.populatedBy(function () { return a.glyphs }), a.glyphIdMap = new Map, a } return e.for = function (n, r, i, s) { return tt(this, void 0, void 0, function () { var a; return nt(this, function (u) { switch (u.label) { case 0: return [4, n.create(r)]; case 1: return a = u.sent(), [2, new e(a, r, i, s)] } }) }) }, e.prototype.encodeText = function (n) { for (var r = this.font.layout(n, this.fontFeatures).glyphs, i = new Array(r.length), s = 0, a = r.length; s < a; s++) { var u = r[s], c = this.subset.includeGlyph(u); this.glyphs[c - 1] = u, this.glyphIdMap.set(u.id, c), i[s] = nu(c, 4) } return this.glyphCache.invalidate(), qe.of(i.join("")) }, e.prototype.isCFF = function () { return this.subset.cff }, e.prototype.glyphId = function (n) { return n ? this.glyphIdMap.get(n.id) : -1 }, e.prototype.serializeFont = function () { var n = this; return new Promise(function (r, i) { var s = []; n.subset.encodeStream().on("data", function (a) { return s.push(a) }).on("end", function () { return r(eM(s)) }).on("error", function (a) { return i(a) }) }) }, e }(Lv), v0; (function (t) { t.Source = "Source", t.Data = "Data", t.Alternative = "Alternative", t.Supplement = "Supplement", t.EncryptedPayload = "EncryptedPayload", t.FormData = "EncryptedPayload", t.Schema = "Schema", t.Unspecified = "Unspecified" })(v0 || (v0 = {})); var F3 = function () { function t(e, n, r) { r === void 0 && (r = {}), this.fileData = e, this.fileName = n, this.options = r } return t.for = function (e, n, r) { return r === void 0 && (r = {}), new t(e, n, r) }, t.prototype.embedIntoContext = function (e, n) { return tt(this, void 0, void 0, function () { var r, i, s, a, u, c, f, h, v; return nt(this, function (m) { return r = this.options, i = r.mimeType, s = r.description, a = r.creationDate, u = r.modificationDate, c = r.afRelationship, f = e.flateStream(this.fileData, { Type: "EmbeddedFile", Subtype: i ?? void 0, Params: { Size: this.fileData.length, CreationDate: a ? xt.fromDate(a) : void 0, ModDate: u ? xt.fromDate(u) : void 0 } }), h = e.register(f), v = e.obj({ Type: "Filespec", F: xt.of(this.fileName), UF: qe.fromText(this.fileName), EF: { F: h }, Desc: s ? qe.fromText(s) : void 0, AFRelationship: c ?? void 0 }), n ? (e.assign(n, v), [2, n]) : [2, e.register(v)] }) }) }, t }(), Sw = [65472, 65473, 65474, 65475, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487], Js; (function (t) { t.DeviceGray = "DeviceGray", t.DeviceRGB = "DeviceRGB", t.DeviceCMYK = "DeviceCMYK" })(Js || (Js = {})); var R3 = { 1: Js.DeviceGray, 3: Js.DeviceRGB, 4: Js.DeviceCMYK }, wP = function () { function t(e, n, r, i, s) { this.imageData = e, this.bitsPerComponent = n, this.width = r, this.height = i, this.colorSpace = s } return t.for = function (e) { return tt(this, void 0, void 0, function () { var n, r, i, s, a, u, c, f, h, v; return nt(this, function (m) { if (n = new DataView(e.buffer), r = n.getUint16(0), r !== 65496) throw new Error("SOI not found in JPEG"); for (i = 2; i < n.byteLength && (s = n.getUint16(i), i += 2, !Sw.includes(s));)i += n.getUint16(i); if (!Sw.includes(s)) throw new Error("Invalid JPEG"); if (i += 2, a = n.getUint8(i++), u = n.getUint16(i), i += 2, c = n.getUint16(i), i += 2, f = n.getUint8(i++), h = R3[f], !h) throw new Error("Unknown JPEG channel."); return v = h, [2, new t(e, a, c, u, v)] }) }) }, t.prototype.embedIntoContext = function (e, n) { return tt(this, void 0, void 0, function () { var r; return nt(this, function (i) { return r = e.stream(this.imageData, { Type: "XObject", Subtype: "Image", BitsPerComponent: this.bitsPerComponent, Width: this.width, Height: this.height, ColorSpace: this.colorSpace, Filter: "DCTDecode", Decode: this.colorSpace === Js.DeviceCMYK ? [1, 0, 1, 0, 1, 0, 1, 0] : void 0 }), n ? (e.assign(n, r), [2, n]) : [2, e.register(r)] }) }) }, t }(), pe = {}; pe.toRGBA8 = function (t) { var e = t.width, n = t.height; if (t.tabs.acTL == null) return [pe.toRGBA8.decodeImage(t.data, e, n, t).buffer]; var r = []; t.frames[0].data == null && (t.frames[0].data = t.data); for (var i = e * n * 4, s = new Uint8Array(i), a = new Uint8Array(i), u = new Uint8Array(i), c = 0; c < t.frames.length; c++) { var f = t.frames[c], h = f.rect.x, v = f.rect.y, m = f.rect.width, g = f.rect.height, S = pe.toRGBA8.decodeImage(f.data, m, g, t); if (c != 0) for (var b = 0; b < i; b++)u[b] = s[b]; if (f.blend == 0 ? pe._copyTile(S, m, g, s, e, n, h, v, 0) : f.blend == 1 && pe._copyTile(S, m, g, s, e, n, h, v, 1), r.push(s.buffer.slice(0)), f.dispose != 0) { if (f.dispose == 1) pe._copyTile(a, m, g, s, e, n, h, v, 0); else if (f.dispose == 2) for (var b = 0; b < i; b++)s[b] = u[b] } } return r }; pe.toRGBA8.decodeImage = function (t, e, n, r) { var i = e * n, s = pe.decode._getBPP(r), a = Math.ceil(e * s / 8), u = new Uint8Array(i * 4), c = new Uint32Array(u.buffer), f = r.ctype, h = r.depth, v = pe._bin.readUshort; if (f == 6) { var m = i << 2; if (h == 8) for (var g = 0; g < m; g += 4)u[g] = t[g], u[g + 1] = t[g + 1], u[g + 2] = t[g + 2], u[g + 3] = t[g + 3]; if (h == 16) for (var g = 0; g < m; g++)u[g] = t[g << 1] } else if (f == 2) { var S = r.tabs.tRNS; if (S == null) { if (h == 8) for (var g = 0; g < i; g++) { var b = g * 3; c[g] = 255 << 24 | t[b + 2] << 16 | t[b + 1] << 8 | t[b] } if (h == 16) for (var g = 0; g < i; g++) { var b = g * 6; c[g] = 255 << 24 | t[b + 4] << 16 | t[b + 2] << 8 | t[b] } } else { var P = S[0], C = S[1], F = S[2]; if (h == 8) for (var g = 0; g < i; g++) { var A = g << 2, b = g * 3; c[g] = 255 << 24 | t[b + 2] << 16 | t[b + 1] << 8 | t[b], t[b] == P && t[b + 1] == C && t[b + 2] == F && (u[A + 3] = 0) } if (h == 16) for (var g = 0; g < i; g++) { var A = g << 2, b = g * 6; c[g] = 255 << 24 | t[b + 4] << 16 | t[b + 2] << 8 | t[b], v(t, b) == P && v(t, b + 2) == C && v(t, b + 4) == F && (u[A + 3] = 0) } } } else if (f == 3) { var N = r.tabs.PLTE, D = r.tabs.tRNS, V = D ? D.length : 0; if (h == 1) for (var B = 0; B < n; B++)for (var I = B * a, Y = B * e, g = 0; g < e; g++) { var A = Y + g << 2, Z = t[I + (g >> 3)] >> 7 - ((g & 7) << 0) & 1, ie = 3 * Z; u[A] = N[ie], u[A + 1] = N[ie + 1], u[A + 2] = N[ie + 2], u[A + 3] = Z < V ? D[Z] : 255 } if (h == 2) for (var B = 0; B < n; B++)for (var I = B * a, Y = B * e, g = 0; g < e; g++) { var A = Y + g << 2, Z = t[I + (g >> 2)] >> 6 - ((g & 3) << 1) & 3, ie = 3 * Z; u[A] = N[ie], u[A + 1] = N[ie + 1], u[A + 2] = N[ie + 2], u[A + 3] = Z < V ? D[Z] : 255 } if (h == 4) for (var B = 0; B < n; B++)for (var I = B * a, Y = B * e, g = 0; g < e; g++) { var A = Y + g << 2, Z = t[I + (g >> 1)] >> 4 - ((g & 1) << 2) & 15, ie = 3 * Z; u[A] = N[ie], u[A + 1] = N[ie + 1], u[A + 2] = N[ie + 2], u[A + 3] = Z < V ? D[Z] : 255 } if (h == 8) for (var g = 0; g < i; g++) { var A = g << 2, Z = t[g], ie = 3 * Z; u[A] = N[ie], u[A + 1] = N[ie + 1], u[A + 2] = N[ie + 2], u[A + 3] = Z < V ? D[Z] : 255 } } else if (f == 4) { if (h == 8) for (var g = 0; g < i; g++) { var A = g << 2, se = g << 1, q = t[se]; u[A] = q, u[A + 1] = q, u[A + 2] = q, u[A + 3] = t[se + 1] } if (h == 16) for (var g = 0; g < i; g++) { var A = g << 2, se = g << 2, q = t[se]; u[A] = q, u[A + 1] = q, u[A + 2] = q, u[A + 3] = t[se + 2] } } else if (f == 0) for (var P = r.tabs.tRNS ? r.tabs.tRNS : -1, B = 0; B < n; B++) { var ue = B * a, ye = B * e; if (h == 1) for (var ae = 0; ae < e; ae++) { var q = 255 * (t[ue + (ae >>> 3)] >>> 7 - (ae & 7) & 1), _ = q == P * 255 ? 0 : 255; c[ye + ae] = _ << 24 | q << 16 | q << 8 | q } else if (h == 2) for (var ae = 0; ae < e; ae++) { var q = 85 * (t[ue + (ae >>> 2)] >>> 6 - ((ae & 3) << 1) & 3), _ = q == P * 85 ? 0 : 255; c[ye + ae] = _ << 24 | q << 16 | q << 8 | q } else if (h == 4) for (var ae = 0; ae < e; ae++) { var q = 17 * (t[ue + (ae >>> 1)] >>> 4 - ((ae & 1) << 2) & 15), _ = q == P * 17 ? 0 : 255; c[ye + ae] = _ << 24 | q << 16 | q << 8 | q } else if (h == 8) for (var ae = 0; ae < e; ae++) { var q = t[ue + ae], _ = q == P ? 0 : 255; c[ye + ae] = _ << 24 | q << 16 | q << 8 | q } else if (h == 16) for (var ae = 0; ae < e; ae++) { var q = t[ue + (ae << 1)], _ = v(t, ue + (ae << g)) == P ? 0 : 255; c[ye + ae] = _ << 24 | q << 16 | q << 8 | q } } return u }; pe.decode = function (t) { for (var e = new Uint8Array(t), n = 8, r = pe._bin, i = r.readUshort, s = r.readUint, a = { tabs: {}, frames: [] }, u = new Uint8Array(e.length), c = 0, f, h = 0, v = [137, 80, 78, 71, 13, 10, 26, 10], m = 0; m < 8; m++)if (e[m] != v[m]) throw "The input is not a PNG file!"; for (; n < e.length;) { var g = r.readUint(e, n); n += 4; var S = r.readASCII(e, n, 4); if (n += 4, S == "IHDR") pe.decode._IHDR(e, n, a); else if (S == "IDAT") { for (var m = 0; m < g; m++)u[c + m] = e[n + m]; c += g } else if (S == "acTL") a.tabs[S] = { num_frames: s(e, n), num_plays: s(e, n + 4) }, f = new Uint8Array(e.length); else if (S == "fcTL") { if (h != 0) { var b = a.frames[a.frames.length - 1]; b.data = pe.decode._decompress(a, f.slice(0, h), b.rect.width, b.rect.height), h = 0 } var P = { x: s(e, n + 12), y: s(e, n + 16), width: s(e, n + 4), height: s(e, n + 8) }, C = i(e, n + 22); C = i(e, n + 20) / (C == 0 ? 100 : C); var F = { rect: P, delay: Math.round(C * 1e3), dispose: e[n + 24], blend: e[n + 25] }; a.frames.push(F) } else if (S == "fdAT") { for (var m = 0; m < g - 4; m++)f[h + m] = e[n + m + 4]; h += g - 4 } else if (S == "pHYs") a.tabs[S] = [r.readUint(e, n), r.readUint(e, n + 4), e[n + 8]]; else if (S == "cHRM") { a.tabs[S] = []; for (var m = 0; m < 8; m++)a.tabs[S].push(r.readUint(e, n + m * 4)) } else if (S == "tEXt") { a.tabs[S] == null && (a.tabs[S] = {}); var A = r.nextZero(e, n), N = r.readASCII(e, n, A - n), D = r.readASCII(e, A + 1, n + g - A - 1); a.tabs[S][N] = D } else if (S == "iTXt") { a.tabs[S] == null && (a.tabs[S] = {}); var A = 0, V = n; A = r.nextZero(e, V); var N = r.readASCII(e, V, A - V); V = A + 1, e[V], e[V + 1], V += 2, A = r.nextZero(e, V), r.readASCII(e, V, A - V), V = A + 1, A = r.nextZero(e, V), r.readUTF8(e, V, A - V), V = A + 1; var D = r.readUTF8(e, V, g - (V - n)); a.tabs[S][N] = D } else if (S == "PLTE") a.tabs[S] = r.readBytes(e, n, g); else if (S == "hIST") { var B = a.tabs.PLTE.length / 3; a.tabs[S] = []; for (var m = 0; m < B; m++)a.tabs[S].push(i(e, n + m * 2)) } else if (S == "tRNS") a.ctype == 3 ? a.tabs[S] = r.readBytes(e, n, g) : a.ctype == 0 ? a.tabs[S] = i(e, n) : a.ctype == 2 && (a.tabs[S] = [i(e, n), i(e, n + 2), i(e, n + 4)]); else if (S == "gAMA") a.tabs[S] = r.readUint(e, n) / 1e5; else if (S == "sRGB") a.tabs[S] = e[n]; else if (S == "bKGD") a.ctype == 0 || a.ctype == 4 ? a.tabs[S] = [i(e, n)] : a.ctype == 2 || a.ctype == 6 ? a.tabs[S] = [i(e, n), i(e, n + 2), i(e, n + 4)] : a.ctype == 3 && (a.tabs[S] = e[n]); else if (S == "IEND") break; n += g, r.readUint(e, n), n += 4 } if (h != 0) { var b = a.frames[a.frames.length - 1]; b.data = pe.decode._decompress(a, f.slice(0, h), b.rect.width, b.rect.height), h = 0 } return a.data = pe.decode._decompress(a, u, a.width, a.height), delete a.compress, delete a.interlace, delete a.filter, a }; pe.decode._decompress = function (t, e, n, r) { var i = pe.decode._getBPP(t), s = Math.ceil(n * i / 8), a = new Uint8Array((s + 1 + t.interlace) * r); return e = pe.decode._inflate(e, a), t.interlace == 0 ? e = pe.decode._filterZero(e, t, 0, n, r) : t.interlace == 1 && (e = pe.decode._readInterlace(e, t)), e }; pe.decode._inflate = function (t, e) { var n = pe.inflateRaw(new Uint8Array(t.buffer, 2, t.length - 6), e); return n }; pe.inflateRaw = function () { var t = {}; return t.H = {}, t.H.N = function (e, n) { var r = Uint8Array, i = 0, s = 0, a = 0, u = 0, c = 0, f = 0, h = 0, v = 0, m = 0, g, S; if (e[0] == 3 && e[1] == 0) return n || new r(0); var b = t.H, P = b.b, C = b.e, F = b.R, A = b.n, N = b.A, D = b.Z, V = b.m, B = n == null; for (B && (n = new r(e.length >>> 2 << 3)); i == 0;) { if (i = P(e, m, 1), s = P(e, m + 1, 2), m += 3, s == 0) { m & 7 && (m += 8 - (m & 7)); var I = (m >>> 3) + 4, Y = e[I - 4] | e[I - 3] << 8; B && (n = t.H.W(n, v + Y)), n.set(new r(e.buffer, e.byteOffset + I, Y), v), m = I + Y << 3, v += Y; continue } if (B && (n = t.H.W(n, v + (1 << 17))), s == 1 && (g = V.J, S = V.h, f = 511, h = 31), s == 2) { a = C(e, m, 5) + 257, u = C(e, m + 5, 5) + 1, c = C(e, m + 10, 4) + 4, m += 14; for (var Z = 1, ie = 0; ie < 38; ie += 2)V.Q[ie] = 0, V.Q[ie + 1] = 0; for (var ie = 0; ie < c; ie++) { var se = C(e, m + ie * 3, 3); V.Q[(V.X[ie] << 1) + 1] = se, se > Z && (Z = se) } m += 3 * c, A(V.Q, Z), N(V.Q, Z, V.u), g = V.w, S = V.d, m = F(V.u, (1 << Z) - 1, a + u, e, m, V.v); var q = b.V(V.v, 0, a, V.C); f = (1 << q) - 1; var ue = b.V(V.v, a, u, V.D); h = (1 << ue) - 1, A(V.C, q), N(V.C, q, g), A(V.D, ue), N(V.D, ue, S) } for (; ;) { var ye = g[D(e, m) & f]; m += ye & 15; var ae = ye >>> 4; if (!(ae >>> 8)) n[v++] = ae; else { if (ae == 256) break; var _ = v + ae - 254; if (ae > 264) { var Q = V.q[ae - 257]; _ = v + (Q >>> 3) + C(e, m, Q & 7), m += Q & 7 } var le = S[D(e, m) & h]; m += le & 15; var ce = le >>> 4, W = V.c[ce], re = (W >>> 4) + P(e, m, W & 15); for (m += W & 15; v < _;)n[v] = n[v++ - re], n[v] = n[v++ - re], n[v] = n[v++ - re], n[v] = n[v++ - re]; v = _ } } } return n.length == v ? n : n.slice(0, v) }, t.H.W = function (e, n) { var r = e.length; if (n <= r) return e; var i = new Uint8Array(r << 1); return i.set(e, 0), i }, t.H.R = function (e, n, r, i, s, a) { for (var u = t.H.e, c = t.H.Z, f = 0; f < r;) { var h = e[c(i, s) & n]; s += h & 15; var v = h >>> 4; if (v <= 15) a[f] = v, f++; else { var m = 0, g = 0; v == 16 ? (g = 3 + u(i, s, 2), s += 2, m = a[f - 1]) : v == 17 ? (g = 3 + u(i, s, 3), s += 3) : v == 18 && (g = 11 + u(i, s, 7), s += 7); for (var S = f + g; f < S;)a[f] = m, f++ } } return s }, t.H.V = function (e, n, r, i) { for (var s = 0, a = 0, u = i.length >>> 1; a < r;) { var c = e[a + n]; i[a << 1] = 0, i[(a << 1) + 1] = c, c > s && (s = c), a++ } for (; a < u;)i[a << 1] = 0, i[(a << 1) + 1] = 0, a++; return s }, t.H.n = function (e, n) { for (var r = t.H.m, i = e.length, s, a, u, c, f, h = r.j, c = 0; c <= n; c++)h[c] = 0; for (c = 1; c < i; c += 2)h[e[c]]++; var v = r.K; for (s = 0, h[0] = 0, a = 1; a <= n; a++)s = s + h[a - 1] << 1, v[a] = s; for (u = 0; u < i; u += 2)f = e[u + 1], f != 0 && (e[u] = v[f], v[f]++) }, t.H.A = function (e, n, r) { for (var i = e.length, s = t.H.m, a = s.r, u = 0; u < i; u += 2)if (e[u + 1] != 0) for (var c = u >> 1, f = e[u + 1], h = c << 4 | f, v = n - f, m = e[u] << v, g = m + (1 << v); m != g;) { var S = a[m] >>> 15 - n; r[S] = h, m++ } }, t.H.l = function (e, n) { for (var r = t.H.m.r, i = 15 - n, s = 0; s < e.length; s += 2) { var a = e[s] << n - e[s + 1]; e[s] = r[a] >>> i } }, t.H.M = function (e, n, r) { r = r << (n & 7); var i = n >>> 3; e[i] |= r, e[i + 1] |= r >>> 8 }, t.H.I = function (e, n, r) { r = r << (n & 7); var i = n >>> 3; e[i] |= r, e[i + 1] |= r >>> 8, e[i + 2] |= r >>> 16 }, t.H.e = function (e, n, r) { return (e[n >>> 3] | e[(n >>> 3) + 1] << 8) >>> (n & 7) & (1 << r) - 1 }, t.H.b = function (e, n, r) { return (e[n >>> 3] | e[(n >>> 3) + 1] << 8 | e[(n >>> 3) + 2] << 16) >>> (n & 7) & (1 << r) - 1 }, t.H.Z = function (e, n) { return (e[n >>> 3] | e[(n >>> 3) + 1] << 8 | e[(n >>> 3) + 2] << 16) >>> (n & 7) }, t.H.i = function (e, n) { return (e[n >>> 3] | e[(n >>> 3) + 1] << 8 | e[(n >>> 3) + 2] << 16 | e[(n >>> 3) + 3] << 24) >>> (n & 7) }, t.H.m = function () { var e = Uint16Array, n = Uint32Array; return { K: new e(16), j: new e(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new e(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new n(32), J: new e(512), _: [], h: new e(32), $: [], w: new e(32768), C: [], v: [], d: new e(32768), D: [], u: new e(512), Q: [], r: new e(32768), s: new n(286), Y: new n(30), a: new n(19), t: new n(15e3), k: new e(65536), g: new e(32768) } }(), function () { for (var e = t.H.m, n = 32768, r = 0; r < n; r++) { var i = r; i = (i & 2863311530) >>> 1 | (i & 1431655765) << 1, i = (i & 3435973836) >>> 2 | (i & 858993459) << 2, i = (i & 4042322160) >>> 4 | (i & 252645135) << 4, i = (i & 4278255360) >>> 8 | (i & 16711935) << 8, e.r[r] = (i >>> 16 | i << 16) >>> 17 } function s(a, u, c) { for (; u-- != 0;)a.push(0, c) } for (var r = 0; r < 32; r++)e.q[r] = e.S[r] << 3 | e.T[r], e.c[r] = e.p[r] << 4 | e.z[r]; s(e._, 144, 8), s(e._, 112, 9), s(e._, 24, 7), s(e._, 8, 8), t.H.n(e._, 9), t.H.A(e._, 9, e.J), t.H.l(e._, 9), s(e.$, 32, 5), t.H.n(e.$, 5), t.H.A(e.$, 5, e.h), t.H.l(e.$, 5), s(e.Q, 19, 0), s(e.C, 286, 0), s(e.D, 30, 0), s(e.v, 320, 0) }(), t.H.N }(); pe.decode._readInterlace = function (t, e) { for (var n = e.width, r = e.height, i = pe.decode._getBPP(e), s = i >> 3, a = Math.ceil(n * i / 8), u = new Uint8Array(r * a), c = 0, f = [0, 0, 4, 0, 2, 0, 1], h = [0, 4, 0, 2, 0, 1, 0], v = [8, 8, 8, 4, 4, 2, 2], m = [8, 8, 4, 4, 2, 2, 1], g = 0; g < 7;) { for (var S = v[g], b = m[g], P = 0, C = 0, F = f[g]; F < r;)F += S, C++; for (var A = h[g]; A < n;)A += b, P++; var N = Math.ceil(P * i / 8); pe.decode._filterZero(t, e, c, P, C); for (var D = 0, V = f[g]; V < r;) { for (var B = h[g], I = c + D * N << 3; B < n;) { if (i == 1) { var Y = t[I >> 3]; Y = Y >> 7 - (I & 7) & 1, u[V * a + (B >> 3)] |= Y << 7 - ((B & 7) << 0) } if (i == 2) { var Y = t[I >> 3]; Y = Y >> 6 - (I & 7) & 3, u[V * a + (B >> 2)] |= Y << 6 - ((B & 3) << 1) } if (i == 4) { var Y = t[I >> 3]; Y = Y >> 4 - (I & 7) & 15, u[V * a + (B >> 1)] |= Y << 4 - ((B & 1) << 2) } if (i >= 8) for (var Z = V * a + B * s, ie = 0; ie < s; ie++)u[Z + ie] = t[(I >> 3) + ie]; I += i, B += b } D++, V += S } P * C != 0 && (c += C * (1 + N)), g = g + 1 } return u }; pe.decode._getBPP = function (t) { var e = [1, null, 3, 1, 2, null, 4][t.ctype]; return e * t.depth }; pe.decode._filterZero = function (t, e, n, r, i) { var s = pe.decode._getBPP(e), a = Math.ceil(r * s / 8), u = pe.decode._paeth; s = Math.ceil(s / 8); var c = 0, f = 1, h = t[n], v = 0; if (h > 1 && (t[n] = [0, 0, 1][h - 2]), h == 3) for (v = s; v < a; v++)t[v + 1] = t[v + 1] + (t[v + 1 - s] >>> 1) & 255; for (var m = 0; m < i; m++)if (c = n + m * a, f = c + m + 1, h = t[f - 1], v = 0, h == 0) for (; v < a; v++)t[c + v] = t[f + v]; else if (h == 1) { for (; v < s; v++)t[c + v] = t[f + v]; for (; v < a; v++)t[c + v] = t[f + v] + t[c + v - s] } else if (h == 2) for (; v < a; v++)t[c + v] = t[f + v] + t[c + v - a]; else if (h == 3) { for (; v < s; v++)t[c + v] = t[f + v] + (t[c + v - a] >>> 1); for (; v < a; v++)t[c + v] = t[f + v] + (t[c + v - a] + t[c + v - s] >>> 1) } else { for (; v < s; v++)t[c + v] = t[f + v] + u(0, t[c + v - a], 0); for (; v < a; v++)t[c + v] = t[f + v] + u(t[c + v - s], t[c + v - a], t[c + v - s - a]) } return t }; pe.decode._paeth = function (t, e, n) { var r = t + e - n, i = r - t, s = r - e, a = r - n; return i * i <= s * s && i * i <= a * a ? t : s * s <= a * a ? e : n }; pe.decode._IHDR = function (t, e, n) { var r = pe._bin; n.width = r.readUint(t, e), e += 4, n.height = r.readUint(t, e), e += 4, n.depth = t[e], e++, n.ctype = t[e], e++, n.compress = t[e], e++, n.filter = t[e], e++, n.interlace = t[e], e++ }; pe._bin = { nextZero: function (t, e) { for (; t[e] != 0;)e++; return e }, readUshort: function (t, e) { return t[e] << 8 | t[e + 1] }, writeUshort: function (t, e, n) { t[e] = n >> 8 & 255, t[e + 1] = n & 255 }, readUint: function (t, e) { return t[e] * (256 * 256 * 256) + (t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) }, writeUint: function (t, e, n) { t[e] = n >> 24 & 255, t[e + 1] = n >> 16 & 255, t[e + 2] = n >> 8 & 255, t[e + 3] = n & 255 }, readASCII: function (t, e, n) { for (var r = "", i = 0; i < n; i++)r += String.fromCharCode(t[e + i]); return r }, writeASCII: function (t, e, n) { for (var r = 0; r < n.length; r++)t[e + r] = n.charCodeAt(r) }, readBytes: function (t, e, n) { for (var r = [], i = 0; i < n; i++)r.push(t[e + i]); return r }, pad: function (t) { return t.length < 2 ? "0" + t : t }, readUTF8: function (t, e, n) { for (var r = "", i, s = 0; s < n; s++)r += "%" + pe._bin.pad(t[e + s].toString(16)); try { i = decodeURIComponent(r) } catch { return pe._bin.readASCII(t, e, n) } return i } }; pe._copyTile = function (t, e, n, r, i, s, a, u, c) { for (var f = Math.min(e, i), h = Math.min(n, s), v = 0, m = 0, g = 0; g < h; g++)for (var S = 0; S < f; S++)if (a >= 0 && u >= 0 ? (v = g * e + S << 2, m = (u + g) * i + a + S << 2) : (v = (-u + g) * e - a + S << 2, m = g * i + S << 2), c == 0) r[m] = t[v], r[m + 1] = t[v + 1], r[m + 2] = t[v + 2], r[m + 3] = t[v + 3]; else if (c == 1) { var b = t[v + 3] * .00392156862745098, P = t[v] * b, C = t[v + 1] * b, F = t[v + 2] * b, A = r[m + 3] * (1 / 255), N = r[m] * A, D = r[m + 1] * A, V = r[m + 2] * A, B = 1 - b, I = b + A * B, Y = I == 0 ? 0 : 1 / I; r[m + 3] = 255 * I, r[m + 0] = (P + N * B) * Y, r[m + 1] = (C + D * B) * Y, r[m + 2] = (F + V * B) * Y } else if (c == 2) { var b = t[v + 3], P = t[v], C = t[v + 1], F = t[v + 2], A = r[m + 3], N = r[m], D = r[m + 1], V = r[m + 2]; b == A && P == N && C == D && F == V ? (r[m] = 0, r[m + 1] = 0, r[m + 2] = 0, r[m + 3] = 0) : (r[m] = P, r[m + 1] = C, r[m + 2] = F, r[m + 3] = b) } else if (c == 3) { var b = t[v + 3], P = t[v], C = t[v + 1], F = t[v + 2], A = r[m + 3], N = r[m], D = r[m + 1], V = r[m + 2]; if (b == A && P == N && C == D && F == V) continue; if (b < 220 && A > 20) return !1 } return !0 }; pe.encode = function (t, e, n, r, i, s, a) { r == null && (r = 0), a == null && (a = !1); var u = pe.encode.compress(t, e, n, r, [!1, !1, !1, 0, a]); return pe.encode.compressPNG(u, -1), pe.encode._main(u, e, n, i, s) }; pe.encodeLL = function (t, e, n, r, i, s, a, u) { for (var c = { ctype: 0 + (r == 1 ? 0 : 2) + (i == 0 ? 0 : 4), depth: s, frames: [] }, f = (r + i) * s, h = f * e, v = 0; v < t.length; v++)c.frames.push({ rect: { x: 0, y: 0, width: e, height: n }, img: new Uint8Array(t[v]), blend: 0, dispose: 1, bpp: Math.ceil(f / 8), bpl: Math.ceil(h / 8) }); pe.encode.compressPNG(c, 0, !0); var m = pe.encode._main(c, e, n, a, u); return m }; pe.encode._main = function (t, e, n, r, i) { i == null && (i = {}); var s = pe.crc.crc, a = pe._bin.writeUint, u = pe._bin.writeUshort, c = pe._bin.writeASCII, f = 8, h = t.frames.length > 1, v = !1, m = 33 + (h ? 20 : 0); if (i.sRGB != null && (m += 13), i.pHYs != null && (m += 21), t.ctype == 3) { for (var g = t.plte.length, S = 0; S < g; S++)t.plte[S] >>> 24 != 255 && (v = !0); m += 8 + g * 3 + 4 + (v ? 8 + g * 1 + 4 : 0) } for (var b = 0; b < t.frames.length; b++) { var P = t.frames[b]; h && (m += 38), m += P.cimg.length + 12, b != 0 && (m += 4) } m += 12; for (var C = new Uint8Array(m), F = [137, 80, 78, 71, 13, 10, 26, 10], S = 0; S < 8; S++)C[S] = F[S]; if (a(C, f, 13), f += 4, c(C, f, "IHDR"), f += 4, a(C, f, e), f += 4, a(C, f, n), f += 4, C[f] = t.depth, f++, C[f] = t.ctype, f++, C[f] = 0, f++, C[f] = 0, f++, C[f] = 0, f++, a(C, f, s(C, f - 17, 17)), f += 4, i.sRGB != null && (a(C, f, 1), f += 4, c(C, f, "sRGB"), f += 4, C[f] = i.sRGB, f++, a(C, f, s(C, f - 5, 5)), f += 4), i.pHYs != null && (a(C, f, 9), f += 4, c(C, f, "pHYs"), f += 4, a(C, f, i.pHYs[0]), f += 4, a(C, f, i.pHYs[1]), f += 4, C[f] = i.pHYs[2], f++, a(C, f, s(C, f - 13, 13)), f += 4), h && (a(C, f, 8), f += 4, c(C, f, "acTL"), f += 4, a(C, f, t.frames.length), f += 4, a(C, f, i.loop != null ? i.loop : 0), f += 4, a(C, f, s(C, f - 12, 12)), f += 4), t.ctype == 3) { var g = t.plte.length; a(C, f, g * 3), f += 4, c(C, f, "PLTE"), f += 4; for (var S = 0; S < g; S++) { var A = S * 3, N = t.plte[S], D = N & 255, V = N >>> 8 & 255, B = N >>> 16 & 255; C[f + A + 0] = D, C[f + A + 1] = V, C[f + A + 2] = B } if (f += g * 3, a(C, f, s(C, f - g * 3 - 4, g * 3 + 4)), f += 4, v) { a(C, f, g), f += 4, c(C, f, "tRNS"), f += 4; for (var S = 0; S < g; S++)C[f + S] = t.plte[S] >>> 24 & 255; f += g, a(C, f, s(C, f - g - 4, g + 4)), f += 4 } } for (var I = 0, b = 0; b < t.frames.length; b++) { var P = t.frames[b]; h && (a(C, f, 26), f += 4, c(C, f, "fcTL"), f += 4, a(C, f, I++), f += 4, a(C, f, P.rect.width), f += 4, a(C, f, P.rect.height), f += 4, a(C, f, P.rect.x), f += 4, a(C, f, P.rect.y), f += 4, u(C, f, r[b]), f += 2, u(C, f, 1e3), f += 2, C[f] = P.dispose, f++, C[f] = P.blend, f++, a(C, f, s(C, f - 30, 30)), f += 4); var Y = P.cimg, g = Y.length; a(C, f, g + (b == 0 ? 0 : 4)), f += 4; var Z = f; c(C, f, b == 0 ? "IDAT" : "fdAT"), f += 4, b != 0 && (a(C, f, I++), f += 4), C.set(Y, f), f += g, a(C, f, s(C, Z, f - Z)), f += 4 } return a(C, f, 0), f += 4, c(C, f, "IEND"), f += 4, a(C, f, s(C, f - 4, 4)), f += 4, C.buffer }; pe.encode.compressPNG = function (t, e, n) { for (var r = 0; r < t.frames.length; r++) { var i = t.frames[r]; i.rect.width; var s = i.rect.height, a = new Uint8Array(s * i.bpl + s); i.cimg = pe.encode._filterZero(i.img, s, i.bpp, i.bpl, a, e, n) } }; pe.encode.compress = function (t, e, n, r, i) { for (var s = i[0], a = i[1], u = i[2], c = i[3], f = i[4], h = 6, v = 8, m = 255, g = 0; g < t.length; g++)for (var S = new Uint8Array(t[g]), b = S.length, P = 0; P < b; P += 4)m &= S[P + 3]; var C = m != 255, F = pe.encode.framize(t, e, n, s, a, u), A = {}, N = [], D = []; if (r != 0) { for (var V = [], P = 0; P < F.length; P++)V.push(F[P].img.buffer); for (var B = pe.encode.concatRGBA(V), I = pe.quantize(B, r), Y = 0, Z = new Uint8Array(I.abuf), P = 0; P < F.length; P++) { var ie = F[P].img, se = ie.length; D.push(new Uint8Array(I.inds.buffer, Y >> 2, se >> 2)); for (var g = 0; g < se; g += 4)ie[g] = Z[Y + g], ie[g + 1] = Z[Y + g + 1], ie[g + 2] = Z[Y + g + 2], ie[g + 3] = Z[Y + g + 3]; Y += se } for (var P = 0; P < I.plte.length; P++)N.push(I.plte[P].est.rgba) } else for (var g = 0; g < F.length; g++) { var q = F[g], ue = new Uint32Array(q.img.buffer), ye = q.rect.width, b = ue.length, ae = new Uint8Array(b); D.push(ae); for (var P = 0; P < b; P++) { var _ = ue[P]; if (P != 0 && _ == ue[P - 1]) ae[P] = ae[P - 1]; else if (P > ye && _ == ue[P - ye]) ae[P] = ae[P - ye]; else { var Q = A[_]; if (Q == null && (A[_] = Q = N.length, N.push(_), N.length >= 300)) break; ae[P] = Q } } } var le = N.length; le <= 256 && f == !1 && (le <= 2 ? v = 1 : le <= 4 ? v = 2 : le <= 16 ? v = 4 : v = 8, v = Math.max(v, c)); for (var g = 0; g < F.length; g++) { var q = F[g]; q.rect.x, q.rect.y; var ye = q.rect.width, ce = q.rect.height, W = q.img; new Uint32Array(W.buffer); var re = 4 * ye, Ae = 4; if (le <= 256 && f == !1) { re = Math.ceil(v * ye / 8); for (var Fe = new Uint8Array(re * ce), Be = D[g], Ee = 0; Ee < ce; Ee++) { var P = Ee * re, Ie = Ee * ye; if (v == 8) for (var be = 0; be < ye; be++)Fe[P + be] = Be[Ie + be]; else if (v == 4) for (var be = 0; be < ye; be++)Fe[P + (be >> 1)] |= Be[Ie + be] << 4 - (be & 1) * 4; else if (v == 2) for (var be = 0; be < ye; be++)Fe[P + (be >> 2)] |= Be[Ie + be] << 6 - (be & 3) * 2; else if (v == 1) for (var be = 0; be < ye; be++)Fe[P + (be >> 3)] |= Be[Ie + be] << 7 - (be & 7) * 1 } W = Fe, h = 3, Ae = 1 } else if (C == !1 && F.length == 1) { for (var Fe = new Uint8Array(ye * ce * 3), Je = ye * ce, P = 0; P < Je; P++) { var ie = P * 3, pt = P * 4; Fe[ie] = W[pt], Fe[ie + 1] = W[pt + 1], Fe[ie + 2] = W[pt + 2] } W = Fe, h = 2, Ae = 3, re = 3 * ye } q.img = W, q.bpl = re, q.bpp = Ae } return { ctype: h, depth: v, plte: N, frames: F } }; pe.encode.framize = function (t, e, n, r, i, s) { for (var a = [], u = 0; u < t.length; u++) { var c = new Uint8Array(t[u]), f = new Uint32Array(c.buffer), h, v = 0, m = 0, g = e, S = n, b = r ? 1 : 0; if (u != 0) { for (var P = s || r || u == 1 || a[u - 2].dispose != 0 ? 1 : 2, C = 0, F = 1e9, A = 0; A < P; A++) { for (var q = new Uint8Array(t[u - 1 - A]), N = new Uint32Array(t[u - 1 - A]), D = e, V = n, B = -1, I = -1, Y = 0; Y < n; Y++)for (var Z = 0; Z < e; Z++) { var ie = Y * e + Z; f[ie] != N[ie] && (Z < D && (D = Z), Z > B && (B = Z), Y < V && (V = Y), Y > I && (I = Y)) } B == -1 && (D = V = B = I = 0), i && ((D & 1) == 1 && D--, (V & 1) == 1 && V--); var se = (B - D + 1) * (I - V + 1); se < F && (F = se, C = A, v = D, m = V, g = B - D + 1, S = I - V + 1) } var q = new Uint8Array(t[u - 1 - C]); C == 1 && (a[u - 1].dispose = 2), h = new Uint8Array(g * S * 4), pe._copyTile(q, e, n, h, g, S, -v, -m, 0), b = pe._copyTile(c, e, n, h, g, S, -v, -m, 3) ? 1 : 0, b == 1 ? pe.encode._prepareDiff(c, e, n, h, { x: v, y: m, width: g, height: S }) : pe._copyTile(c, e, n, h, g, S, -v, -m, 0) } else h = c.slice(0); a.push({ rect: { x: v, y: m, width: g, height: S }, img: h, blend: b, dispose: 0 }) } if (r) for (var u = 0; u < a.length; u++) { var ue = a[u]; if (ue.blend != 1) { var ye = ue.rect, ae = a[u - 1].rect, _ = Math.min(ye.x, ae.x), Q = Math.min(ye.y, ae.y), le = Math.max(ye.x + ye.width, ae.x + ae.width), ce = Math.max(ye.y + ye.height, ae.y + ae.height), W = { x: _, y: Q, width: le - _, height: ce - Q }; a[u - 1].dispose = 1, u - 1 != 0 && pe.encode._updateFrame(t, e, n, a, u - 1, W, i), pe.encode._updateFrame(t, e, n, a, u, W, i) } } var re = 0; if (t.length != 1) for (var ie = 0; ie < a.length; ie++) { var ue = a[ie]; re += ue.rect.width * ue.rect.height } return a }; pe.encode._updateFrame = function (t, e, n, r, i, s, a) { for (var u = Uint8Array, c = Uint32Array, f = new u(t[i - 1]), h = new c(t[i - 1]), v = i + 1 < t.length ? new u(t[i + 1]) : null, m = new u(t[i]), g = new c(m.buffer), S = e, b = n, P = -1, C = -1, F = 0; F < s.height; F++)for (var A = 0; A < s.width; A++) { var N = s.x + A, D = s.y + F, V = D * e + N, B = g[V]; B == 0 || r[i - 1].dispose == 0 && h[V] == B && (v == null || v[V * 4 + 3] != 0) || (N < S && (S = N), N > P && (P = N), D < b && (b = D), D > C && (C = D)) } P == -1 && (S = b = P = C = 0), a && ((S & 1) == 1 && S--, (b & 1) == 1 && b--), s = { x: S, y: b, width: P - S + 1, height: C - b + 1 }; var I = r[i]; I.rect = s, I.blend = 1, I.img = new Uint8Array(s.width * s.height * 4), r[i - 1].dispose == 0 ? (pe._copyTile(f, e, n, I.img, s.width, s.height, -s.x, -s.y, 0), pe.encode._prepareDiff(m, e, n, I.img, s)) : pe._copyTile(m, e, n, I.img, s.width, s.height, -s.x, -s.y, 0) }; pe.encode._prepareDiff = function (t, e, n, r, i) { pe._copyTile(t, e, n, r, i.width, i.height, -i.x, -i.y, 2) }; pe.encode._filterZero = function (t, e, n, r, i, s, a) { var u = [], c = [0, 1, 2, 3, 4]; s != -1 ? c = [s] : (e * r > 5e5 || n == 1) && (c = [0]); var f; a && (f = { level: 0 }); for (var h = a && UZIP != null ? UZIP : If, v = 0; v < c.length; v++) { for (var m = 0; m < e; m++)pe.encode._filterLine(i, t, m, r, n, c[v]); u.push(h.deflate(i, f)) } for (var g, S = 1e9, v = 0; v < u.length; v++)u[v].length < S && (g = v, S = u[v].length); return u[g] }; pe.encode._filterLine = function (t, e, n, r, i, s) { var a = n * r, u = a + n, c = pe.decode._paeth; if (t[u] = s, u++, s == 0) if (r < 500) for (var f = 0; f < r; f++)t[u + f] = e[a + f]; else t.set(new Uint8Array(e.buffer, a, r), u); else if (s == 1) { for (var f = 0; f < i; f++)t[u + f] = e[a + f]; for (var f = i; f < r; f++)t[u + f] = e[a + f] - e[a + f - i] + 256 & 255 } else if (n == 0) { for (var f = 0; f < i; f++)t[u + f] = e[a + f]; if (s == 2) for (var f = i; f < r; f++)t[u + f] = e[a + f]; if (s == 3) for (var f = i; f < r; f++)t[u + f] = e[a + f] - (e[a + f - i] >> 1) + 256 & 255; if (s == 4) for (var f = i; f < r; f++)t[u + f] = e[a + f] - c(e[a + f - i], 0, 0) + 256 & 255 } else { if (s == 2) for (var f = 0; f < r; f++)t[u + f] = e[a + f] + 256 - e[a + f - r] & 255; if (s == 3) { for (var f = 0; f < i; f++)t[u + f] = e[a + f] + 256 - (e[a + f - r] >> 1) & 255; for (var f = i; f < r; f++)t[u + f] = e[a + f] + 256 - (e[a + f - r] + e[a + f - i] >> 1) & 255 } if (s == 4) { for (var f = 0; f < i; f++)t[u + f] = e[a + f] + 256 - c(0, e[a + f - r], 0) & 255; for (var f = i; f < r; f++)t[u + f] = e[a + f] + 256 - c(e[a + f - i], e[a + f - r], e[a + f - i - r]) & 255 } } }; pe.crc = { table: function () { for (var t = new Uint32Array(256), e = 0; e < 256; e++) { for (var n = e, r = 0; r < 8; r++)n & 1 ? n = 3988292384 ^ n >>> 1 : n = n >>> 1; t[e] = n } return t }(), update: function (t, e, n, r) { for (var i = 0; i < r; i++)t = pe.crc.table[(t ^ e[n + i]) & 255] ^ t >>> 8; return t }, crc: function (t, e, n) { return pe.crc.update(4294967295, t, e, n) ^ 4294967295 } }; pe.quantize = function (t, e) { var n = new Uint8Array(t), r = n.slice(0), i = new Uint32Array(r.buffer), s = pe.quantize.getKDtree(r, e), a = s[0], u = s[1]; pe.quantize.planeDst; for (var c = n, f = i, h = c.length, v = new Uint8Array(n.length >> 2), m = 0; m < h; m += 4) { var g = c[m] * .00392156862745098, S = c[m + 1] * (1 / 255), b = c[m + 2] * (1 / 255), P = c[m + 3] * (1 / 255), C = pe.quantize.getNearest(a, g, S, b, P); v[m >> 2] = C.ind, f[m >> 2] = C.est.rgba } return { abuf: r.buffer, inds: v, plte: u } }; pe.quantize.getKDtree = function (t, e, n) { n == null && (n = 1e-4); var r = new Uint32Array(t.buffer), i = { i0: 0, i1: t.length, bst: null, est: null, tdst: 0, left: null, right: null }; i.bst = pe.quantize.stats(t, i.i0, i.i1), i.est = pe.quantize.estats(i.bst); for (var s = [i]; s.length < e;) { for (var a = 0, u = 0, c = 0; c < s.length; c++)s[c].est.L > a && (a = s[c].est.L, u = c); if (a < n) break; var f = s[u], h = pe.quantize.splitPixels(t, r, f.i0, f.i1, f.est.e, f.est.eMq255), v = f.i0 >= h || f.i1 <= h; if (v) { f.est.L = 0; continue } var m = { i0: f.i0, i1: h, bst: null, est: null, tdst: 0, left: null, right: null }; m.bst = pe.quantize.stats(t, m.i0, m.i1), m.est = pe.quantize.estats(m.bst); var g = { i0: h, i1: f.i1, bst: null, est: null, tdst: 0, left: null, right: null }; g.bst = { R: [], m: [], N: f.bst.N - m.bst.N }; for (var c = 0; c < 16; c++)g.bst.R[c] = f.bst.R[c] - m.bst.R[c]; for (var c = 0; c < 4; c++)g.bst.m[c] = f.bst.m[c] - m.bst.m[c]; g.est = pe.quantize.estats(g.bst), f.left = m, f.right = g, s[u] = m, s.push(g) } s.sort(function (S, b) { return b.bst.N - S.bst.N }); for (var c = 0; c < s.length; c++)s[c].ind = c; return [i, s] }; pe.quantize.getNearest = function (t, e, n, r, i) { if (t.left == null) return t.tdst = pe.quantize.dist(t.est.q, e, n, r, i), t; var s = pe.quantize.planeDst(t.est, e, n, r, i), a = t.left, u = t.right; s > 0 && (a = t.right, u = t.left); var c = pe.quantize.getNearest(a, e, n, r, i); if (c.tdst <= s * s) return c; var f = pe.quantize.getNearest(u, e, n, r, i); return f.tdst < c.tdst ? f : c }; pe.quantize.planeDst = function (t, e, n, r, i) { var s = t.e; return s[0] * e + s[1] * n + s[2] * r + s[3] * i - t.eMq }; pe.quantize.dist = function (t, e, n, r, i) { var s = e - t[0], a = n - t[1], u = r - t[2], c = i - t[3]; return s * s + a * a + u * u + c * c }; pe.quantize.splitPixels = function (t, e, n, r, i, s) { var a = pe.quantize.vecDot; for (r -= 4; n < r;) { for (; a(t, n, i) <= s;)n += 4; for (; a(t, r, i) > s;)r -= 4; if (n >= r) break; var u = e[n >> 2]; e[n >> 2] = e[r >> 2], e[r >> 2] = u, n += 4, r -= 4 } for (; a(t, n, i) > s;)n -= 4; return n + 4 }; pe.quantize.vecDot = function (t, e, n) { return t[e] * n[0] + t[e + 1] * n[1] + t[e + 2] * n[2] + t[e + 3] * n[3] }; pe.quantize.stats = function (t, e, n) { for (var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i = [0, 0, 0, 0], s = n - e >> 2, a = e; a < n; a += 4) { var u = t[a] * .00392156862745098, c = t[a + 1] * (1 / 255), f = t[a + 2] * (1 / 255), h = t[a + 3] * (1 / 255); i[0] += u, i[1] += c, i[2] += f, i[3] += h, r[0] += u * u, r[1] += u * c, r[2] += u * f, r[3] += u * h, r[5] += c * c, r[6] += c * f, r[7] += c * h, r[10] += f * f, r[11] += f * h, r[15] += h * h } return r[4] = r[1], r[8] = r[2], r[9] = r[6], r[12] = r[3], r[13] = r[7], r[14] = r[11], { R: r, m: i, N: s } }; pe.quantize.estats = function (t) { var e = t.R, n = t.m, r = t.N, i = n[0], s = n[1], a = n[2], u = n[3], c = r == 0 ? 0 : 1 / r, f = [e[0] - i * i * c, e[1] - i * s * c, e[2] - i * a * c, e[3] - i * u * c, e[4] - s * i * c, e[5] - s * s * c, e[6] - s * a * c, e[7] - s * u * c, e[8] - a * i * c, e[9] - a * s * c, e[10] - a * a * c, e[11] - a * u * c, e[12] - u * i * c, e[13] - u * s * c, e[14] - u * a * c, e[15] - u * u * c], h = f, v = pe.M4, m = [.5, .5, .5, .5], g = 0, S = 0; if (r != 0) for (var b = 0; b < 10 && (m = v.multVec(h, m), S = Math.sqrt(v.dot(m, m)), m = v.sml(1 / S, m), !(Math.abs(S - g) < 1e-9)); b++)g = S; var P = [i * c, s * c, a * c, u * c], C = v.dot(v.sml(255, P), m); return { Cov: f, q: P, e: m, L: g, eMq255: C, eMq: v.dot(m, P), rgba: (Math.round(255 * P[3]) << 24 | Math.round(255 * P[2]) << 16 | Math.round(255 * P[1]) << 8 | Math.round(255 * P[0]) << 0) >>> 0 } }; pe.M4 = { multVec: function (t, e) { return [t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3], t[4] * e[0] + t[5] * e[1] + t[6] * e[2] + t[7] * e[3], t[8] * e[0] + t[9] * e[1] + t[10] * e[2] + t[11] * e[3], t[12] * e[0] + t[13] * e[1] + t[14] * e[2] + t[15] * e[3]] }, dot: function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3] }, sml: function (t, e) { return [t * e[0], t * e[1], t * e[2], t * e[3]] } }; pe.encode.concatRGBA = function (t) { for (var e = 0, n = 0; n < t.length; n++)e += t[n].byteLength; for (var r = new Uint8Array(e), i = 0, n = 0; n < t.length; n++) { for (var s = new Uint8Array(t[n]), a = s.length, u = 0; u < a; u += 4) { var c = s[u], f = s[u + 1], h = s[u + 2], v = s[u + 3]; v == 0 && (c = f = h = 0), r[i + u] = c, r[i + u + 1] = f, r[i + u + 2] = h, r[i + u + 3] = v } i += a } return r.buffer }; var D3 = function (t) { if (t === 0) return Xo.Greyscale; if (t === 2) return Xo.Truecolour; if (t === 3) return Xo.IndexedColour; if (t === 4) return Xo.GreyscaleWithAlpha; if (t === 6) return Xo.TruecolourWithAlpha; throw new Error("Unknown color type: " + t) }, O3 = function (t) { for (var e = Math.floor(t.length / 4), n = new Uint8Array(e * 3), r = new Uint8Array(e * 1), i = 0, s = 0, a = 0; i < t.length;)n[s++] = t[i++], n[s++] = t[i++], n[s++] = t[i++], r[a++] = t[i++]; return { rgbChannel: n, alphaChannel: r } }, Xo; (function (t) { t.Greyscale = "Greyscale", t.Truecolour = "Truecolour", t.IndexedColour = "IndexedColour", t.GreyscaleWithAlpha = "GreyscaleWithAlpha", t.TruecolourWithAlpha = "TruecolourWithAlpha" })(Xo || (Xo = {})); var M3 = function () { function t(e) { var n = pe.decode(e), r = pe.toRGBA8(n); if (r.length > 1) throw new Error("Animated PNGs are not supported"); var i = new Uint8Array(r[0]), s = O3(i), a = s.rgbChannel, u = s.alphaChannel; this.rgbChannel = a; var c = u.some(function (f) { return f < 255 }); c && (this.alphaChannel = u), this.type = D3(n.ctype), this.width = n.width, this.height = n.height, this.bitsPerComponent = 8 } return t.load = function (e) { return new t(e) }, t }(), SP = function () { function t(e) { this.image = e, this.bitsPerComponent = e.bitsPerComponent, this.width = e.width, this.height = e.height, this.colorSpace = "DeviceRGB" } return t.for = function (e) { return tt(this, void 0, void 0, function () { var n; return nt(this, function (r) { return n = M3.load(e), [2, new t(n)] }) }) }, t.prototype.embedIntoContext = function (e, n) { return tt(this, void 0, void 0, function () { var r, i; return nt(this, function (s) { return r = this.embedAlphaChannel(e), i = e.flateStream(this.image.rgbChannel, { Type: "XObject", Subtype: "Image", BitsPerComponent: this.image.bitsPerComponent, Width: this.image.width, Height: this.image.height, ColorSpace: this.colorSpace, SMask: r }), n ? (e.assign(n, i), [2, n]) : [2, e.register(i)] }) }) }, t.prototype.embedAlphaChannel = function (e) { if (this.image.alphaChannel) { var n = e.flateStream(this.image.alphaChannel, { Type: "XObject", Subtype: "Image", Height: this.image.height, Width: this.image.width, BitsPerComponent: this.image.bitsPerComponent, ColorSpace: "DeviceGray", Decode: [0, 1] }); return e.register(n) } }, t }(), bP = function () { function t(e, n, r) { this.bytes = e, this.start = n || 0, this.pos = this.start, this.end = n && r ? n + r : this.bytes.length } return Object.defineProperty(t.prototype, "length", { get: function () { return this.end - this.start }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "isEmpty", { get: function () { return this.length === 0 }, enumerable: !1, configurable: !0 }), t.prototype.getByte = function () { return this.pos >= this.end ? -1 : this.bytes[this.pos++] }, t.prototype.getUint16 = function () { var e = this.getByte(), n = this.getByte(); return e === -1 || n === -1 ? -1 : (e << 8) + n }, t.prototype.getInt32 = function () { var e = this.getByte(), n = this.getByte(), r = this.getByte(), i = this.getByte(); return (e << 24) + (n << 16) + (r << 8) + i }, t.prototype.getBytes = function (e, n) { n === void 0 && (n = !1); var r = this.bytes, i = this.pos, s = this.end; if (e) { var u = i + e; u > s && (u = s), this.pos = u; var a = r.subarray(i, u); return n ? new Uint8ClampedArray(a) : a } else { var a = r.subarray(i, s); return n ? new Uint8ClampedArray(a) : a } }, t.prototype.peekByte = function () { var e = this.getByte(); return this.pos--, e }, t.prototype.peekBytes = function (e, n) { n === void 0 && (n = !1); var r = this.getBytes(e, n); return this.pos -= r.length, r }, t.prototype.skip = function (e) { e || (e = 1), this.pos += e }, t.prototype.reset = function () { this.pos = this.start }, t.prototype.moveStart = function () { this.start = this.pos }, t.prototype.makeSubStream = function (e, n) { return new t(this.bytes, e, n) }, t.prototype.decode = function () { return this.bytes }, t }(), V3 = new Uint8Array(0), ou = function () { function t(e) { if (this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = V3, this.minBufferLength = 512, e) for (; this.minBufferLength < e;)this.minBufferLength *= 2 } return Object.defineProperty(t.prototype, "isEmpty", { get: function () { for (; !this.eof && this.bufferLength === 0;)this.readBlock(); return this.bufferLength === 0 }, enumerable: !1, configurable: !0 }), t.prototype.getByte = function () { for (var e = this.pos; this.bufferLength <= e;) { if (this.eof) return -1; this.readBlock() } return this.buffer[this.pos++] }, t.prototype.getUint16 = function () { var e = this.getByte(), n = this.getByte(); return e === -1 || n === -1 ? -1 : (e << 8) + n }, t.prototype.getInt32 = function () { var e = this.getByte(), n = this.getByte(), r = this.getByte(), i = this.getByte(); return (e << 24) + (n << 16) + (r << 8) + i }, t.prototype.getBytes = function (e, n) { n === void 0 && (n = !1); var r, i = this.pos; if (e) { for (this.ensureBuffer(i + e), r = i + e; !this.eof && this.bufferLength < r;)this.readBlock(); var s = this.bufferLength; r > s && (r = s) } else { for (; !this.eof;)this.readBlock(); r = this.bufferLength } this.pos = r; var a = this.buffer.subarray(i, r); return n && !(a instanceof Uint8ClampedArray) ? new Uint8ClampedArray(a) : a }, t.prototype.peekByte = function () { var e = this.getByte(); return this.pos--, e }, t.prototype.peekBytes = function (e, n) { n === void 0 && (n = !1); var r = this.getBytes(e, n); return this.pos -= r.length, r }, t.prototype.skip = function (e) { e || (e = 1), this.pos += e }, t.prototype.reset = function () { this.pos = 0 }, t.prototype.makeSubStream = function (e, n) { for (var r = e + n; this.bufferLength <= r && !this.eof;)this.readBlock(); return new bP(this.buffer, e, n) }, t.prototype.decode = function () { for (; !this.eof;)this.readBlock(); return this.buffer.subarray(0, this.bufferLength) }, t.prototype.readBlock = function () { throw new Ar(this.constructor.name, "readBlock") }, t.prototype.ensureBuffer = function (e) { var n = this.buffer; if (e <= n.byteLength) return n; for (var r = this.minBufferLength; r < e;)r *= 2; var i = new Uint8Array(r); return i.set(n), this.buffer = i }, t }(), bw = function (t) { return t === 32 || t === 9 || t === 13 || t === 10 }, N3 = function (t) { we(e, t); function e(n, r) { var i = t.call(this, r) || this; return i.stream = n, i.input = new Uint8Array(5), r && (r = .8 * r), i } return e.prototype.readBlock = function () { for (var n = 126, r = 122, i = -1, s = this.stream, a = s.getByte(); bw(a);)a = s.getByte(); if (a === i || a === n) { this.eof = !0; return } var u = this.bufferLength, c, f; if (a === r) { for (c = this.ensureBuffer(u + 4), f = 0; f < 4; ++f)c[u + f] = 0; this.bufferLength += 4 } else { var h = this.input; for (h[0] = a, f = 1; f < 5; ++f) { for (a = s.getByte(); bw(a);)a = s.getByte(); if (h[f] = a, a === i || a === n) break } if (c = this.ensureBuffer(u + f - 1), this.bufferLength += f - 1, f < 5) { for (; f < 5; ++f)h[f] = 117; this.eof = !0 } var v = 0; for (f = 0; f < 5; ++f)v = v * 85 + (h[f] - 33); for (f = 3; f >= 0; --f)c[u + f] = v & 255, v >>= 8 } }, e }(ou), B3 = function (t) { we(e, t); function e(n, r) { var i = t.call(this, r) || this; return i.stream = n, i.firstDigit = -1, r && (r = .5 * r), i } return e.prototype.readBlock = function () { var n = 8e3, r = this.stream.getBytes(n); if (!r.length) { this.eof = !0; return } for (var i = r.length + 1 >> 1, s = this.ensureBuffer(this.bufferLength + i), a = this.bufferLength, u = this.firstDigit, c = 0, f = r.length; c < f; c++) { var h = r[c], v = void 0; if (h >= 48 && h <= 57) v = h & 15; else if (h >= 65 && h <= 70 || h >= 97 && h <= 102) v = (h & 15) + 9; else if (h === 62) { this.eof = !0; break } else continue; u < 0 ? u = v : (s[a++] = u << 4 | v, u = -1) } u >= 0 && this.eof && (s[a++] = u << 4, u = -1), this.firstDigit = u, this.bufferLength = a }, e }(ou), Cw = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), L3 = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), j3 = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), I3 = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], z3 = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5], U3 = function (t) { we(e, t); function e(n, r) { var i = t.call(this, r) || this; i.stream = n; var s = n.getByte(), a = n.getByte(); if (s === -1 || a === -1) throw new Error("Invalid header in flate stream: " + s + ", " + a); if ((s & 15) !== 8) throw new Error("Unknown compression method in flate stream: " + s + ", " + a); if (((s << 8) + a) % 31 !== 0) throw new Error("Bad FCHECK in flate stream: " + s + ", " + a); if (a & 32) throw new Error("FDICT bit set in flate stream: " + s + ", " + a); return i.codeSize = 0, i.codeBuf = 0, i } return e.prototype.readBlock = function () { var n, r, i = this.stream, s = this.getBits(3); if (s & 1 && (this.eof = !0), s >>= 1, s === 0) { var a = void 0; if ((a = i.getByte()) === -1) throw new Error("Bad block header in flate stream"); var u = a; if ((a = i.getByte()) === -1) throw new Error("Bad block header in flate stream"); if (u |= a << 8, (a = i.getByte()) === -1) throw new Error("Bad block header in flate stream"); var c = a; if ((a = i.getByte()) === -1) throw new Error("Bad block header in flate stream"); if (c |= a << 8, c !== (~u & 65535) && (u !== 0 || c !== 0)) throw new Error("Bad uncompressed block length in flate stream"); this.codeBuf = 0, this.codeSize = 0; var f = this.bufferLength; n = this.ensureBuffer(f + u); var h = f + u; if (this.bufferLength = h, u === 0) i.peekByte() === -1 && (this.eof = !0); else for (var v = f; v < h; ++v) { if ((a = i.getByte()) === -1) { this.eof = !0; break } n[v] = a } return } var m, g; if (s === 1) m = I3, g = z3; else if (s === 2) { var S = this.getBits(5) + 257, b = this.getBits(5) + 1, P = this.getBits(4) + 4, C = new Uint8Array(Cw.length), F = void 0; for (F = 0; F < P; ++F)C[Cw[F]] = this.getBits(3); var A = this.generateHuffmanTable(C); r = 0, F = 0; for (var N = S + b, D = new Uint8Array(N), V = void 0, B = void 0, I = void 0; F < N;) { var Y = this.getCode(A); if (Y === 16) V = 2, B = 3, I = r; else if (Y === 17) V = 3, B = 3, I = r = 0; else if (Y === 18) V = 7, B = 11, I = r = 0; else { D[F++] = r = Y; continue } for (var Z = this.getBits(V) + B; Z-- > 0;)D[F++] = I } m = this.generateHuffmanTable(D.subarray(0, S)), g = this.generateHuffmanTable(D.subarray(S, N)) } else throw new Error("Unknown block type in flate stream"); n = this.buffer; for (var ie = n ? n.length : 0, se = this.bufferLength; ;) { var q = this.getCode(m); if (q < 256) { se + 1 >= ie && (n = this.ensureBuffer(se + 1), ie = n.length), n[se++] = q; continue } if (q === 256) { this.bufferLength = se; return } q -= 257, q = L3[q]; var ue = q >> 16; ue > 0 && (ue = this.getBits(ue)), r = (q & 65535) + ue, q = this.getCode(g), q = j3[q], ue = q >> 16, ue > 0 && (ue = this.getBits(ue)); var ye = (q & 65535) + ue; se + r >= ie && (n = this.ensureBuffer(se + r), ie = n.length); for (var ae = 0; ae < r; ++ae, ++se)n[se] = n[se - ye] } }, e.prototype.getBits = function (n) { for (var r = this.stream, i = this.codeSize, s = this.codeBuf, a; i < n;) { if ((a = r.getByte()) === -1) throw new Error("Bad encoding in flate stream"); s |= a << i, i += 8 } return a = s & (1 << n) - 1, this.codeBuf = s >> n, this.codeSize = i -= n, a }, e.prototype.getCode = function (n) { for (var r = this.stream, i = n[0], s = n[1], a = this.codeSize, u = this.codeBuf, c; a < s && (c = r.getByte()) !== -1;)u |= c << a, a += 8; var f = i[u & (1 << s) - 1]; typeof i == "number" && console.log("FLATE:", f); var h = f >> 16, v = f & 65535; if (h < 1 || a < h) throw new Error("Bad encoding in flate stream"); return this.codeBuf = u >> h, this.codeSize = a - h, v }, e.prototype.generateHuffmanTable = function (n) { var r = n.length, i = 0, s; for (s = 0; s < r; ++s)n[s] > i && (i = n[s]); for (var a = 1 << i, u = new Int32Array(a), c = 1, f = 0, h = 2; c <= i; ++c, f <<= 1, h <<= 1)for (var v = 0; v < r; ++v)if (n[v] === c) { var m = 0, g = f; for (s = 0; s < c; ++s)m = m << 1 | g & 1, g >>= 1; for (s = m; s < a; s += h)u[s] = c << 16 | v; ++f } return [u, i] }, e }(ou), W3 = function (t) { we(e, t); function e(n, r, i) { var s = t.call(this, r) || this; s.stream = n, s.cachedData = 0, s.bitsCached = 0; for (var a = 4096, u = { earlyChange: i, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(a), dictionaryLengths: new Uint16Array(a), dictionaryPrevCodes: new Uint16Array(a), currentSequence: new Uint8Array(a), currentSequenceLength: 0 }, c = 0; c < 256; ++c)u.dictionaryValues[c] = c, u.dictionaryLengths[c] = 1; return s.lzwState = u, s } return e.prototype.readBlock = function () { var n = 512, r = n * 2, i = n, s, a, u, c = this.lzwState; if (c) { var f = c.earlyChange, h = c.nextCode, v = c.dictionaryValues, m = c.dictionaryLengths, g = c.dictionaryPrevCodes, S = c.codeLength, b = c.prevCode, P = c.currentSequence, C = c.currentSequenceLength, F = 0, A = this.bufferLength, N = this.ensureBuffer(this.bufferLength + r); for (s = 0; s < n; s++) { var D = this.readBits(S), V = C > 0; if (!D || D < 256) P[0] = D, C = 1; else if (D >= 258) if (D < h) for (C = m[D], a = C - 1, u = D; a >= 0; a--)P[a] = v[u], u = g[u]; else P[C++] = P[0]; else if (D === 256) { S = 9, h = 258, C = 0; continue } else { this.eof = !0, delete this.lzwState; break } if (V && (g[h] = b, m[h] = m[b] + 1, v[h] = P[0], h++, S = h + f & h + f - 1 ? S : Math.min(Math.log(h + f) / .6931471805599453 + 1, 12) | 0), b = D, F += C, r < F) { do r += i; while (r < F); N = this.ensureBuffer(this.bufferLength + r) } for (a = 0; a < C; a++)N[A++] = P[a] } c.nextCode = h, c.codeLength = S, c.prevCode = b, c.currentSequenceLength = C, this.bufferLength = A } }, e.prototype.readBits = function (n) { for (var r = this.bitsCached, i = this.cachedData; r < n;) { var s = this.stream.getByte(); if (s === -1) return this.eof = !0, null; i = i << 8 | s, r += 8 } return this.bitsCached = r -= n, this.cachedData = i, i >>> r & (1 << n) - 1 }, e }(ou), K3 = function (t) { we(e, t); function e(n, r) { var i = t.call(this, r) || this; return i.stream = n, i } return e.prototype.readBlock = function () { var n = this.stream.getBytes(2); if (!n || n.length < 2 || n[0] === 128) { this.eof = !0; return } var r, i = this.bufferLength, s = n[0]; if (s < 128) { if (r = this.ensureBuffer(i + s + 1), r[i++] = n[1], s > 0) { var a = this.stream.getBytes(s); r.set(a, i), i += s } } else { s = 257 - s; var u = n[1]; r = this.ensureBuffer(i + s + 1); for (var c = 0; c < s; c++)r[i++] = u } this.bufferLength = i }, e }(ou), Pw = function (t, e, n) { if (e === O.of("FlateDecode")) return new U3(t); if (e === O.of("LZWDecode")) { var r = 1; if (n instanceof et) { var i = n.lookup(O.of("EarlyChange")); i instanceof Xe && (r = i.asNumber()) } return new W3(t, void 0, r) } if (e === O.of("ASCII85Decode")) return new N3(t); if (e === O.of("ASCIIHexDecode")) return new B3(t); if (e === O.of("RunLengthDecode")) return new K3(t); throw new _M(e.asString()) }, CP = function (t) { var e = t.dict, n = t.contents, r = new bP(n), i = e.lookup(O.of("Filter")), s = e.lookup(O.of("DecodeParms")); if (i instanceof O) r = Pw(r, i, s); else if (i instanceof mt) for (var a = 0, u = i.size(); a < u; a++)r = Pw(r, i.lookup(a, O), s && s.lookupMaybe(a, et)); else if (i) throw new cf([O, mt], i); return r }, H3 = function (t) { var e = t.MediaBox(), n = e.lookup(2, Xe).asNumber() - e.lookup(0, Xe).asNumber(), r = e.lookup(3, Xe).asNumber() - e.lookup(1, Xe).asNumber(); return { left: 0, bottom: 0, right: n, top: r } }, q3 = function (t) { return [1, 0, 0, 1, -t.left, -t.bottom] }, PP = function () { function t(e, n, r) { this.page = e; var i = n ?? H3(e); this.width = i.right - i.left, this.height = i.top - i.bottom, this.boundingBox = i, this.transformationMatrix = r ?? q3(i) } return t.for = function (e, n, r) { return tt(this, void 0, void 0, function () { return nt(this, function (i) { return [2, new t(e, n, r)] }) }) }, t.prototype.embedIntoContext = function (e, n) { return tt(this, void 0, void 0, function () { var r, i, s, a, u, c, f, h, v, m; return nt(this, function (g) { if (r = this.page.normalizedEntries(), i = r.Contents, s = r.Resources, !i) throw new $M; return a = this.decodeContents(i), u = this.boundingBox, c = u.left, f = u.bottom, h = u.right, v = u.top, m = e.flateStream(a, { Type: "XObject", Subtype: "Form", FormType: 1, BBox: [c, f, h, v], Matrix: this.transformationMatrix, Resources: s }), n ? (e.assign(n, m), [2, n]) : [2, e.register(m)] }) }) }, t.prototype.decodeContents = function (e) { for (var n = Uint8Array.of(M.Newline), r = [], i = 0, s = e.size(); i < s; i++) { var a = e.lookup(i, or), u = void 0; if (a instanceof Ul) u = CP(a).decode(); else if (a instanceof Cl) u = a.getUnencodedContents(); else throw new e3(a); r.push(u, n) } return $O.apply(void 0, r) }, t }(), Fc = function (t, e) { if (t !== void 0) return e[t] }, Pl; (function (t) { t.UseNone = "UseNone", t.UseOutlines = "UseOutlines", t.UseThumbs = "UseThumbs", t.UseOC = "UseOC" })(Pl || (Pl = {})); var Tl; (function (t) { t.L2R = "L2R", t.R2L = "R2L" })(Tl || (Tl = {})); var kl; (function (t) { t.None = "None", t.AppDefault = "AppDefault" })(kl || (kl = {})); var hf; (function (t) { t.Simplex = "Simplex", t.DuplexFlipShortEdge = "DuplexFlipShortEdge", t.DuplexFlipLongEdge = "DuplexFlipLongEdge" })(hf || (hf = {})); var Tw = function () { function t(e) { this.dict = e } return t.prototype.lookupBool = function (e) { var n = this.dict.lookup(O.of(e)); if (n instanceof zl) return n }, t.prototype.lookupName = function (e) { var n = this.dict.lookup(O.of(e)); if (n instanceof O) return n }, t.prototype.HideToolbar = function () { return this.lookupBool("HideToolbar") }, t.prototype.HideMenubar = function () { return this.lookupBool("HideMenubar") }, t.prototype.HideWindowUI = function () { return this.lookupBool("HideWindowUI") }, t.prototype.FitWindow = function () { return this.lookupBool("FitWindow") }, t.prototype.CenterWindow = function () { return this.lookupBool("CenterWindow") }, t.prototype.DisplayDocTitle = function () { return this.lookupBool("DisplayDocTitle") }, t.prototype.NonFullScreenPageMode = function () { return this.lookupName("NonFullScreenPageMode") }, t.prototype.Direction = function () { return this.lookupName("Direction") }, t.prototype.PrintScaling = function () { return this.lookupName("PrintScaling") }, t.prototype.Duplex = function () { return this.lookupName("Duplex") }, t.prototype.PickTrayByPDFSize = function () { return this.lookupBool("PickTrayByPDFSize") }, t.prototype.PrintPageRange = function () { var e = this.dict.lookup(O.of("PrintPageRange")); if (e instanceof mt) return e }, t.prototype.NumCopies = function () { var e = this.dict.lookup(O.of("NumCopies")); if (e instanceof Xe) return e }, t.prototype.getHideToolbar = function () { var e, n; return (n = (e = this.HideToolbar()) === null || e === void 0 ? void 0 : e.asBoolean()) !== null && n !== void 0 ? n : !1 }, t.prototype.getHideMenubar = function () { var e, n; return (n = (e = this.HideMenubar()) === null || e === void 0 ? void 0 : e.asBoolean()) !== null && n !== void 0 ? n : !1 }, t.prototype.getHideWindowUI = function () { var e, n; return (n = (e = this.HideWindowUI()) === null || e === void 0 ? void 0 : e.asBoolean()) !== null && n !== void 0 ? n : !1 }, t.prototype.getFitWindow = function () { var e, n; return (n = (e = this.FitWindow()) === null || e === void 0 ? void 0 : e.asBoolean()) !== null && n !== void 0 ? n : !1 }, t.prototype.getCenterWindow = function () { var e, n; return (n = (e = this.CenterWindow()) === null || e === void 0 ? void 0 : e.asBoolean()) !== null && n !== void 0 ? n : !1 }, t.prototype.getDisplayDocTitle = function () { var e, n; return (n = (e = this.DisplayDocTitle()) === null || e === void 0 ? void 0 : e.asBoolean()) !== null && n !== void 0 ? n : !1 }, t.prototype.getNonFullScreenPageMode = function () { var e, n, r = (e = this.NonFullScreenPageMode()) === null || e === void 0 ? void 0 : e.decodeText(); return (n = Fc(r, Pl)) !== null && n !== void 0 ? n : Pl.UseNone }, t.prototype.getReadingDirection = function () { var e, n, r = (e = this.Direction()) === null || e === void 0 ? void 0 : e.decodeText(); return (n = Fc(r, Tl)) !== null && n !== void 0 ? n : Tl.L2R }, t.prototype.getPrintScaling = function () { var e, n, r = (e = this.PrintScaling()) === null || e === void 0 ? void 0 : e.decodeText(); return (n = Fc(r, kl)) !== null && n !== void 0 ? n : kl.AppDefault }, t.prototype.getDuplex = function () { var e, n = (e = this.Duplex()) === null || e === void 0 ? void 0 : e.decodeText(); return Fc(n, hf) }, t.prototype.getPickTrayByPDFSize = function () { var e; return (e = this.PickTrayByPDFSize()) === null || e === void 0 ? void 0 : e.asBoolean() }, t.prototype.getPrintPageRange = function () { var e = this.PrintPageRange(); if (!e) return []; for (var n = [], r = 0; r < e.size(); r += 2) { var i = e.lookup(r, Xe).asNumber(), s = e.lookup(r + 1, Xe).asNumber(); n.push({ start: i, end: s }) } return n }, t.prototype.getNumCopies = function () { var e, n; return (n = (e = this.NumCopies()) === null || e === void 0 ? void 0 : e.asNumber()) !== null && n !== void 0 ? n : 1 }, t.prototype.setHideToolbar = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("HideToolbar"), n) }, t.prototype.setHideMenubar = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("HideMenubar"), n) }, t.prototype.setHideWindowUI = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("HideWindowUI"), n) }, t.prototype.setFitWindow = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("FitWindow"), n) }, t.prototype.setCenterWindow = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("CenterWindow"), n) }, t.prototype.setDisplayDocTitle = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("DisplayDocTitle"), n) }, t.prototype.setNonFullScreenPageMode = function (e) { ao(e, "nonFullScreenPageMode", Pl); var n = O.of(e); this.dict.set(O.of("NonFullScreenPageMode"), n) }, t.prototype.setReadingDirection = function (e) { ao(e, "readingDirection", Tl); var n = O.of(e); this.dict.set(O.of("Direction"), n) }, t.prototype.setPrintScaling = function (e) { ao(e, "printScaling", kl); var n = O.of(e); this.dict.set(O.of("PrintScaling"), n) }, t.prototype.setDuplex = function (e) { ao(e, "duplex", hf); var n = O.of(e); this.dict.set(O.of("Duplex"), n) }, t.prototype.setPickTrayByPDFSize = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("PickTrayByPDFSize"), n) }, t.prototype.setPrintPageRange = function (e) { Array.isArray(e) || (e = [e]); for (var n = [], r = 0, i = e.length; r < i; r++)n.push(e[r].start), n.push(e[r].end); dP(n, "printPageRange", ["number"]); var s = this.dict.context.obj(n); this.dict.set(O.of("PrintPageRange"), s) }, t.prototype.setNumCopies = function (e) { nr(e, "numCopies", 1, Number.MAX_VALUE), JM(e, "numCopies"); var n = this.dict.context.obj(e); this.dict.set(O.of("NumCopies"), n) }, t.fromDict = function (e) { return new t(e) }, t.create = function (e) { var n = e.obj({}); return new t(n) }, t }(), G3 = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+Tf/, TP = function () { function t(e, n) { this.dict = e, this.ref = n } return t.prototype.T = function () { return this.dict.lookupMaybe(O.of("T"), xt, qe) }, t.prototype.Ff = function () { var e = this.getInheritableAttribute(O.of("Ff")); return this.dict.context.lookupMaybe(e, Xe) }, t.prototype.V = function () { var e = this.getInheritableAttribute(O.of("V")); return this.dict.context.lookup(e) }, t.prototype.Kids = function () { return this.dict.lookupMaybe(O.of("Kids"), mt) }, t.prototype.DA = function () { var e = this.dict.lookup(O.of("DA")); if (e instanceof xt || e instanceof qe) return e }, t.prototype.setKids = function (e) { this.dict.set(O.of("Kids"), this.dict.context.obj(e)) }, t.prototype.getParent = function () { var e = this.dict.get(O.of("Parent")); if (e instanceof wt) { var n = this.dict.lookup(O.of("Parent"), et); return new t(n, e) } }, t.prototype.setParent = function (e) { e ? this.dict.set(O.of("Parent"), e) : this.dict.delete(O.of("Parent")) }, t.prototype.getFullyQualifiedName = function () { var e = this.getParent(); return e ? e.getFullyQualifiedName() + "." + this.getPartialName() : this.getPartialName() }, t.prototype.getPartialName = function () { var e; return (e = this.T()) === null || e === void 0 ? void 0 : e.decodeText() }, t.prototype.setPartialName = function (e) { e ? this.dict.set(O.of("T"), qe.fromText(e)) : this.dict.delete(O.of("T")) }, t.prototype.setDefaultAppearance = function (e) { this.dict.set(O.of("DA"), xt.of(e)) }, t.prototype.getDefaultAppearance = function () { var e = this.DA(); return e instanceof qe ? e.decodeText() : e == null ? void 0 : e.asString() }, t.prototype.setFontSize = function (e) { var n, r = (n = this.getFullyQualifiedName()) !== null && n !== void 0 ? n : "", i = this.getDefaultAppearance(); if (!i) throw new i3(r); var s = Fv(i, G3); if (!s.match) throw new o3(r); var a = i.slice(0, s.pos - s.match[0].length), u = s.pos <= i.length ? i.slice(s.pos) : "", c = s.match[1], f = a + " /" + c + " " + e + " Tf " + u; this.setDefaultAppearance(f) }, t.prototype.getFlags = function () { var e, n; return (n = (e = this.Ff()) === null || e === void 0 ? void 0 : e.asNumber()) !== null && n !== void 0 ? n : 0 }, t.prototype.setFlags = function (e) { this.dict.set(O.of("Ff"), Xe.of(e)) }, t.prototype.hasFlag = function (e) { var n = this.getFlags(); return (n & e) !== 0 }, t.prototype.setFlag = function (e) { var n = this.getFlags(); this.setFlags(n | e) }, t.prototype.clearFlag = function (e) { var n = this.getFlags(); this.setFlags(n & ~e) }, t.prototype.setFlagTo = function (e, n) { n ? this.setFlag(e) : this.clearFlag(e) }, t.prototype.getInheritableAttribute = function (e) { var n; return this.ascend(function (r) { n || (n = r.dict.get(e)) }), n }, t.prototype.ascend = function (e) { e(this); var n = this.getParent(); n && n.ascend(e) }, t }(), Ap = function () { function t(e) { this.dict = e } return t.prototype.W = function () { var e = this.dict.lookup(O.of("W")); if (e instanceof Xe) return e }, t.prototype.getWidth = function () { var e, n; return (n = (e = this.W()) === null || e === void 0 ? void 0 : e.asNumber()) !== null && n !== void 0 ? n : 1 }, t.prototype.setWidth = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("W"), n) }, t.fromDict = function (e) { return new t(e) }, t }(), X3 = function () { function t(e) { this.dict = e } return t.prototype.Rect = function () { return this.dict.lookup(O.of("Rect"), mt) }, t.prototype.AP = function () { return this.dict.lookupMaybe(O.of("AP"), et) }, t.prototype.F = function () { var e = this.dict.lookup(O.of("F")); return this.dict.context.lookupMaybe(e, Xe) }, t.prototype.getRectangle = function () { var e, n = this.Rect(); return (e = n == null ? void 0 : n.asRectangle()) !== null && e !== void 0 ? e : { x: 0, y: 0, width: 0, height: 0 } }, t.prototype.setRectangle = function (e) { var n = e.x, r = e.y, i = e.width, s = e.height, a = this.dict.context.obj([n, r, n + i, r + s]); this.dict.set(O.of("Rect"), a) }, t.prototype.getAppearanceState = function () { var e = this.dict.lookup(O.of("AS")); if (e instanceof O) return e }, t.prototype.setAppearanceState = function (e) { this.dict.set(O.of("AS"), e) }, t.prototype.setAppearances = function (e) { this.dict.set(O.of("AP"), e) }, t.prototype.ensureAP = function () { var e = this.AP(); return e || (e = this.dict.context.obj({}), this.dict.set(O.of("AP"), e)), e }, t.prototype.getNormalAppearance = function () { var e = this.ensureAP(), n = e.get(O.of("N")); if (n instanceof wt || n instanceof et) return n; throw new Error("Unexpected N type: " + (n == null ? void 0 : n.constructor.name)) }, t.prototype.setNormalAppearance = function (e) { var n = this.ensureAP(); n.set(O.of("N"), e) }, t.prototype.setRolloverAppearance = function (e) { var n = this.ensureAP(); n.set(O.of("R"), e) }, t.prototype.setDownAppearance = function (e) { var n = this.ensureAP(); n.set(O.of("D"), e) }, t.prototype.removeRolloverAppearance = function () { var e = this.AP(); e == null || e.delete(O.of("R")) }, t.prototype.removeDownAppearance = function () { var e = this.AP(); e == null || e.delete(O.of("D")) }, t.prototype.getAppearances = function () { var e = this.AP(); if (e) { var n = e.lookup(O.of("N"), et, or), r = e.lookupMaybe(O.of("R"), et, or), i = e.lookupMaybe(O.of("D"), et, or); return { normal: n, rollover: r, down: i } } }, t.prototype.getFlags = function () { var e, n; return (n = (e = this.F()) === null || e === void 0 ? void 0 : e.asNumber()) !== null && n !== void 0 ? n : 0 }, t.prototype.setFlags = function (e) { this.dict.set(O.of("F"), Xe.of(e)) }, t.prototype.hasFlag = function (e) { var n = this.getFlags(); return (n & e) !== 0 }, t.prototype.setFlag = function (e) { var n = this.getFlags(); this.setFlags(n | e) }, t.prototype.clearFlag = function (e) { var n = this.getFlags(); this.setFlags(n & ~e) }, t.prototype.setFlagTo = function (e, n) { n ? this.setFlag(e) : this.clearFlag(e) }, t.fromDict = function (e) { return new t(e) }, t }(), Ep = function () { function t(e) { this.dict = e } return t.prototype.R = function () { var e = this.dict.lookup(O.of("R")); if (e instanceof Xe) return e }, t.prototype.BC = function () { var e = this.dict.lookup(O.of("BC")); if (e instanceof mt) return e }, t.prototype.BG = function () { var e = this.dict.lookup(O.of("BG")); if (e instanceof mt) return e }, t.prototype.CA = function () { var e = this.dict.lookup(O.of("CA")); if (e instanceof qe || e instanceof xt) return e }, t.prototype.RC = function () { var e = this.dict.lookup(O.of("RC")); if (e instanceof qe || e instanceof xt) return e }, t.prototype.AC = function () { var e = this.dict.lookup(O.of("AC")); if (e instanceof qe || e instanceof xt) return e }, t.prototype.getRotation = function () { var e; return (e = this.R()) === null || e === void 0 ? void 0 : e.asNumber() }, t.prototype.getBorderColor = function () { var e = this.BC(); if (e) { for (var n = [], r = 0, i = e == null ? void 0 : e.size(); r < i; r++) { var s = e.get(r); s instanceof Xe && n.push(s.asNumber()) } return n } }, t.prototype.getBackgroundColor = function () { var e = this.BG(); if (e) { for (var n = [], r = 0, i = e == null ? void 0 : e.size(); r < i; r++) { var s = e.get(r); s instanceof Xe && n.push(s.asNumber()) } return n } }, t.prototype.getCaptions = function () { var e = this.CA(), n = this.RC(), r = this.AC(); return { normal: e == null ? void 0 : e.decodeText(), rollover: n == null ? void 0 : n.decodeText(), down: r == null ? void 0 : r.decodeText() } }, t.prototype.setRotation = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("R"), n) }, t.prototype.setBorderColor = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("BC"), n) }, t.prototype.setBackgroundColor = function (e) { var n = this.dict.context.obj(e); this.dict.set(O.of("BG"), n) }, t.prototype.setCaptions = function (e) { var n = qe.fromText(e.normal); if (this.dict.set(O.of("CA"), n), e.rollover) { var r = qe.fromText(e.rollover); this.dict.set(O.of("RC"), r) } else this.dict.delete(O.of("RC")); if (e.down) { var i = qe.fromText(e.down); this.dict.set(O.of("AC"), i) } else this.dict.delete(O.of("AC")) }, t.fromDict = function (e) { return new t(e) }, t }(), m0 = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.MK = function () { var n = this.dict.lookup(O.of("MK")); if (n instanceof et) return n }, e.prototype.BS = function () { var n = this.dict.lookup(O.of("BS")); if (n instanceof et) return n }, e.prototype.DA = function () { var n = this.dict.lookup(O.of("DA")); if (n instanceof xt || n instanceof qe) return n }, e.prototype.P = function () { var n = this.dict.get(O.of("P")); if (n instanceof wt) return n }, e.prototype.setP = function (n) { this.dict.set(O.of("P"), n) }, e.prototype.setDefaultAppearance = function (n) { this.dict.set(O.of("DA"), xt.of(n)) }, e.prototype.getDefaultAppearance = function () { var n = this.DA(); return n instanceof qe ? n.decodeText() : n == null ? void 0 : n.asString() }, e.prototype.getAppearanceCharacteristics = function () { var n = this.MK(); if (n) return Ep.fromDict(n) }, e.prototype.getOrCreateAppearanceCharacteristics = function () { var n = this.MK(); if (n) return Ep.fromDict(n); var r = Ep.fromDict(this.dict.context.obj({})); return this.dict.set(O.of("MK"), r.dict), r }, e.prototype.getBorderStyle = function () { var n = this.BS(); if (n) return Ap.fromDict(n) }, e.prototype.getOrCreateBorderStyle = function () { var n = this.BS(); if (n) return Ap.fromDict(n); var r = Ap.fromDict(this.dict.context.obj({})); return this.dict.set(O.of("BS"), r.dict), r }, e.prototype.getOnValue = function () { var n, r = (n = this.getAppearances()) === null || n === void 0 ? void 0 : n.normal; if (r instanceof et) for (var i = r.keys(), s = 0, a = i.length; s < a; s++) { var u = i[s]; if (u !== O.of("Off")) return u } }, e.fromDict = function (n) { return new e(n) }, e.create = function (n, r) { var i = n.obj({ Type: "Annot", Subtype: "Widget", Rect: [0, 0, 0, 0], Parent: r }); return new e(i) }, e }(X3), ua = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.FT = function () { var n = this.getInheritableAttribute(O.of("FT")); return this.dict.context.lookup(n, O) }, e.prototype.getWidgets = function () { var n = this.Kids(); if (!n) return [m0.fromDict(this.dict)]; for (var r = new Array(n.size()), i = 0, s = n.size(); i < s; i++) { var a = n.lookup(i, et); r[i] = m0.fromDict(a) } return r }, e.prototype.addWidget = function (n) { var r = this.normalizedEntries().Kids; r.push(n) }, e.prototype.removeWidget = function (n) { var r = this.Kids(); if (r) { if (n < 0 || n > r.size()) throw new ff(n, 0, r.size()); r.remove(n) } else { if (n !== 0) throw new ff(n, 0, 0); this.setKids([]) } }, e.prototype.normalizedEntries = function () { var n = this.Kids(); return n || (n = this.dict.context.obj([this.ref]), this.dict.set(O.of("Kids"), n)), { Kids: n } }, e.fromDict = function (n, r) { return new e(n, r) }, e }(TP), jv = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.Opt = function () { return this.dict.lookupMaybe(O.of("Opt"), xt, qe, mt) }, e.prototype.setOpt = function (n) { this.dict.set(O.of("Opt"), this.dict.context.obj(n)) }, e.prototype.getExportValues = function () { var n = this.Opt(); if (n) { if (n instanceof xt || n instanceof qe) return [n]; for (var r = [], i = 0, s = n.size(); i < s; i++) { var a = n.lookup(i); (a instanceof xt || a instanceof qe) && r.push(a) } return r } }, e.prototype.removeExportValue = function (n) { var r = this.Opt(); if (r) if (r instanceof xt || r instanceof qe) { if (n !== 0) throw new ff(n, 0, 0); this.setOpt([]) } else { if (n < 0 || n > r.size()) throw new ff(n, 0, r.size()); r.remove(n) } }, e.prototype.normalizeExportValues = function () { for (var n, r, i, s, a = (n = this.getExportValues()) !== null && n !== void 0 ? n : [], u = [], c = this.getWidgets(), f = 0, h = c.length; f < h; f++) { var v = c[f], m = (r = a[f]) !== null && r !== void 0 ? r : qe.fromText((s = (i = v.getOnValue()) === null || i === void 0 ? void 0 : i.decodeText()) !== null && s !== void 0 ? s : ""); u.push(m) } this.setOpt(u) }, e.prototype.addOpt = function (n, r) { var i; this.normalizeExportValues(); var s = n.decodeText(), a; if (r) for (var u = (i = this.getExportValues()) !== null && i !== void 0 ? i : [], c = 0, f = u.length; c < f; c++) { var h = u[c]; h.decodeText() === s && (a = c) } var v = this.Opt(); return v.push(n), a ?? v.size() - 1 }, e.prototype.addWidgetWithOpt = function (n, r, i) { var s = this.addOpt(r, i), a = O.of(String(s)); return this.addWidget(n), a }, e }(ua), Kf = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.setValue = function (n) { var r, i = (r = this.getOnValue()) !== null && r !== void 0 ? r : O.of("Yes"); if (n !== i && n !== O.of("Off")) throw new Mv; this.dict.set(O.of("V"), n); for (var s = this.getWidgets(), a = 0, u = s.length; a < u; a++) { var c = s[a], f = c.getOnValue() === n ? n : O.of("Off"); c.setAppearanceState(f) } }, e.prototype.getValue = function () { var n = this.V(); return n instanceof O ? n : O.of("Off") }, e.prototype.getOnValue = function () { var n = this.getWidgets()[0]; return n == null ? void 0 : n.getOnValue() }, e.fromDict = function (n, r) { return new e(n, r) }, e.create = function (n) { var r = n.obj({ FT: "Btn", Kids: [] }), i = n.register(r); return new e(r, i) }, e }(jv), _t = function (t) { return 1 << t }, Kr; (function (t) { t[t.ReadOnly = _t(0)] = "ReadOnly", t[t.Required = _t(1)] = "Required", t[t.NoExport = _t(2)] = "NoExport" })(Kr || (Kr = {})); var Tr; (function (t) { t[t.NoToggleToOff = _t(14)] = "NoToggleToOff", t[t.Radio = _t(15)] = "Radio", t[t.PushButton = _t(16)] = "PushButton", t[t.RadiosInUnison = _t(25)] = "RadiosInUnison" })(Tr || (Tr = {})); var Nt; (function (t) { t[t.Multiline = _t(12)] = "Multiline", t[t.Password = _t(13)] = "Password", t[t.FileSelect = _t(20)] = "FileSelect", t[t.DoNotSpellCheck = _t(22)] = "DoNotSpellCheck", t[t.DoNotScroll = _t(23)] = "DoNotScroll", t[t.Comb = _t(24)] = "Comb", t[t.RichText = _t(25)] = "RichText" })(Nt || (Nt = {})); var yt; (function (t) { t[t.Combo = _t(17)] = "Combo", t[t.Edit = _t(18)] = "Edit", t[t.Sort = _t(19)] = "Sort", t[t.MultiSelect = _t(21)] = "MultiSelect", t[t.DoNotSpellCheck = _t(22)] = "DoNotSpellCheck", t[t.CommitOnSelChange = _t(26)] = "CommitOnSelChange" })(yt || (yt = {})); var kP = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.setValues = function (n) { if (this.hasFlag(yt.Combo) && !this.hasFlag(yt.Edit) && !this.valuesAreValid(n)) throw new Mv; if (n.length === 0 && this.dict.delete(O.of("V")), n.length === 1 && this.dict.set(O.of("V"), n[0]), n.length > 1) { if (!this.hasFlag(yt.MultiSelect)) throw new r3; this.dict.set(O.of("V"), this.dict.context.obj(n)) } this.updateSelectedIndices(n) }, e.prototype.valuesAreValid = function (n) { for (var r = this.getOptions(), i = function (c, f) { var h = n[c].decodeText(); if (!r.find(function (v) { return h === (v.display || v.value).decodeText() })) return { value: !1 } }, s = 0, a = n.length; s < a; s++) { var u = i(s); if (typeof u == "object") return u.value } return !0 }, e.prototype.updateSelectedIndices = function (n) { if (n.length > 1) { for (var r = new Array(n.length), i = this.getOptions(), s = function (c, f) { var h = n[c].decodeText(); r[c] = i.findIndex(function (v) { return h === (v.display || v.value).decodeText() }) }, a = 0, u = n.length; a < u; a++)s(a, u); this.dict.set(O.of("I"), this.dict.context.obj(r.sort())) } else this.dict.delete(O.of("I")) }, e.prototype.getValues = function () { var n = this.V(); if (n instanceof xt || n instanceof qe) return [n]; if (n instanceof mt) { for (var r = [], i = 0, s = n.size(); i < s; i++) { var a = n.lookup(i); (a instanceof xt || a instanceof qe) && r.push(a) } return r } return [] }, e.prototype.Opt = function () { return this.dict.lookupMaybe(O.of("Opt"), xt, qe, mt) }, e.prototype.setOptions = function (n) { for (var r = new Array(n.length), i = 0, s = n.length; i < s; i++) { var a = n[i], u = a.value, c = a.display; r[i] = this.dict.context.obj([u, c || u]) } this.dict.set(O.of("Opt"), this.dict.context.obj(r)) }, e.prototype.getOptions = function () { var n = this.Opt(); if (n instanceof xt || n instanceof qe) return [{ value: n, display: n }]; if (n instanceof mt) { for (var r = [], i = 0, s = n.size(); i < s; i++) { var a = n.lookup(i); if ((a instanceof xt || a instanceof qe) && r.push({ value: a, display: a }), a instanceof mt && a.size() > 0) { var u = a.lookup(0, xt, qe), c = a.lookupMaybe(1, xt, qe); r.push({ value: u, display: c || u }) } } return r } return [] }, e }(ua), Hf = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.fromDict = function (n, r) { return new e(n, r) }, e.create = function (n) { var r = n.obj({ FT: "Ch", Ff: yt.Combo, Kids: [] }), i = n.register(r); return new e(r, i) }, e }(kP), pf = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.addField = function (n) { var r = this.normalizedEntries().Kids; r == null || r.push(n) }, e.prototype.normalizedEntries = function () { var n = this.Kids(); return n || (n = this.dict.context.obj([]), this.dict.set(O.of("Kids"), n)), { Kids: n } }, e.fromDict = function (n, r) { return new e(n, r) }, e.create = function (n) { var r = n.obj({}), i = n.register(r); return new e(r, i) }, e }(TP), Iv = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.fromDict = function (n, r) { return new e(n, r) }, e }(ua), qf = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.MaxLen = function () { var n = this.dict.lookup(O.of("MaxLen")); if (n instanceof Xe) return n }, e.prototype.Q = function () { var n = this.dict.lookup(O.of("Q")); if (n instanceof Xe) return n }, e.prototype.setMaxLength = function (n) { this.dict.set(O.of("MaxLen"), Xe.of(n)) }, e.prototype.removeMaxLength = function () { this.dict.delete(O.of("MaxLen")) }, e.prototype.getMaxLength = function () { var n; return (n = this.MaxLen()) === null || n === void 0 ? void 0 : n.asNumber() }, e.prototype.setQuadding = function (n) { this.dict.set(O.of("Q"), Xe.of(n)) }, e.prototype.getQuadding = function () { var n; return (n = this.Q()) === null || n === void 0 ? void 0 : n.asNumber() }, e.prototype.setValue = function (n) { this.dict.set(O.of("V"), n) }, e.prototype.removeValue = function () { this.dict.delete(O.of("V")) }, e.prototype.getValue = function () { var n = this.V(); if (n instanceof xt || n instanceof qe) return n }, e.fromDict = function (n, r) { return new e(n, r) }, e.create = function (n) { var r = n.obj({ FT: "Tx", Kids: [] }), i = n.register(r); return new e(r, i) }, e }(ua), Gf = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.fromDict = function (n, r) { return new e(n, r) }, e.create = function (n) { var r = n.obj({ FT: "Btn", Ff: Tr.PushButton, Kids: [] }), i = n.register(r); return new e(r, i) }, e }(jv), Xf = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.setValue = function (n) { var r = this.getOnValues(); if (!r.includes(n) && n !== O.of("Off")) throw new Mv; this.dict.set(O.of("V"), n); for (var i = this.getWidgets(), s = 0, a = i.length; s < a; s++) { var u = i[s], c = u.getOnValue() === n ? n : O.of("Off"); u.setAppearanceState(c) } }, e.prototype.getValue = function () { var n = this.V(); return n instanceof O ? n : O.of("Off") }, e.prototype.getOnValues = function () { for (var n = this.getWidgets(), r = [], i = 0, s = n.length; i < s; i++) { var a = n[i].getOnValue(); a && r.push(a) } return r }, e.fromDict = function (n, r) { return new e(n, r) }, e.create = function (n) { var r = n.obj({ FT: "Btn", Ff: Tr.Radio, Kids: [] }), i = n.register(r); return new e(r, i) }, e }(jv), Zf = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.fromDict = function (n, r) { return new e(n, r) }, e.create = function (n) { var r = n.obj({ FT: "Ch", Kids: [] }), i = n.register(r); return new e(r, i) }, e }(kP), zv = function (t) { if (!t) return []; for (var e = [], n = 0, r = t.size(); n < r; n++) { var i = t.get(n), s = t.lookup(n); i instanceof wt && s instanceof et && e.push([AP(s, i), i]) } return e }, AP = function (t, e) { var n = Z3(t); return n ? pf.fromDict(t, e) : Y3(t, e) }, Z3 = function (t) { var e = t.lookup(O.of("Kids")); if (e instanceof mt) for (var n = 0, r = e.size(); n < r; n++) { var i = e.lookup(n), s = i instanceof et && i.has(O.of("T")); if (s) return !0 } return !1 }, Y3 = function (t, e) { var n = Uv(t, O.of("FT")), r = t.context.lookup(n, O); return r === O.of("Btn") ? Q3(t, e) : r === O.of("Ch") ? J3(t, e) : r === O.of("Tx") ? qf.fromDict(t, e) : r === O.of("Sig") ? Iv.fromDict(t, e) : ua.fromDict(t, e) }, Q3 = function (t, e) { var n, r = Uv(t, O.of("Ff")), i = t.context.lookupMaybe(r, Xe), s = (n = i == null ? void 0 : i.asNumber()) !== null && n !== void 0 ? n : 0; return g0(s, Tr.PushButton) ? Gf.fromDict(t, e) : g0(s, Tr.Radio) ? Xf.fromDict(t, e) : Kf.fromDict(t, e) }, J3 = function (t, e) { var n, r = Uv(t, O.of("Ff")), i = t.context.lookupMaybe(r, Xe), s = (n = i == null ? void 0 : i.asNumber()) !== null && n !== void 0 ? n : 0; return g0(s, yt.Combo) ? Hf.fromDict(t, e) : Zf.fromDict(t, e) }, g0 = function (t, e) { return (t & e) !== 0 }, Uv = function (t, e) { var n; return EP(t, function (r) { n || (n = r.get(e)) }), n }, EP = function (t, e) { e(t); var n = t.lookupMaybe(O.of("Parent"), et); n && EP(n, e) }, vf = function () { function t(e) { this.dict = e } return t.prototype.Fields = function () { var e = this.dict.lookup(O.of("Fields")); if (e instanceof mt) return e }, t.prototype.getFields = function () { for (var e = this.normalizedEntries().Fields, n = new Array(e.size()), r = 0, i = e.size(); r < i; r++) { var s = e.get(r), a = e.lookup(r, et); n[r] = [AP(a, s), s] } return n }, t.prototype.getAllFields = function () { var e = [], n = function (r) { if (r) for (var i = 0, s = r.length; i < s; i++) { var a = r[i]; e.push(a); var u = a[0]; u instanceof pf && n(zv(u.Kids())) } }; return n(this.getFields()), e }, t.prototype.addField = function (e) { var n = this.normalizedEntries().Fields; n == null || n.push(e) }, t.prototype.removeField = function (e) { var n = e.getParent(), r = n === void 0 ? this.normalizedEntries().Fields : n.Kids(), i = r == null ? void 0 : r.indexOf(e.ref); if (r === void 0 || i === void 0) throw new Error("Tried to remove inexistent field " + e.getFullyQualifiedName()); r.remove(i), n !== void 0 && r.size() === 0 && this.removeField(n) }, t.prototype.normalizedEntries = function () { var e = this.Fields(); return e || (e = this.dict.context.obj([]), this.dict.set(O.of("Fields"), e)), { Fields: e } }, t.fromDict = function (e) { return new t(e) }, t.create = function (e) { var n = e.obj({ Fields: [] }); return new t(n) }, t }(), FP = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.Pages = function () { return this.lookup(O.of("Pages"), et) }, e.prototype.AcroForm = function () { return this.lookupMaybe(O.of("AcroForm"), et) }, e.prototype.getAcroForm = function () { var n = this.AcroForm(); if (n) return vf.fromDict(n) }, e.prototype.getOrCreateAcroForm = function () { var n = this.getAcroForm(); if (!n) { n = vf.create(this.context); var r = this.context.register(n.dict); this.set(O.of("AcroForm"), r) } return n }, e.prototype.ViewerPreferences = function () { return this.lookupMaybe(O.of("ViewerPreferences"), et) }, e.prototype.getViewerPreferences = function () { var n = this.ViewerPreferences(); if (n) return Tw.fromDict(n) }, e.prototype.getOrCreateViewerPreferences = function () { var n = this.getViewerPreferences(); if (!n) { n = Tw.create(this.context); var r = this.context.register(n.dict); this.set(O.of("ViewerPreferences"), r) } return n }, e.prototype.insertLeafNode = function (n, r) { var i = this.get(O.of("Pages")), s = this.Pages().insertLeafNode(n, r); return s || i }, e.prototype.removeLeafNode = function (n) { this.Pages().removeLeafNode(n) }, e.withContextAndPages = function (n, r) { var i = new Map; return i.set(O.of("Type"), O.of("Catalog")), i.set(O.of("Pages"), r), new e(i, n) }, e.fromMapWithContext = function (n, r) { return new e(n, r) }, e }(et), RP = function (t) { we(e, t); function e() { return t !== null && t.apply(this, arguments) || this } return e.prototype.Parent = function () { return this.lookup(O.of("Parent")) }, e.prototype.Kids = function () { return this.lookup(O.of("Kids"), mt) }, e.prototype.Count = function () { return this.lookup(O.of("Count"), Xe) }, e.prototype.pushTreeNode = function (n) { var r = this.Kids(); r.push(n) }, e.prototype.pushLeafNode = function (n) { var r = this.Kids(); this.insertLeafKid(r.size(), n) }, e.prototype.insertLeafNode = function (n, r) { var i = this.Kids(), s = this.Count().asNumber(); if (r > s) throw new dw(r, s); for (var a = r, u = 0, c = i.size(); u < c; u++) { if (a === 0) { this.insertLeafKid(u, n); return } var f = i.get(u), h = this.context.lookup(f); if (h instanceof e) { if (h.Count().asNumber() > a) return h.insertLeafNode(n, a) || f; a -= h.Count().asNumber() } h instanceof Ai && (a -= 1) } if (a === 0) { this.insertLeafKid(i.size(), n); return } throw new hw(r, "insertLeafNode") }, e.prototype.removeLeafNode = function (n, r) { r === void 0 && (r = !0); var i = this.Kids(), s = this.Count().asNumber(); if (n >= s) throw new dw(n, s); for (var a = n, u = 0, c = i.size(); u < c; u++) { var f = i.get(u), h = this.context.lookup(f); if (h instanceof e) if (h.Count().asNumber() > a) { h.removeLeafNode(a, r), r && h.Kids().size() === 0 && i.remove(u); return } else a -= h.Count().asNumber(); if (h instanceof Ai) if (a === 0) { this.removeKid(u); return } else a -= 1 } throw new hw(n, "removeLeafNode") }, e.prototype.ascend = function (n) { n(this); var r = this.Parent(); r && r.ascend(n) }, e.prototype.traverse = function (n) { for (var r = this.Kids(), i = 0, s = r.size(); i < s; i++) { var a = r.get(i), u = this.context.lookup(a); u instanceof e && u.traverse(n), n(u, a) } }, e.prototype.insertLeafKid = function (n, r) { var i = this.Kids(); this.ascend(function (s) { var a = s.Count().asNumber() + 1; s.set(O.of("Count"), Xe.of(a)) }), i.insert(n, r) }, e.prototype.removeKid = function (n) { var r = this.Kids(), i = r.lookup(n); i instanceof Ai && this.ascend(function (s) { var a = s.Count().asNumber() - 1; s.set(O.of("Count"), Xe.of(a)) }), r.remove(n) }, e.withContext = function (n, r) { var i = new Map; return i.set(O.of("Type"), O.of("Pages")), i.set(O.of("Kids"), n.obj([])), i.set(O.of("Count"), n.obj(0)), r && i.set(O.of("Parent"), r), new e(i, n) }, e.fromMapWithContext = function (n, r) { return new e(n, r) }, e }(et), Rn = new Uint8Array(256); Rn[M.Zero] = 1; Rn[M.One] = 1; Rn[M.Two] = 1; Rn[M.Three] = 1; Rn[M.Four] = 1; Rn[M.Five] = 1; Rn[M.Six] = 1; Rn[M.Seven] = 1; Rn[M.Eight] = 1; Rn[M.Nine] = 1; var Yf = new Uint8Array(256); Yf[M.Period] = 1; Yf[M.Plus] = 1; Yf[M.Minus] = 1; var Wv = new Uint8Array(256); for (var tl = 0, _3 = 256; tl < _3; tl++)Wv[tl] = Rn[tl] || Yf[tl] ? 1 : 0; var kw = M.Newline, Aw = M.CarriageReturn, $3 = function () { function t(e, n) { n === void 0 && (n = !1), this.bytes = e, this.capNumbers = n } return t.prototype.parseRawInt = function () { for (var e = ""; !this.bytes.done();) { var n = this.bytes.peek(); if (!Rn[n]) break; e += Ti(this.bytes.next()) } var r = Number(e); if (!e || !isFinite(r)) throw new pw(this.bytes.position(), e); return r }, t.prototype.parseRawNumber = function () { for (var e = ""; !this.bytes.done();) { var n = this.bytes.peek(); if (!Wv[n] || (e += Ti(this.bytes.next()), n === M.Period)) break } for (; !this.bytes.done();) { var n = this.bytes.peek(); if (!Rn[n]) break; e += Ti(this.bytes.next()) } var r = Number(e); if (!e || !isFinite(r)) throw new pw(this.bytes.position(), e); if (r > Number.MAX_SAFE_INTEGER) if (this.capNumbers) { var i = "Parsed number that is too large for some PDF readers: " + e + ", using Number.MAX_SAFE_INTEGER instead."; return console.warn(i), Number.MAX_SAFE_INTEGER } else { var i = "Parsed number that is too large for some PDF readers: " + e + ", not capping."; console.warn(i) } return r }, t.prototype.skipWhitespace = function () { for (; !this.bytes.done() && Vi[this.bytes.peek()];)this.bytes.next() }, t.prototype.skipLine = function () { for (; !this.bytes.done();) { var e = this.bytes.peek(); if (e === kw || e === Aw) return; this.bytes.next() } }, t.prototype.skipComment = function () { if (this.bytes.peek() !== M.Percent) return !1; for (; !this.bytes.done();) { var e = this.bytes.peek(); if (e === kw || e === Aw) return !0; this.bytes.next() } return !0 }, t.prototype.skipWhitespaceAndComments = function () { for (this.skipWhitespace(); this.skipComment();)this.skipWhitespace() }, t.prototype.matchKeyword = function (e) { for (var n = this.bytes.offset(), r = 0, i = e.length; r < i; r++)if (this.bytes.done() || this.bytes.next() !== e[r]) return this.bytes.moveTo(n), !1; return !0 }, t }(), Qf = function () { function t(e) { this.idx = 0, this.line = 0, this.column = 0, this.bytes = e, this.length = this.bytes.length } return t.prototype.moveTo = function (e) { this.idx = e }, t.prototype.next = function () { var e = this.bytes[this.idx++]; return e === M.Newline ? (this.line += 1, this.column = 0) : this.column += 1, e }, t.prototype.assertNext = function (e) { if (this.peek() !== e) throw new s3(this.position(), e, this.peek()); return this.next() }, t.prototype.peek = function () { return this.bytes[this.idx] }, t.prototype.peekAhead = function (e) { return this.bytes[this.idx + e] }, t.prototype.peekAt = function (e) { return this.bytes[e] }, t.prototype.done = function () { return this.idx >= this.length }, t.prototype.offset = function () { return this.idx }, t.prototype.slice = function (e, n) { return this.bytes.slice(e, n) }, t.prototype.position = function () { return { line: this.line, column: this.column, offset: this.idx } }, t.of = function (e) { return new t(e) }, t.fromPDFRawStream = function (e) { return t.of(CP(e).decode()) }, t }(), e5 = M.Space, nl = M.CarriageReturn, rl = M.Newline, il = [M.s, M.t, M.r, M.e, M.a, M.m], Rc = [M.e, M.n, M.d, M.s, M.t, M.r, M.e, M.a, M.m], Tt = { header: [M.Percent, M.P, M.D, M.F, M.Dash], eof: [M.Percent, M.Percent, M.E, M.O, M.F], obj: [M.o, M.b, M.j], endobj: [M.e, M.n, M.d, M.o, M.b, M.j], xref: [M.x, M.r, M.e, M.f], trailer: [M.t, M.r, M.a, M.i, M.l, M.e, M.r], startxref: [M.s, M.t, M.a, M.r, M.t, M.x, M.r, M.e, M.f], true: [M.t, M.r, M.u, M.e], false: [M.f, M.a, M.l, M.s, M.e], null: [M.n, M.u, M.l, M.l], stream: il, streamEOF1: ft(il, [e5, nl, rl]), streamEOF2: ft(il, [nl, rl]), streamEOF3: ft(il, [nl]), streamEOF4: ft(il, [rl]), endstream: Rc, EOF1endstream: ft([nl, rl], Rc), EOF2endstream: ft([nl], Rc), EOF3endstream: ft([rl], Rc) }, DP = function (t) { we(e, t); function e(n, r, i) { i === void 0 && (i = !1); var s = t.call(this, n, i) || this; return s.context = r, s } return e.prototype.parseObject = function () { if (this.skipWhitespaceAndComments(), this.matchKeyword(Tt.true)) return zl.True; if (this.matchKeyword(Tt.false)) return zl.False; if (this.matchKeyword(Tt.null)) return Xn; var n = this.bytes.peek(); if (n === M.LessThan && this.bytes.peekAhead(1) === M.LessThan) return this.parseDictOrStream(); if (n === M.LessThan) return this.parseHexString(); if (n === M.LeftParen) return this.parseString(); if (n === M.ForwardSlash) return this.parseName(); if (n === M.LeftSquareBracket) return this.parseArray(); if (Wv[n]) return this.parseNumberOrRef(); throw new a3(this.bytes.position(), n) }, e.prototype.parseNumberOrRef = function () { var n = this.parseRawNumber(); this.skipWhitespaceAndComments(); var r = this.bytes.offset(); if (Rn[this.bytes.peek()]) { var i = this.parseRawNumber(); if (this.skipWhitespaceAndComments(), this.bytes.peek() === M.R) return this.bytes.assertNext(M.R), wt.of(n, i) } return this.bytes.moveTo(r), Xe.of(n) }, e.prototype.parseHexString = function () { var n = ""; for (this.bytes.assertNext(M.LessThan); !this.bytes.done() && this.bytes.peek() !== M.GreaterThan;)n += Ti(this.bytes.next()); return this.bytes.assertNext(M.GreaterThan), qe.of(n) }, e.prototype.parseString = function () { for (var n = 0, r = !1, i = ""; !this.bytes.done();) { var s = this.bytes.next(); if (i += Ti(s), r || (s === M.LeftParen && (n += 1), s === M.RightParen && (n -= 1)), s === M.BackSlash ? r = !r : r && (r = !1), n === 0) return xt.of(i.substring(1, i.length - 1)) } throw new c3(this.bytes.position()) }, e.prototype.parseName = function () { this.bytes.assertNext(M.ForwardSlash); for (var n = ""; !this.bytes.done();) { var r = this.bytes.peek(); if (Vi[r] || Dr[r]) break; n += Ti(r), this.bytes.next() } return O.of(n) }, e.prototype.parseArray = function () { this.bytes.assertNext(M.LeftSquareBracket), this.skipWhitespaceAndComments(); for (var n = mt.withContext(this.context); this.bytes.peek() !== M.RightSquareBracket;) { var r = this.parseObject(); n.push(r), this.skipWhitespaceAndComments() } return this.bytes.assertNext(M.RightSquareBracket), n }, e.prototype.parseDict = function () { this.bytes.assertNext(M.LessThan), this.bytes.assertNext(M.LessThan), this.skipWhitespaceAndComments(); for (var n = new Map; !this.bytes.done() && this.bytes.peek() !== M.GreaterThan && this.bytes.peekAhead(1) !== M.GreaterThan;) { var r = this.parseName(), i = this.parseObject(); n.set(r, i), this.skipWhitespaceAndComments() } this.skipWhitespaceAndComments(), this.bytes.assertNext(M.GreaterThan), this.bytes.assertNext(M.GreaterThan); var s = n.get(O.of("Type")); return s === O.of("Catalog") ? FP.fromMapWithContext(n, this.context) : s === O.of("Pages") ? RP.fromMapWithContext(n, this.context) : s === O.of("Page") ? Ai.fromMapWithContext(n, this.context) : et.fromMapWithContext(n, this.context) }, e.prototype.parseDictOrStream = function () { var n = this.bytes.position(), r = this.parseDict(); if (this.skipWhitespaceAndComments(), !this.matchKeyword(Tt.streamEOF1) && !this.matchKeyword(Tt.streamEOF2) && !this.matchKeyword(Tt.streamEOF3) && !this.matchKeyword(Tt.streamEOF4) && !this.matchKeyword(Tt.stream)) return r; var i = this.bytes.offset(), s, a = r.get(O.of("Length")); a instanceof Xe ? (s = i + a.asNumber(), this.bytes.moveTo(s), this.skipWhitespaceAndComments(), this.matchKeyword(Tt.endstream) || (this.bytes.moveTo(i), s = this.findEndOfStreamFallback(n))) : s = this.findEndOfStreamFallback(n); var u = this.bytes.slice(i, s); return Ul.of(r, u) }, e.prototype.findEndOfStreamFallback = function (n) { for (var r = 1, i = this.bytes.offset(); !this.bytes.done() && (i = this.bytes.offset(), this.matchKeyword(Tt.stream) ? r += 1 : this.matchKeyword(Tt.EOF1endstream) || this.matchKeyword(Tt.EOF2endstream) || this.matchKeyword(Tt.EOF3endstream) || this.matchKeyword(Tt.endstream) ? r -= 1 : this.bytes.next(), r !== 0);); if (r !== 0) throw new u3(n); return i }, e.forBytes = function (n, r, i) { return new e(Qf.of(n), r, i) }, e.forByteStream = function (n, r, i) { return i === void 0 && (i = !1), new e(n, r, i) }, e }($3), t5 = function (t) { we(e, t); function e(n, r) { var i = t.call(this, Qf.fromPDFRawStream(n), n.dict.context) || this, s = n.dict; return i.alreadyParsed = !1, i.shouldWaitForTick = r || function () { return !1 }, i.firstOffset = s.lookup(O.of("First"), Xe).asNumber(), i.objectCount = s.lookup(O.of("N"), Xe).asNumber(), i } return e.prototype.parseIntoContext = function () { return tt(this, void 0, void 0, function () { var n, r, i, s, a, u, c, f; return nt(this, function (h) { switch (h.label) { case 0: if (this.alreadyParsed) throw new Ov("PDFObjectStreamParser", "parseIntoContext"); this.alreadyParsed = !0, n = this.parseOffsetsAndObjectNumbers(), r = 0, i = n.length, h.label = 1; case 1: return r < i ? (s = n[r], a = s.objectNumber, u = s.offset, this.bytes.moveTo(this.firstOffset + u), c = this.parseObject(), f = wt.of(a, 0), this.context.assign(f, c), this.shouldWaitForTick() ? [4, na()] : [3, 3]) : [3, 4]; case 2: h.sent(), h.label = 3; case 3: return r++, [3, 1]; case 4: return [2] } }) }) }, e.prototype.parseOffsetsAndObjectNumbers = function () { for (var n = [], r = 0, i = this.objectCount; r < i; r++) { this.skipWhitespaceAndComments(); var s = this.parseRawInt(); this.skipWhitespaceAndComments(); var a = this.parseRawInt(); n.push({ objectNumber: s, offset: a }) } return n }, e.forStream = function (n, r) { return new e(n, r) }, e }(DP), n5 = function () { function t(e) { this.alreadyParsed = !1, this.dict = e.dict, this.bytes = Qf.fromPDFRawStream(e), this.context = this.dict.context; var n = this.dict.lookup(O.of("Size"), Xe), r = this.dict.lookup(O.of("Index")); if (r instanceof mt) { this.subsections = []; for (var i = 0, s = r.size(); i < s; i += 2) { var a = r.lookup(i + 0, Xe).asNumber(), u = r.lookup(i + 1, Xe).asNumber(); this.subsections.push({ firstObjectNumber: a, length: u }) } } else this.subsections = [{ firstObjectNumber: 0, length: n.asNumber() }]; var c = this.dict.lookup(O.of("W"), mt); this.byteWidths = [-1, -1, -1]; for (var i = 0, s = c.size(); i < s; i++)this.byteWidths[i] = c.lookup(i, Xe).asNumber() } return t.prototype.parseIntoContext = function () { if (this.alreadyParsed) throw new Ov("PDFXRefStreamParser", "parseIntoContext"); this.alreadyParsed = !0, this.context.trailerInfo = { Root: this.dict.get(O.of("Root")), Encrypt: this.dict.get(O.of("Encrypt")), Info: this.dict.get(O.of("Info")), ID: this.dict.get(O.of("ID")) }; var e = this.parseEntries(); return e }, t.prototype.parseEntries = function () { for (var e = [], n = this.byteWidths, r = n[0], i = n[1], s = n[2], a = 0, u = this.subsections.length; a < u; a++)for (var c = this.subsections[a], f = c.firstObjectNumber, h = c.length, v = 0; v < h; v++) { for (var m = 0, g = 0, S = r; g < S; g++)m = m << 8 | this.bytes.next(); for (var b = 0, g = 0, S = i; g < S; g++)b = b << 8 | this.bytes.next(); for (var P = 0, g = 0, S = s; g < S; g++)P = P << 8 | this.bytes.next(); r === 0 && (m = 1); var C = f + v, F = { ref: wt.of(C, P), offset: b, deleted: m === 0, inObjectStream: m === 2 }; e.push(F) } return e }, t.forStream = function (e) { return new t(e) }, t }(), r5 = function (t) { we(e, t); function e(n, r, i, s) { r === void 0 && (r = 1 / 0), i === void 0 && (i = !1), s === void 0 && (s = !1); var a = t.call(this, Qf.of(n), p0.create(), s) || this; return a.alreadyParsed = !1, a.parsedObjects = 0, a.shouldWaitForTick = function () { return a.parsedObjects += 1, a.parsedObjects % a.objectsPerTick === 0 }, a.objectsPerTick = r, a.throwOnInvalidObject = i, a } return e.prototype.parseDocument = function () { return tt(this, void 0, void 0, function () { var n, r; return nt(this, function (i) { switch (i.label) { case 0: if (this.alreadyParsed) throw new Ov("PDFParser", "parseDocument"); this.alreadyParsed = !0, this.context.header = this.parseHeader(), i.label = 1; case 1: return this.bytes.done() ? [3, 3] : [4, this.parseDocumentSection()]; case 2: if (i.sent(), r = this.bytes.offset(), r === n) throw new f3(this.bytes.position()); return n = r, [3, 1]; case 3: return this.maybeRecoverRoot(), this.context.lookup(wt.of(0)) && (console.warn("Removing parsed object: 0 0 R"), this.context.delete(wt.of(0))), [2, this.context] } }) }) }, e.prototype.maybeRecoverRoot = function () { var n = function (h) { return h instanceof et && h.lookup(O.of("Type")) === O.of("Catalog") }, r = this.context.lookup(this.context.trailerInfo.Root); if (!n(r)) for (var i = this.context.enumerateIndirectObjects(), s = 0, a = i.length; s < a; s++) { var u = i[s], c = u[0], f = u[1]; n(f) && (this.context.trailerInfo.Root = c) } }, e.prototype.parseHeader = function () { for (; !this.bytes.done();) { if (this.matchKeyword(Tt.header)) { var n = this.parseRawInt(); this.bytes.assertNext(M.Period); var r = this.parseRawInt(), i = Wf.forVersion(n, r); return this.skipBinaryHeaderComment(), i } this.bytes.next() } throw new d3(this.bytes.position()) }, e.prototype.parseIndirectObjectHeader = function () { this.skipWhitespaceAndComments(); var n = this.parseRawInt(); this.skipWhitespaceAndComments(); var r = this.parseRawInt(); if (this.skipWhitespaceAndComments(), !this.matchKeyword(Tt.obj)) throw new h3(this.bytes.position(), Tt.obj); return wt.of(n, r) }, e.prototype.matchIndirectObjectHeader = function () { var n = this.bytes.offset(); try { return this.parseIndirectObjectHeader(), !0 } catch { return this.bytes.moveTo(n), !1 } }, e.prototype.parseIndirectObject = function () { return tt(this, void 0, void 0, function () { var n, r; return nt(this, function (i) { switch (i.label) { case 0: return n = this.parseIndirectObjectHeader(), this.skipWhitespaceAndComments(), r = this.parseObject(), this.skipWhitespaceAndComments(), this.matchKeyword(Tt.endobj), r instanceof Ul && r.dict.lookup(O.of("Type")) === O.of("ObjStm") ? [4, t5.forStream(r, this.shouldWaitForTick).parseIntoContext()] : [3, 2]; case 1: return i.sent(), [3, 3]; case 2: r instanceof Ul && r.dict.lookup(O.of("Type")) === O.of("XRef") ? n5.forStream(r).parseIntoContext() : this.context.assign(n, r), i.label = 3; case 3: return [2, n] } }) }) }, e.prototype.tryToParseInvalidIndirectObject = function () { var n = this.bytes.position(), r = "Trying to parse invalid object: " + JSON.stringify(n) + ")"; if (this.throwOnInvalidObject) throw new Error(r); console.warn(r); var i = this.parseIndirectObjectHeader(); console.warn("Invalid object ref: " + i), this.skipWhitespaceAndComments(); for (var s = this.bytes.offset(), a = !0; !this.bytes.done() && (this.matchKeyword(Tt.endobj) && (a = !1), !!a);)this.bytes.next(); if (a) throw new l3(n); var u = this.bytes.offset() - Tt.endobj.length, c = xP.of(this.bytes.slice(s, u)); return this.context.assign(i, c), i }, e.prototype.parseIndirectObjects = function () { return tt(this, void 0, void 0, function () { var n; return nt(this, function (r) { switch (r.label) { case 0: this.skipWhitespaceAndComments(), r.label = 1; case 1: if (!(!this.bytes.done() && Rn[this.bytes.peek()])) return [3, 8]; n = this.bytes.offset(), r.label = 2; case 2: return r.trys.push([2, 4, , 5]), [4, this.parseIndirectObject()]; case 3: return r.sent(), [3, 5]; case 4: return r.sent(), this.bytes.moveTo(n), this.tryToParseInvalidIndirectObject(), [3, 5]; case 5: return this.skipWhitespaceAndComments(), this.skipJibberish(), this.shouldWaitForTick() ? [4, na()] : [3, 7]; case 6: r.sent(), r.label = 7; case 7: return [3, 1]; case 8: return [2] } }) }) }, e.prototype.maybeParseCrossRefSection = function () { if (this.skipWhitespaceAndComments(), !!this.matchKeyword(Tt.xref)) { this.skipWhitespaceAndComments(); for (var n = -1, r = mP.createEmpty(); !this.bytes.done() && Rn[this.bytes.peek()];) { var i = this.parseRawInt(); this.skipWhitespaceAndComments(); var s = this.parseRawInt(); this.skipWhitespaceAndComments(); var a = this.bytes.peek(); if (a === M.n || a === M.f) { var u = wt.of(n, s); this.bytes.next() === M.n ? r.addEntry(u, i) : r.addDeletedEntry(u, i), n += 1 } else n = i; this.skipWhitespaceAndComments() } return r } }, e.prototype.maybeParseTrailerDict = function () { if (this.skipWhitespaceAndComments(), !!this.matchKeyword(Tt.trailer)) { this.skipWhitespaceAndComments(); var n = this.parseDict(), r = this.context; r.trailerInfo = { Root: n.get(O.of("Root")) || r.trailerInfo.Root, Encrypt: n.get(O.of("Encrypt")) || r.trailerInfo.Encrypt, Info: n.get(O.of("Info")) || r.trailerInfo.Info, ID: n.get(O.of("ID")) || r.trailerInfo.ID } } }, e.prototype.maybeParseTrailer = function () { if (this.skipWhitespaceAndComments(), !!this.matchKeyword(Tt.startxref)) { this.skipWhitespaceAndComments(); var n = this.parseRawInt(); return this.skipWhitespace(), this.matchKeyword(Tt.eof), this.skipWhitespaceAndComments(), this.matchKeyword(Tt.eof), this.skipWhitespaceAndComments(), Bv.forLastCrossRefSectionOffset(n) } }, e.prototype.parseDocumentSection = function () { return tt(this, void 0, void 0, function () { return nt(this, function (n) { switch (n.label) { case 0: return [4, this.parseIndirectObjects()]; case 1: return n.sent(), this.maybeParseCrossRefSection(), this.maybeParseTrailerDict(), this.maybeParseTrailer(), this.skipJibberish(), [2] } }) }) }, e.prototype.skipJibberish = function () { for (this.skipWhitespaceAndComments(); !this.bytes.done();) { var n = this.bytes.offset(), r = this.bytes.peek(), i = r >= M.Space && r <= M.Tilde; if (i && (this.matchKeyword(Tt.xref) || this.matchKeyword(Tt.trailer) || this.matchKeyword(Tt.startxref) || this.matchIndirectObjectHeader())) { this.bytes.moveTo(n); break } this.bytes.next() } }, e.prototype.skipBinaryHeaderComment = function () { this.skipWhitespaceAndComments(); try { var n = this.bytes.offset(); this.parseIndirectObjectHeader(), this.bytes.moveTo(n) } catch { this.bytes.next(), this.skipWhitespaceAndComments() } }, e.forBytesWithOptions = function (n, r, i, s) { return new e(n, r, i, s) }, e }(DP), $r = function (t) { return 1 << t }, Al; (function (t) { t[t.Invisible = $r(0)] = "Invisible", t[t.Hidden = $r(1)] = "Hidden", t[t.Print = $r(2)] = "Print", t[t.NoZoom = $r(3)] = "NoZoom", t[t.NoRotate = $r(4)] = "NoRotate", t[t.NoView = $r(5)] = "NoView", t[t.ReadOnly = $r(6)] = "ReadOnly", t[t.Locked = $r(7)] = "Locked", t[t.ToggleNoView = $r(8)] = "ToggleNoView", t[t.LockedContents = $r(9)] = "LockedContents" })(Al || (Al = {})); var Jf = function (t) { return t instanceof O ? t : O.of(t) }, Ze = function (t) { return t instanceof Xe ? t : Xe.of(t) }, rt = function (t) { return t instanceof Xe ? t.asNumber() : t }, Wl; (function (t) { t.Degrees = "degrees", t.Radians = "radians" })(Wl || (Wl = {})); var Ge = function (t) { return G(t, "degreeAngle", ["number"]), { type: Wl.Degrees, angle: t } }, OP = Wl.Radians, MP = Wl.Degrees, VP = function (t) { return t * Math.PI / 180 }, i5 = function (t) { return t * 180 / Math.PI }, Sn = function (t) { return t.type === OP ? t.angle : t.type === MP ? VP(t.angle) : iu("Invalid rotation: " + JSON.stringify(t)) }, NP = function (t) { return t.type === OP ? i5(t.angle) : t.type === MP ? t.angle : iu("Invalid rotation: " + JSON.stringify(t)) }, Ni = function (t) { t === void 0 && (t = 0); var e = t / 90 % 4; return e === 0 ? 0 : e === 1 ? 90 : e === 2 ? 180 : e === 3 ? 270 : 0 }, ns = function (t, e) { e === void 0 && (e = 0); var n = Ni(e); return n === 90 || n === 270 ? { width: t.height, height: t.width } : { width: t.width, height: t.height } }, o5 = function (t, e, n) { e === void 0 && (e = 0), n === void 0 && (n = 0); var r = t.x, i = t.y, s = t.width, a = t.height, u = Ni(n), c = e / 2; return u === 0 ? { x: r - c, y: i - c, width: s, height: a } : u === 90 ? { x: r - a + c, y: i - c, width: a, height: s } : u === 180 ? { x: r - s + c, y: i - a + c, width: s, height: a } : u === 270 ? { x: r - c, y: i - s + c, width: a, height: s } : { x: r - c, y: i - c, width: s, height: a } }, BP = function () { return ct.of(dt.ClipNonZero) }, mf = Math.cos, gf = Math.sin, yf = Math.tan, _f = function (t, e, n, r, i, s) { return ct.of(dt.ConcatTransformationMatrix, [Ze(t), Ze(e), Ze(n), Ze(r), Ze(i), Ze(s)]) }, Er = function (t, e) { return _f(1, 0, 0, 1, t, e) }, Kl = function (t, e) { return _f(t, 0, 0, e, 0, 0) }, ca = function (t) { return _f(mf(rt(t)), gf(rt(t)), -gf(rt(t)), mf(rt(t)), 0, 0) }, Dc = function (t) { return ca(VP(rt(t))) }, Kv = function (t, e) { return _f(1, yf(rt(t)), yf(rt(e)), 1, 0, 0) }, $f = function (t, e) { return ct.of(dt.SetLineDashPattern, ["[" + t.map(Ze).join(" ") + "]", Ze(e)]) }, Hs; (function (t) { t[t.Butt = 0] = "Butt", t[t.Round = 1] = "Round", t[t.Projecting = 2] = "Projecting" })(Hs || (Hs = {})); var ed = function (t) { return ct.of(dt.SetLineCapStyle, [Ze(t)]) }, Ew; (function (t) { t[t.Miter = 0] = "Miter", t[t.Round = 1] = "Round", t[t.Bevel = 2] = "Bevel" })(Ew || (Ew = {})); var rs = function (t) { return ct.of(dt.SetGraphicsStateParams, [Jf(t)]) }, an = function () { return ct.of(dt.PushGraphicsState) }, ln = function () { return ct.of(dt.PopGraphicsState) }, su = function (t) { return ct.of(dt.SetLineWidth, [Ze(t)]) }, rr = function (t, e, n, r, i, s) { return ct.of(dt.AppendBezierCurve, [Ze(t), Ze(e), Ze(n), Ze(r), Ze(i), Ze(s)]) }, Oc = function (t, e, n, r) { return ct.of(dt.CurveToReplicateInitialPoint, [Ze(t), Ze(e), Ze(n), Ze(r)]) }, ho = function () { return ct.of(dt.ClosePath) }, si = function (t, e) { return ct.of(dt.MoveTo, [Ze(t), Ze(e)]) }, hn = function (t, e) { return ct.of(dt.LineTo, [Ze(t), Ze(e)]) }, au = function () { return ct.of(dt.StrokePath) }, Hv = function () { return ct.of(dt.FillNonZero) }, qv = function () { return ct.of(dt.FillNonZeroAndStroke) }, LP = function () { return ct.of(dt.EndPath) }, s5 = function () { return ct.of(dt.NextLine) }, jP = function (t) { return ct.of(dt.ShowText, [t]) }, IP = function () { return ct.of(dt.BeginText) }, zP = function () { return ct.of(dt.EndText) }, Gv = function (t, e) { return ct.of(dt.SetFontAndSize, [Jf(t), Ze(e)]) }, a5 = function (t) { return ct.of(dt.SetTextLineHeight, [Ze(t)]) }, Fw; (function (t) { t[t.Fill = 0] = "Fill", t[t.Outline = 1] = "Outline", t[t.FillAndOutline = 2] = "FillAndOutline", t[t.Invisible = 3] = "Invisible", t[t.FillAndClip = 4] = "FillAndClip", t[t.OutlineAndClip = 5] = "OutlineAndClip", t[t.FillAndOutlineAndClip = 6] = "FillAndOutlineAndClip", t[t.Clip = 7] = "Clip" })(Fw || (Fw = {})); var l5 = function (t, e, n, r, i, s) { return ct.of(dt.SetTextMatrix, [Ze(t), Ze(e), Ze(n), Ze(r), Ze(i), Ze(s)]) }, UP = function (t, e, n, r, i) { return l5(mf(rt(t)), gf(rt(t)) + yf(rt(e)), -gf(rt(t)) + yf(rt(n)), mf(rt(t)), r, i) }, Xv = function (t) { return ct.of(dt.DrawObject, [Jf(t)]) }, u5 = function (t) { return ct.of(dt.NonStrokingColorGray, [Ze(t)]) }, c5 = function (t) { return ct.of(dt.StrokingColorGray, [Ze(t)]) }, f5 = function (t, e, n) { return ct.of(dt.NonStrokingColorRgb, [Ze(t), Ze(e), Ze(n)]) }, d5 = function (t, e, n) { return ct.of(dt.StrokingColorRgb, [Ze(t), Ze(e), Ze(n)]) }, h5 = function (t, e, n, r) { return ct.of(dt.NonStrokingColorCmyk, [Ze(t), Ze(e), Ze(n), Ze(r)]) }, p5 = function (t, e, n, r) { return ct.of(dt.StrokingColorCmyk, [Ze(t), Ze(e), Ze(n), Ze(r)]) }, WP = function (t) { return ct.of(dt.BeginMarkedContent, [Jf(t)]) }, KP = function () { return ct.of(dt.EndMarkedContent) }, po; (function (t) { t.Grayscale = "Grayscale", t.RGB = "RGB", t.CMYK = "CMYK" })(po || (po = {})); var HP = function (t) { return nr(t, "gray", 0, 1), { type: po.Grayscale, gray: t } }, St = function (t, e, n) { return nr(t, "red", 0, 1), nr(e, "green", 0, 1), nr(n, "blue", 0, 1), { type: po.RGB, red: t, green: e, blue: n } }, qP = function (t, e, n, r) { return nr(t, "cyan", 0, 1), nr(e, "magenta", 0, 1), nr(n, "yellow", 0, 1), nr(r, "key", 0, 1), { type: po.CMYK, cyan: t, magenta: e, yellow: n, key: r } }, Zv = po.Grayscale, Yv = po.RGB, Qv = po.CMYK, is = function (t) { return t.type === Zv ? u5(t.gray) : t.type === Yv ? f5(t.red, t.green, t.blue) : t.type === Qv ? h5(t.cyan, t.magenta, t.yellow, t.key) : iu("Invalid color: " + JSON.stringify(t)) }, lu = function (t) { return t.type === Zv ? c5(t.gray) : t.type === Yv ? d5(t.red, t.green, t.blue) : t.type === Qv ? p5(t.cyan, t.magenta, t.yellow, t.key) : iu("Invalid color: " + JSON.stringify(t)) }, Bn = function (t, e) { return e === void 0 && (e = 1), (t == null ? void 0 : t.length) === 1 ? HP(t[0] * e) : (t == null ? void 0 : t.length) === 3 ? St(t[0] * e, t[1] * e, t[2] * e) : (t == null ? void 0 : t.length) === 4 ? qP(t[0] * e, t[1] * e, t[2] * e, t[3] * e) : void 0 }, Rw = function (t) { return t.type === Zv ? [t.gray] : t.type === Yv ? [t.red, t.green, t.blue] : t.type === Qv ? [t.cyan, t.magenta, t.yellow, t.key] : iu("Invalid color: " + JSON.stringify(t)) }, Le = 0, je = 0, lt = 0, ut = 0, dl = 0, hl = 0, Dw = new Map([["A", 7], ["a", 7], ["C", 6], ["c", 6], ["H", 1], ["h", 1], ["L", 2], ["l", 2], ["M", 2], ["m", 2], ["Q", 4], ["q", 4], ["S", 4], ["s", 4], ["T", 2], ["t", 2], ["V", 1], ["v", 1], ["Z", 0], ["z", 0]]), v5 = function (t) { for (var e, n = [], r = [], i = "", s = !1, a = 0, u = 0, c = t; u < c.length; u++) { var f = c[u]; if (Dw.has(f)) a = Dw.get(f), e && (i.length > 0 && (r[r.length] = +i), n[n.length] = { cmd: e, args: r }, r = [], i = "", s = !1), e = f; else if ([" ", ","].includes(f) || f === "-" && i.length > 0 && i[i.length - 1] !== "e" || f === "." && s) { if (i.length === 0) continue; r.length === a ? (n[n.length] = { cmd: e, args: r }, r = [+i], e === "M" && (e = "L"), e === "m" && (e = "l")) : r[r.length] = +i, s = f === ".", i = ["-", "."].includes(f) ? f : "" } else i += f, f === "." && (s = !0) } return i.length > 0 && (r.length === a ? (n[n.length] = { cmd: e, args: r }, r = [+i], e === "M" && (e = "L"), e === "m" && (e = "l")) : r[r.length] = +i), n[n.length] = { cmd: e, args: r }, n }, m5 = function (t) { Le = je = lt = ut = dl = hl = 0; for (var e = [], n = 0; n < t.length; n++) { var r = t[n]; if (r.cmd && typeof Ow[r.cmd] == "function") { var i = Ow[r.cmd](r.args); Array.isArray(i) ? e = e.concat(i) : e.push(i) } } return e }, Ow = { M: function (t) { return Le = t[0], je = t[1], lt = ut = null, dl = Le, hl = je, si(Le, je) }, m: function (t) { return Le += t[0], je += t[1], lt = ut = null, dl = Le, hl = je, si(Le, je) }, C: function (t) { return Le = t[4], je = t[5], lt = t[2], ut = t[3], rr(t[0], t[1], t[2], t[3], t[4], t[5]) }, c: function (t) { var e = rr(t[0] + Le, t[1] + je, t[2] + Le, t[3] + je, t[4] + Le, t[5] + je); return lt = Le + t[2], ut = je + t[3], Le += t[4], je += t[5], e }, S: function (t) { (lt === null || ut === null) && (lt = Le, ut = je); var e = rr(Le - (lt - Le), je - (ut - je), t[0], t[1], t[2], t[3]); return lt = t[0], ut = t[1], Le = t[2], je = t[3], e }, s: function (t) { (lt === null || ut === null) && (lt = Le, ut = je); var e = rr(Le - (lt - Le), je - (ut - je), Le + t[0], je + t[1], Le + t[2], je + t[3]); return lt = Le + t[0], ut = je + t[1], Le += t[2], je += t[3], e }, Q: function (t) { return lt = t[0], ut = t[1], Le = t[2], je = t[3], Oc(t[0], t[1], Le, je) }, q: function (t) { var e = Oc(t[0] + Le, t[1] + je, t[2] + Le, t[3] + je); return lt = Le + t[0], ut = je + t[1], Le += t[2], je += t[3], e }, T: function (t) { lt === null || ut === null ? (lt = Le, ut = je) : (lt = Le - (lt - Le), ut = je - (ut - je)); var e = Oc(lt, ut, t[0], t[1]); return lt = Le - (lt - Le), ut = je - (ut - je), Le = t[0], je = t[1], e }, t: function (t) { lt === null || ut === null ? (lt = Le, ut = je) : (lt = Le - (lt - Le), ut = je - (ut - je)); var e = Oc(lt, ut, Le + t[0], je + t[1]); return Le += t[0], je += t[1], e }, A: function (t) { var e = Mw(Le, je, t); return Le = t[5], je = t[6], e }, a: function (t) { t[5] += Le, t[6] += je; var e = Mw(Le, je, t); return Le = t[5], je = t[6], e }, L: function (t) { return Le = t[0], je = t[1], lt = ut = null, hn(Le, je) }, l: function (t) { return Le += t[0], je += t[1], lt = ut = null, hn(Le, je) }, H: function (t) { return Le = t[0], lt = ut = null, hn(Le, je) }, h: function (t) { return Le += t[0], lt = ut = null, hn(Le, je) }, V: function (t) { return je = t[0], lt = ut = null, hn(Le, je) }, v: function (t) { return je += t[0], lt = ut = null, hn(Le, je) }, Z: function () { var t = ho(); return Le = dl, je = hl, t }, z: function () { var t = ho(); return Le = dl, je = hl, t } }, Mw = function (t, e, n) { for (var r = n[0], i = n[1], s = n[2], a = n[3], u = n[4], c = n[5], f = n[6], h = g5(c, f, r, i, a, u, s, t, e), v = [], m = 0, g = h; m < g.length; m++) { var S = g[m], b = y5.apply(void 0, S); v.push(rr.apply(void 0, b)) } return v }, g5 = function (t, e, n, r, i, s, a, u, c) { var f = a * (Math.PI / 180), h = Math.sin(f), v = Math.cos(f); n = Math.abs(n), r = Math.abs(r), lt = v * (u - t) * .5 + h * (c - e) * .5, ut = v * (c - e) * .5 - h * (u - t) * .5; var m = lt * lt / (n * n) + ut * ut / (r * r); m > 1 && (m = Math.sqrt(m), n *= m, r *= m); var g = v / n, S = h / n, b = -h / r, P = v / r, C = g * u + S * c, F = b * u + P * c, A = g * t + S * e, N = b * t + P * e, D = (A - C) * (A - C) + (N - F) * (N - F), V = 1 / D - .25; V < 0 && (V = 0); var B = Math.sqrt(V); s === i && (B = -B); var I = .5 * (C + A) - B * (N - F), Y = .5 * (F + N) + B * (A - C), Z = Math.atan2(F - Y, C - I), ie = Math.atan2(N - Y, A - I), se = ie - Z; se < 0 && s === 1 ? se += 2 * Math.PI : se > 0 && s === 0 && (se -= 2 * Math.PI); for (var q = Math.ceil(Math.abs(se / (Math.PI * .5 + .001))), ue = [], ye = 0; ye < q; ye++) { var ae = Z + ye * se / q, _ = Z + (ye + 1) * se / q; ue[ye] = [I, Y, ae, _, n, r, h, v] } return ue }, y5 = function (t, e, n, r, i, s, a, u) { var c = u * i, f = -a * s, h = a * i, v = u * s, m = .5 * (r - n), g = 8 / 3 * Math.sin(m * .5) * Math.sin(m * .5) / Math.sin(m), S = t + Math.cos(n) - g * Math.sin(n), b = e + Math.sin(n) + g * Math.cos(n), P = t + Math.cos(r), C = e + Math.sin(r), F = P + g * Math.sin(r), A = C - g * Math.cos(r), N = [c * S + f * b, h * S + v * b, c * F + f * A, h * F + v * A, c * P + f * C, h * P + v * C]; return N }, x5 = function (t) { return m5(v5(t)) }, w5 = function (t, e) { for (var n = [an(), e.graphicsState && rs(e.graphicsState), IP(), is(e.color), Gv(e.font, e.size), a5(e.lineHeight), UP(Sn(e.rotate), Sn(e.xSkew), Sn(e.ySkew), e.x, e.y)].filter(Boolean), r = 0, i = t.length; r < i; r++)n.push(jP(t[r]), s5()); return n.push(zP(), ln()), n }, GP = function (t, e) { return [an(), e.graphicsState && rs(e.graphicsState), Er(e.x, e.y), ca(Sn(e.rotate)), Kl(e.width, e.height), Kv(Sn(e.xSkew), Sn(e.ySkew)), Xv(t), ln()].filter(Boolean) }, S5 = function (t, e) { return [an(), e.graphicsState && rs(e.graphicsState), Er(e.x, e.y), ca(Sn(e.rotate)), Kl(e.xScale, e.yScale), Kv(Sn(e.xSkew), Sn(e.ySkew)), Xv(t), ln()].filter(Boolean) }, b5 = function (t) { var e, n; return [an(), t.graphicsState && rs(t.graphicsState), t.color && lu(t.color), su(t.thickness), $f((e = t.dashArray) !== null && e !== void 0 ? e : [], (n = t.dashPhase) !== null && n !== void 0 ? n : 0), si(t.start.x, t.start.y), t.lineCap && ed(t.lineCap), si(t.start.x, t.start.y), hn(t.end.x, t.end.y), au(), ln()].filter(Boolean) }, ra = function (t) { var e, n; return [an(), t.graphicsState && rs(t.graphicsState), t.color && is(t.color), t.borderColor && lu(t.borderColor), su(t.borderWidth), t.borderLineCap && ed(t.borderLineCap), $f((e = t.borderDashArray) !== null && e !== void 0 ? e : [], (n = t.borderDashPhase) !== null && n !== void 0 ? n : 0), Er(t.x, t.y), ca(Sn(t.rotate)), Kv(Sn(t.xSkew), Sn(t.ySkew)), si(0, 0), hn(0, t.height), hn(t.width, t.height), hn(t.width, 0), ho(), t.color && t.borderWidth ? qv() : t.color ? Hv() : t.borderColor ? au() : ho(), ln()].filter(Boolean) }, xf = 4 * ((Math.sqrt(2) - 1) / 3), C5 = function (t) { var e = rt(t.x), n = rt(t.y), r = rt(t.xScale), i = rt(t.yScale); e -= r, n -= i; var s = r * xf, a = i * xf, u = e + r * 2, c = n + i * 2, f = e + r, h = n + i; return [an(), si(e, h), rr(e, h - a, f - s, n, f, n), rr(f + s, n, u, h - a, u, h), rr(u, h + a, f + s, c, f, c), rr(f - s, c, e, h + a, e, h), ln()] }, P5 = function (t) { var e = rt(t.x), n = rt(t.y), r = rt(t.xScale), i = rt(t.yScale), s = -r, a = -i, u = r * xf, c = i * xf, f = s + r * 2, h = a + i * 2, v = s + r, m = a + i; return [Er(e, n), ca(Sn(t.rotate)), si(s, m), rr(s, m - c, v - u, a, v, a), rr(v + u, a, f, m - c, f, m), rr(f, m + c, v + u, h, v, h), rr(v - u, h, s, m + c, s, m)] }, y0 = function (t) { var e, n, r; return ft([an(), t.graphicsState && rs(t.graphicsState), t.color && is(t.color), t.borderColor && lu(t.borderColor), su(t.borderWidth), t.borderLineCap && ed(t.borderLineCap), $f((e = t.borderDashArray) !== null && e !== void 0 ? e : [], (n = t.borderDashPhase) !== null && n !== void 0 ? n : 0)], t.rotate === void 0 ? C5({ x: t.x, y: t.y, xScale: t.xScale, yScale: t.yScale }) : P5({ x: t.x, y: t.y, xScale: t.xScale, yScale: t.yScale, rotate: (r = t.rotate) !== null && r !== void 0 ? r : Ge(0) }), [t.color && t.borderWidth ? qv() : t.color ? Hv() : t.borderColor ? au() : ho(), ln()]).filter(Boolean) }, T5 = function (t, e) { var n, r, i; return ft([an(), e.graphicsState && rs(e.graphicsState), Er(e.x, e.y), ca(Sn((n = e.rotate) !== null && n !== void 0 ? n : Ge(0))), e.scale ? Kl(e.scale, -e.scale) : Kl(1, -1), e.color && is(e.color), e.borderColor && lu(e.borderColor), e.borderWidth && su(e.borderWidth), e.borderLineCap && ed(e.borderLineCap), $f((r = e.borderDashArray) !== null && r !== void 0 ? r : [], (i = e.borderDashPhase) !== null && i !== void 0 ? i : 0)], x5(t), [e.color && e.borderWidth ? qv() : e.color ? Hv() : e.borderColor ? au() : ho(), ln()]).filter(Boolean) }, k5 = function (t) { var e = rt(t.size), n = -1 + .75, r = -1 + .51, i = 1 - .525, s = 1 - .31, a = -1 + .325, u = -((a - n) * (s - n)) / (i - r) + r; return [an(), t.color && lu(t.color), su(t.thickness), Er(t.x, t.y), si(a * e, u * e), hn(n * e, r * e), hn(s * e, i * e), au(), ln()].filter(Boolean) }, Co = function (t) { return t.rotation === 0 ? [Er(0, 0), Dc(0)] : t.rotation === 90 ? [Er(t.width, 0), Dc(90)] : t.rotation === 180 ? [Er(t.width, t.height), Dc(180)] : t.rotation === 270 ? [Er(0, t.height), Dc(270)] : [] }, Mc = function (t) { var e = ra({ x: t.x, y: t.y, width: t.width, height: t.height, borderWidth: t.borderWidth, color: t.color, borderColor: t.borderColor, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) }); if (!t.filled) return e; var n = rt(t.width), r = rt(t.height), i = Math.min(n, r) / 2, s = k5({ x: n / 2, y: r / 2, size: i, thickness: t.thickness, color: t.markColor }); return ft([an()], e, s, [ln()]) }, Vc = function (t) { var e = rt(t.width), n = rt(t.height), r = Math.min(e, n) / 2, i = y0({ x: t.x, y: t.y, xScale: r, yScale: r, color: t.color, borderColor: t.borderColor, borderWidth: t.borderWidth }); if (!t.filled) return i; var s = y0({ x: t.x, y: t.y, xScale: r * .45, yScale: r * .45, color: t.dotColor, borderColor: void 0, borderWidth: 0 }); return ft([an()], i, s, [ln()]) }, Vw = function (t) { var e = rt(t.x), n = rt(t.y), r = rt(t.width), i = rt(t.height), s = ra({ x: e, y: n, width: r, height: i, borderWidth: t.borderWidth, color: t.color, borderColor: t.borderColor, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) }), a = Jv(t.textLines, { color: t.textColor, font: t.font, size: t.fontSize, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) }); return ft([an()], s, a, [ln()]) }, Jv = function (t, e) { for (var n = [IP(), is(e.color), Gv(e.font, e.size)], r = 0, i = t.length; r < i; r++) { var s = t[r], a = s.encoded, u = s.x, c = s.y; n.push(UP(Sn(e.rotate), Sn(e.xSkew), Sn(e.ySkew), u, c), jP(a)) } return n.push(zP()), n }, XP = function (t) { var e = rt(t.x), n = rt(t.y), r = rt(t.width), i = rt(t.height), s = rt(t.borderWidth), a = rt(t.padding), u = e + s / 2 + a, c = n + s / 2 + a, f = r - (s / 2 + a) * 2, h = i - (s / 2 + a) * 2, v = [si(u, c), hn(u, c + h), hn(u + f, c + h), hn(u + f, c), ho(), BP(), LP()], m = ra({ x: e, y: n, width: r, height: i, borderWidth: t.borderWidth, color: t.color, borderColor: t.borderColor, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) }), g = Jv(t.textLines, { color: t.textColor, font: t.font, size: t.fontSize, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) }), S = ft([WP("Tx"), an()], g, [ln(), KP()]); return ft([an()], m, v, S, [ln()]) }, A5 = function (t) { for (var e = rt(t.x), n = rt(t.y), r = rt(t.width), i = rt(t.height), s = rt(t.lineHeight), a = rt(t.borderWidth), u = rt(t.padding), c = e + a / 2 + u, f = n + a / 2 + u, h = r - (a / 2 + u) * 2, v = i - (a / 2 + u) * 2, m = [si(c, f), hn(c, f + v), hn(c + h, f + v), hn(c + h, f), ho(), BP(), LP()], g = ra({ x: e, y: n, width: r, height: i, borderWidth: t.borderWidth, color: t.color, borderColor: t.borderColor, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) }), S = [], b = 0, P = t.selectedLines.length; b < P; b++) { var C = t.textLines[t.selectedLines[b]]; S.push.apply(S, ra({ x: C.x - u, y: C.y - (s - C.height) / 2, width: r - a, height: C.height + (s - C.height) / 2, borderWidth: 0, color: t.selectedColor, borderColor: void 0, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) })) } var F = Jv(t.textLines, { color: t.textColor, font: t.font, size: t.fontSize, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) }), A = ft([WP("Tx"), an()], F, [ln(), KP()]); return ft([an()], g, S, m, A, [ln()]) }, E5 = function (t) { we(e, t); function e() { var n = this, r = "Input document to `PDFDocument.load` is encrypted. You can use `PDFDocument.load(..., { ignoreEncryption: true })` if you wish to load the document anyways."; return n = t.call(this, r) || this, n } return e }(Error), F5 = function (t) { we(e, t); function e() { var n = this, r = "Input to `PDFDocument.embedFont` was a custom font, but no `fontkit` instance was found. You must register a `fontkit` instance with `PDFDocument.registerFontkit(...)` before embedding custom fonts."; return n = t.call(this, r) || this, n } return e }(Error), R5 = function (t) { we(e, t); function e() { var n = this, r = "A `page` passed to `PDFDocument.addPage` or `PDFDocument.insertPage` was from a different (foreign) PDF document. If you want to copy pages from one PDFDocument to another, you must use `PDFDocument.copyPages(...)` to copy the pages before adding or inserting them."; return n = t.call(this, r) || this, n } return e }(Error), D5 = function (t) { we(e, t); function e() { var n = this, r = "PDFDocument has no pages so `PDFDocument.removePage` cannot be called"; return n = t.call(this, r) || this, n } return e }(Error), O5 = function (t) { we(e, t); function e(n) { var r = this, i = 'PDFDocument has no form field with the name "' + n + '"'; return r = t.call(this, i) || this, r } return e }(Error), zo = function (t) { we(e, t); function e(n, r, i) { var s, a, u = this, c = r == null ? void 0 : r.name, f = (a = (s = i == null ? void 0 : i.constructor) === null || s === void 0 ? void 0 : s.name) !== null && a !== void 0 ? a : i, h = 'Expected field "' + n + '" to be of type ' + c + ", " + ("but it is actually of type " + f); return u = t.call(this, h) || this, u } return e }(Error); (function (t) { we(e, t); function e(n) { var r = this, i = 'Failed to select check box due to missing onValue: "' + n + '"'; return r = t.call(this, i) || this, r } return e })(Error); var ZP = function (t) { we(e, t); function e(n) { var r = this, i = 'A field already exists with the specified name: "' + n + '"'; return r = t.call(this, i) || this, r } return e }(Error), M5 = function (t) { we(e, t); function e(n) { var r = this, i = 'Field name contains invalid component: "' + n + '"'; return r = t.call(this, i) || this, r } return e }(Error); (function (t) { we(e, t); function e(n) { var r = this, i = 'A non-terminal field already exists with the specified name: "' + n + '"'; return r = t.call(this, i) || this, r } return e })(Error); var V5 = function (t) { we(e, t); function e(n) { var r = this, i = "Reading rich text fields is not supported: Attempted to read rich text field: " + n; return r = t.call(this, i) || this, r } return e }(Error), N5 = function (t) { we(e, t); function e(n, r) { var i = this, s = "Failed to layout combed text as lineLength=" + n + " is greater than cellCount=" + r; return i = t.call(this, s) || this, i } return e }(Error), B5 = function (t) { we(e, t); function e(n, r, i) { var s = this, a = "Attempted to set text with length=" + n + " for TextField with maxLength=" + r + " and name=" + i; return s = t.call(this, a) || this, s } return e }(Error), L5 = function (t) { we(e, t); function e(n, r, i) { var s = this, a = "Attempted to set maxLength=" + r + ", which is less than " + n + ", the length of this field's current value (name=" + i + ")"; return s = t.call(this, a) || this, s } return e }(Error), sn; (function (t) { t[t.Left = 0] = "Left", t[t.Center = 1] = "Center", t[t.Right = 2] = "Right" })(sn || (sn = {})); var YP = 4, QP = 500, JP = function (t, e, n, r) { r === void 0 && (r = !1); for (var i = YP; i < QP;) { for (var s = 0, a = 0, u = t.length; a < u; a++) { s += 1; for (var c = t[a], f = c.split(" "), h = n.width, v = 0, m = f.length; v < m; v++) { var g = v === m - 1, S = g ? f[v] : f[v] + " ", b = e.widthOfTextAtSize(S, i); h -= b, h <= 0 && (s += 1, h = n.width - b) } } if (!r && s > t.length) return i - 1; var P = e.heightAtSize(i), C = P + P * .2, F = C * s; if (F > Math.abs(n.height)) return i - 1; i += 1 } return i }, j5 = function (t, e, n, r) { for (var i = n.width / r, s = n.height, a = YP, u = YO(t); a < QP;) { for (var c = 0, f = u.length; c < f; c++) { var h = u[c], v = e.widthOfTextAtSize(h, a) > i * .75; if (v) return a - 1 } var m = e.heightAtSize(a, { descender: !1 }); if (m > s) return a - 1; a += 1 } return a }, I5 = function (t) { for (var e = t.length; e > 0; e--)if (/\s/.test(t[e])) return e }, z5 = function (t, e, n, r) { for (var i, s = t.length; s > 0;) { var a = t.substring(0, s), u = n.encodeText(a), c = n.widthOfTextAtSize(a, r); if (c < e) { var f = t.substring(s) || void 0; return { line: a, encoded: u, width: c, remainder: f } } s = (i = I5(a)) !== null && i !== void 0 ? i : 0 } return { line: t, encoded: n.encodeText(t), width: n.widthOfTextAtSize(t, r), remainder: void 0 } }, _P = function (t, e) { var n = e.alignment, r = e.fontSize, i = e.font, s = e.bounds, a = YC(ru(t)); (r === void 0 || r === 0) && (r = JP(a, i, s, !0)); for (var u = i.heightAtSize(r), c = u + u * .2, f = [], h = s.x, v = s.y, m = s.x + s.width, g = s.y + s.height, S = s.y + s.height, b = 0, P = a.length; b < P; b++)for (var C = a[b]; C !== void 0;) { var F = z5(C, s.width, i, r), A = F.line, N = F.encoded, D = F.width, V = F.remainder, B = n === sn.Left ? s.x : n === sn.Center ? s.x + s.width / 2 - D / 2 : n === sn.Right ? s.x + s.width - D : s.x; S -= c, B < h && (h = B), S < v && (v = S), B + D > m && (m = B + D), S + u > g && (g = S + u), f.push({ text: A, encoded: N, width: D, height: u, x: B, y: S }), C = V == null ? void 0 : V.trim() } return { fontSize: r, lineHeight: c, lines: f, bounds: { x: h, y: v, width: m - h, height: g - v } } }, U5 = function (t, e) { var n = e.fontSize, r = e.font, i = e.bounds, s = e.cellCount, a = QC(ru(t)); if (a.length > s) throw new N5(a.length, s); (n === void 0 || n === 0) && (n = j5(a, r, i, s)); for (var u = i.width / s, c = r.heightAtSize(n, { descender: !1 }), f = i.y + (i.height / 2 - c / 2), h = [], v = i.x, m = i.y, g = i.x + i.width, S = i.y + i.height, b = 0, P = 0; b < s;) { var C = JC(a, P), F = C[0], A = C[1], N = r.encodeText(F), D = r.widthOfTextAtSize(F, n), V = i.x + (u * b + u / 2), B = V - D / 2; B < v && (v = B), f < m && (m = f), B + D > g && (g = B + D), f + c > S && (S = f + c), h.push({ text: a, encoded: N, width: D, height: c, x: B, y: f }), b += 1, P += A } return { fontSize: n, cells: h, bounds: { x: v, y: m, width: g - v, height: S - m } } }, wf = function (t, e) { var n = e.alignment, r = e.fontSize, i = e.font, s = e.bounds, a = QC(ru(t)); (r === void 0 || r === 0) && (r = JP([a], i, s)); var u = i.encodeText(a), c = i.widthOfTextAtSize(a, r), f = i.heightAtSize(r, { descender: !1 }), h = n === sn.Left ? s.x : n === sn.Center ? s.x + s.width / 2 - c / 2 : n === sn.Right ? s.x + s.width - c : s.x, v = s.y + (s.height / 2 - f / 2); return { fontSize: r, line: { text: a, encoded: u, width: c, height: f, x: h, y: v }, bounds: { x: h, y: v, width: c, height: f } } }, fa = function (t) { return "normal" in t ? t : { normal: t } }, W5 = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]+(\d*\.\d+|\d+)[\0\t\n\f\r\ ]+Tf/, vo = function (t) { var e, n, r = (e = t.getDefaultAppearance()) !== null && e !== void 0 ? e : "", i = (n = Fv(r, W5).match) !== null && n !== void 0 ? n : [], s = Number(i[2]); return isFinite(s) ? s : void 0 }, K5 = /(\d*\.\d+|\d+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+(g|rg|k)/, Fr = function (t) { var e, n = (e = t.getDefaultAppearance()) !== null && e !== void 0 ? e : "", r = Fv(n, K5).match, i = r ?? [], s = i[1], a = i[2], u = i[3], c = i[4], f = i[5]; if (f === "g" && s) return HP(Number(s)); if (f === "rg" && s && a && u) return St(Number(s), Number(a), Number(u)); if (f === "k" && s && a && u && c) return qP(Number(s), Number(a), Number(u), Number(c)) }, Rr = function (t, e, n, r) {
  var i; r === void 0 && (r = 0); var s = [is(e).toString(), Gv((i = n == null ? void 0 : n.name) !== null && i !== void 0 ? i : "dummy__noop", r).toString()].join(`
`); t.setDefaultAppearance(s)
}, H5 = function (t, e) { var n, r, i, s = Fr(e), a = Fr(t.acroField), u = e.getRectangle(), c = e.getAppearanceCharacteristics(), f = e.getBorderStyle(), h = (n = f == null ? void 0 : f.getWidth()) !== null && n !== void 0 ? n : 0, v = Ni(c == null ? void 0 : c.getRotation()), m = ns(u, v), g = m.width, S = m.height, b = Co(_e(_e({}, u), { rotation: v })), P = St(0, 0, 0), C = (r = Bn(c == null ? void 0 : c.getBorderColor())) !== null && r !== void 0 ? r : P, F = Bn(c == null ? void 0 : c.getBackgroundColor()), A = Bn(c == null ? void 0 : c.getBackgroundColor(), .8), N = (i = s ?? a) !== null && i !== void 0 ? i : P; Rr(s ? e : t.acroField, N); var D = { x: 0 + h / 2, y: 0 + h / 2, width: g - h, height: S - h, thickness: 1.5, borderWidth: h, borderColor: C, markColor: N }; return { normal: { on: ft(b, Mc(_e(_e({}, D), { color: F, filled: !0 }))), off: ft(b, Mc(_e(_e({}, D), { color: F, filled: !1 }))) }, down: { on: ft(b, Mc(_e(_e({}, D), { color: A, filled: !0 }))), off: ft(b, Mc(_e(_e({}, D), { color: A, filled: !1 }))) } } }, q5 = function (t, e) { var n, r, i, s = Fr(e), a = Fr(t.acroField), u = e.getRectangle(), c = e.getAppearanceCharacteristics(), f = e.getBorderStyle(), h = (n = f == null ? void 0 : f.getWidth()) !== null && n !== void 0 ? n : 0, v = Ni(c == null ? void 0 : c.getRotation()), m = ns(u, v), g = m.width, S = m.height, b = Co(_e(_e({}, u), { rotation: v })), P = St(0, 0, 0), C = (r = Bn(c == null ? void 0 : c.getBorderColor())) !== null && r !== void 0 ? r : P, F = Bn(c == null ? void 0 : c.getBackgroundColor()), A = Bn(c == null ? void 0 : c.getBackgroundColor(), .8), N = (i = s ?? a) !== null && i !== void 0 ? i : P; Rr(s ? e : t.acroField, N); var D = { x: g / 2, y: S / 2, width: g - h, height: S - h, borderWidth: h, borderColor: C, dotColor: N }; return { normal: { on: ft(b, Vc(_e(_e({}, D), { color: F, filled: !0 }))), off: ft(b, Vc(_e(_e({}, D), { color: F, filled: !1 }))) }, down: { on: ft(b, Vc(_e(_e({}, D), { color: A, filled: !0 }))), off: ft(b, Vc(_e(_e({}, D), { color: A, filled: !1 }))) } } }, G5 = function (t, e, n) { var r, i, s, a, u, c = Fr(e), f = Fr(t.acroField), h = vo(e), v = vo(t.acroField), m = e.getRectangle(), g = e.getAppearanceCharacteristics(), S = e.getBorderStyle(), b = g == null ? void 0 : g.getCaptions(), P = (r = b == null ? void 0 : b.normal) !== null && r !== void 0 ? r : "", C = (s = (i = b == null ? void 0 : b.down) !== null && i !== void 0 ? i : P) !== null && s !== void 0 ? s : "", F = (a = S == null ? void 0 : S.getWidth()) !== null && a !== void 0 ? a : 0, A = Ni(g == null ? void 0 : g.getRotation()), N = ns(m, A), D = N.width, V = N.height, B = Co(_e(_e({}, m), { rotation: A })), I = St(0, 0, 0), Y = Bn(g == null ? void 0 : g.getBorderColor()), Z = Bn(g == null ? void 0 : g.getBackgroundColor()), ie = Bn(g == null ? void 0 : g.getBackgroundColor(), .8), se = { x: F, y: F, width: D - F * 2, height: V - F * 2 }, q = wf(P, { alignment: sn.Center, fontSize: h ?? v, font: n, bounds: se }), ue = wf(C, { alignment: sn.Center, fontSize: h ?? v, font: n, bounds: se }), ye = Math.min(q.fontSize, ue.fontSize), ae = (u = c ?? f) !== null && u !== void 0 ? u : I; Rr(c || h !== void 0 ? e : t.acroField, ae, n, ye); var _ = { x: 0 + F / 2, y: 0 + F / 2, width: D - F, height: V - F, borderWidth: F, borderColor: Y, textColor: ae, font: n.name, fontSize: ye }; return { normal: ft(B, Vw(_e(_e({}, _), { color: Z, textLines: [q.line] }))), down: ft(B, Vw(_e(_e({}, _), { color: ie, textLines: [ue.line] }))) } }, X5 = function (t, e, n) { var r, i, s, a, u = Fr(e), c = Fr(t.acroField), f = vo(e), h = vo(t.acroField), v = e.getRectangle(), m = e.getAppearanceCharacteristics(), g = e.getBorderStyle(), S = (r = t.getText()) !== null && r !== void 0 ? r : "", b = (i = g == null ? void 0 : g.getWidth()) !== null && i !== void 0 ? i : 0, P = Ni(m == null ? void 0 : m.getRotation()), C = ns(v, P), F = C.width, A = C.height, N = Co(_e(_e({}, v), { rotation: P })), D = St(0, 0, 0), V = Bn(m == null ? void 0 : m.getBorderColor()), B = Bn(m == null ? void 0 : m.getBackgroundColor()), I, Y, Z = t.isCombed() ? 0 : 1, ie = { x: b + Z, y: b + Z, width: F - (b + Z) * 2, height: A - (b + Z) * 2 }; if (t.isMultiline()) { var se = _P(S, { alignment: t.getAlignment(), fontSize: f ?? h, font: n, bounds: ie }); I = se.lines, Y = se.fontSize } else if (t.isCombed()) { var se = U5(S, { fontSize: f ?? h, font: n, bounds: ie, cellCount: (s = t.getMaxLength()) !== null && s !== void 0 ? s : 0 }); I = se.cells, Y = se.fontSize } else { var se = wf(S, { alignment: t.getAlignment(), fontSize: f ?? h, font: n, bounds: ie }); I = [se.line], Y = se.fontSize } var q = (a = u ?? c) !== null && a !== void 0 ? a : D; Rr(u || f !== void 0 ? e : t.acroField, q, n, Y); var ue = { x: 0 + b / 2, y: 0 + b / 2, width: F - b, height: A - b, borderWidth: b ?? 0, borderColor: V, textColor: q, font: n.name, fontSize: Y, color: B, textLines: I, padding: Z }; return ft(N, XP(ue)) }, Z5 = function (t, e, n) { var r, i, s, a = Fr(e), u = Fr(t.acroField), c = vo(e), f = vo(t.acroField), h = e.getRectangle(), v = e.getAppearanceCharacteristics(), m = e.getBorderStyle(), g = (r = t.getSelected()[0]) !== null && r !== void 0 ? r : "", S = (i = m == null ? void 0 : m.getWidth()) !== null && i !== void 0 ? i : 0, b = Ni(v == null ? void 0 : v.getRotation()), P = ns(h, b), C = P.width, F = P.height, A = Co(_e(_e({}, h), { rotation: b })), N = St(0, 0, 0), D = Bn(v == null ? void 0 : v.getBorderColor()), V = Bn(v == null ? void 0 : v.getBackgroundColor()), B = 1, I = { x: S + B, y: S + B, width: C - (S + B) * 2, height: F - (S + B) * 2 }, Y = wf(g, { alignment: sn.Left, fontSize: c ?? f, font: n, bounds: I }), Z = Y.line, ie = Y.fontSize, se = (s = a ?? u) !== null && s !== void 0 ? s : N; Rr(a || c !== void 0 ? e : t.acroField, se, n, ie); var q = { x: 0 + S / 2, y: 0 + S / 2, width: C - S, height: F - S, borderWidth: S ?? 0, borderColor: D, textColor: se, font: n.name, fontSize: ie, color: V, textLines: [Z], padding: B }; return ft(A, XP(q)) }, Y5 = function (t, e, n) {
  var r, i, s = Fr(e), a = Fr(t.acroField), u = vo(e), c = vo(t.acroField), f = e.getRectangle(), h = e.getAppearanceCharacteristics(), v = e.getBorderStyle(), m = (r = v == null ? void 0 : v.getWidth()) !== null && r !== void 0 ? r : 0, g = Ni(h == null ? void 0 : h.getRotation()), S = ns(f, g), b = S.width, P = S.height, C = Co(_e(_e({}, f), { rotation: g })), F = St(0, 0, 0), A = Bn(h == null ? void 0 : h.getBorderColor()), N = Bn(h == null ? void 0 : h.getBackgroundColor()), D = t.getOptions(), V = t.getSelected(); t.isSorted() && D.sort(); for (var B = "", I = 0, Y = D.length; I < Y; I++)B += D[I], I < Y - 1 && (B += `
`); for (var Z = 1, ie = { x: m + Z, y: m + Z, width: b - (m + Z) * 2, height: P - (m + Z) * 2 }, se = _P(B, { alignment: sn.Left, fontSize: u ?? c, font: n, bounds: ie }), q = se.lines, ue = se.fontSize, ye = se.lineHeight, ae = [], I = 0, Y = q.length; I < Y; I++) { var _ = q[I]; V.includes(_.text) && ae.push(I) } var Q = St(153 / 255, 193 / 255, 218 / 255), le = (i = s ?? a) !== null && i !== void 0 ? i : F; return Rr(s || u !== void 0 ? e : t.acroField, le, n, ue), ft(C, A5({ x: 0 + m / 2, y: 0 + m / 2, width: b - m, height: P - m, borderWidth: m ?? 0, borderColor: A, textColor: le, font: n.name, fontSize: ue, color: N, textLines: q, lineHeight: ye, selectedColor: Q, selectedLines: ae, padding: Z }))
}, $P = function () { function t(e, n, r) { this.alreadyEmbedded = !1, G(e, "ref", [[wt, "PDFRef"]]), G(n, "doc", [[_o, "PDFDocument"]]), G(r, "embedder", [[PP, "PDFPageEmbedder"]]), this.ref = e, this.doc = n, this.width = r.width, this.height = r.height, this.embedder = r } return t.prototype.scale = function (e) { return G(e, "factor", ["number"]), { width: this.width * e, height: this.height * e } }, t.prototype.size = function () { return this.scale(1) }, t.prototype.embed = function () { return tt(this, void 0, void 0, function () { return nt(this, function (e) { switch (e.label) { case 0: return this.alreadyEmbedded ? [3, 2] : [4, this.embedder.embedIntoContext(this.doc.context, this.ref)]; case 1: e.sent(), this.alreadyEmbedded = !0, e.label = 2; case 2: return [2] } }) }) }, t.of = function (e, n, r) { return new t(e, n, r) }, t }(), lr = function () { function t(e, n, r) { this.modified = !0, G(e, "ref", [[wt, "PDFRef"]]), G(n, "doc", [[_o, "PDFDocument"]]), G(r, "embedder", [[Lv, "CustomFontEmbedder"], [df, "StandardFontEmbedder"]]), this.ref = e, this.doc = n, this.name = r.fontName, this.embedder = r } return t.prototype.encodeText = function (e) { return G(e, "text", ["string"]), this.modified = !0, this.embedder.encodeText(e) }, t.prototype.widthOfTextAtSize = function (e, n) { return G(e, "text", ["string"]), G(n, "size", ["number"]), this.embedder.widthOfTextAtSize(e, n) }, t.prototype.heightAtSize = function (e, n) { var r; return G(e, "size", ["number"]), xe(n == null ? void 0 : n.descender, "options.descender", ["boolean"]), this.embedder.heightOfFontAtSize(e, { descender: (r = n == null ? void 0 : n.descender) !== null && r !== void 0 ? r : !0 }) }, t.prototype.sizeAtHeight = function (e) { return G(e, "height", ["number"]), this.embedder.sizeOfFontAtHeight(e) }, t.prototype.getCharacterSet = function () { return this.embedder instanceof df ? this.embedder.encoding.supportedCodePoints : this.embedder.font.characterSet }, t.prototype.embed = function () { return tt(this, void 0, void 0, function () { return nt(this, function (e) { switch (e.label) { case 0: return this.modified ? [4, this.embedder.embedIntoContext(this.doc.context, this.ref)] : [3, 2]; case 1: e.sent(), this.modified = !1, e.label = 2; case 2: return [2] } }) }) }, t.of = function (e, n, r) { return new t(e, n, r) }, t }(), x0 = function () { function t(e, n, r) { G(e, "ref", [[wt, "PDFRef"]]), G(n, "doc", [[_o, "PDFDocument"]]), G(r, "embedder", [[wP, "JpegEmbedder"], [SP, "PngEmbedder"]]), this.ref = e, this.doc = n, this.width = r.width, this.height = r.height, this.embedder = r } return t.prototype.scale = function (e) { return G(e, "factor", ["number"]), { width: this.width * e, height: this.height * e } }, t.prototype.scaleToFit = function (e, n) { G(e, "width", ["number"]), G(n, "height", ["number"]); var r = e / this.width, i = n / this.height, s = Math.min(r, i); return this.scale(s) }, t.prototype.size = function () { return this.scale(1) }, t.prototype.embed = function () { return tt(this, void 0, void 0, function () { var e, n, r; return nt(this, function (i) { switch (i.label) { case 0: return this.embedder ? (this.embedTask || (e = this, n = e.doc, r = e.ref, this.embedTask = this.embedder.embedIntoContext(n.context, r)), [4, this.embedTask]) : [2]; case 1: return i.sent(), this.embedder = void 0, [2] } }) }) }, t.of = function (e, n, r) { return new t(e, n, r) }, t }(), uo; (function (t) { t[t.Left = 0] = "Left", t[t.Center = 1] = "Center", t[t.Right = 2] = "Right" })(uo || (uo = {})); var da = function (t) { xe(t == null ? void 0 : t.x, "options.x", ["number"]), xe(t == null ? void 0 : t.y, "options.y", ["number"]), xe(t == null ? void 0 : t.width, "options.width", ["number"]), xe(t == null ? void 0 : t.height, "options.height", ["number"]), xe(t == null ? void 0 : t.textColor, "options.textColor", [[Object, "Color"]]), xe(t == null ? void 0 : t.backgroundColor, "options.backgroundColor", [[Object, "Color"]]), xe(t == null ? void 0 : t.borderColor, "options.borderColor", [[Object, "Color"]]), xe(t == null ? void 0 : t.borderWidth, "options.borderWidth", ["number"]), xe(t == null ? void 0 : t.rotate, "options.rotate", [[Object, "Rotation"]]) }, os = function () {
  function t(e, n, r) { G(e, "acroField", [[ua, "PDFAcroTerminal"]]), G(n, "ref", [[wt, "PDFRef"]]), G(r, "doc", [[_o, "PDFDocument"]]), this.acroField = e, this.ref = n, this.doc = r } return t.prototype.getName = function () { var e; return (e = this.acroField.getFullyQualifiedName()) !== null && e !== void 0 ? e : "" }, t.prototype.isReadOnly = function () { return this.acroField.hasFlag(Kr.ReadOnly) }, t.prototype.enableReadOnly = function () { this.acroField.setFlagTo(Kr.ReadOnly, !0) }, t.prototype.disableReadOnly = function () { this.acroField.setFlagTo(Kr.ReadOnly, !1) }, t.prototype.isRequired = function () { return this.acroField.hasFlag(Kr.Required) }, t.prototype.enableRequired = function () { this.acroField.setFlagTo(Kr.Required, !0) }, t.prototype.disableRequired = function () { this.acroField.setFlagTo(Kr.Required, !1) }, t.prototype.isExported = function () { return !this.acroField.hasFlag(Kr.NoExport) }, t.prototype.enableExporting = function () { this.acroField.setFlagTo(Kr.NoExport, !1) }, t.prototype.disableExporting = function () { this.acroField.setFlagTo(Kr.NoExport, !0) }, t.prototype.needsAppearancesUpdate = function () { throw new Ar(this.constructor.name, "needsAppearancesUpdate") }, t.prototype.defaultUpdateAppearances = function (e) { throw new Ar(this.constructor.name, "defaultUpdateAppearances") }, t.prototype.markAsDirty = function () { this.doc.getForm().markFieldAsDirty(this.ref) }, t.prototype.markAsClean = function () { this.doc.getForm().markFieldAsClean(this.ref) }, t.prototype.isDirty = function () { return this.doc.getForm().fieldIsDirty(this.ref) }, t.prototype.createWidget = function (e) {
    var n, r = e.textColor, i = e.backgroundColor, s = e.borderColor, a = e.borderWidth, u = NP(e.rotate), c = e.caption, f = e.x, h = e.y, v = e.width + a, m = e.height + a, g = !!e.hidden, S = e.page; hP(u, "degreesAngle", 90); var b = m0.create(this.doc.context, this.ref), P = o5({ x: f, y: h, width: v, height: m }, a, u); b.setRectangle(P), S && b.setP(S); var C = b.getOrCreateAppearanceCharacteristics(); i && C.setBackgroundColor(Rw(i)), C.setRotation(u), c && C.setCaptions({ normal: c }), s && C.setBorderColor(Rw(s)); var F = b.getOrCreateBorderStyle(); if (a !== void 0 && F.setWidth(a), b.setFlagTo(Al.Print, !0), b.setFlagTo(Al.Hidden, g), b.setFlagTo(Al.Invisible, !1), r) {
      var A = (n = this.acroField.getDefaultAppearance()) !== null && n !== void 0 ? n : "", N = A + `
`+ is(r).toString(); this.acroField.setDefaultAppearance(N)
    } return b
  }, t.prototype.updateWidgetAppearanceWithFont = function (e, n, r) { var i = r.normal, s = r.rollover, a = r.down; this.updateWidgetAppearances(e, { normal: this.createAppearanceStream(e, i, n), rollover: s && this.createAppearanceStream(e, s, n), down: a && this.createAppearanceStream(e, a, n) }) }, t.prototype.updateOnOffWidgetAppearance = function (e, n, r) { var i = r.normal, s = r.rollover, a = r.down; this.updateWidgetAppearances(e, { normal: this.createAppearanceDict(e, i, n), rollover: s && this.createAppearanceDict(e, s, n), down: a && this.createAppearanceDict(e, a, n) }) }, t.prototype.updateWidgetAppearances = function (e, n) { var r = n.normal, i = n.rollover, s = n.down; e.setNormalAppearance(r), i ? e.setRolloverAppearance(i) : e.removeRolloverAppearance(), s ? e.setDownAppearance(s) : e.removeDownAppearance() }, t.prototype.createAppearanceStream = function (e, n, r) { var i, s = this.acroField.dict.context, a = e.getRectangle(), u = a.width, c = a.height, f = r && { Font: (i = {}, i[r.name] = r.ref, i) }, h = s.formXObject(n, { Resources: f, BBox: s.obj([0, 0, u, c]), Matrix: s.obj([1, 0, 0, 1, 0, 0]) }), v = s.register(h); return v }, t.prototype.createImageAppearanceStream = function (e, n, r) { var i, s, a = this.acroField.dict.context, u = e.getRectangle(), c = e.getAppearanceCharacteristics(), f = e.getBorderStyle(), h = (s = f == null ? void 0 : f.getWidth()) !== null && s !== void 0 ? s : 0, v = Ni(c == null ? void 0 : c.getRotation()), m = Co(_e(_e({}, u), { rotation: v })), g = ns(u, v), S = n.scaleToFit(g.width - h * 2, g.height - h * 2), b = { x: h, y: h, width: S.width, height: S.height, rotate: Ge(0), xSkew: Ge(0), ySkew: Ge(0) }; r === uo.Center ? (b.x += (g.width - h * 2) / 2 - S.width / 2, b.y += (g.height - h * 2) / 2 - S.height / 2) : r === uo.Right && (b.x = g.width - h - S.width, b.y = g.height - h - S.height); var P = this.doc.context.addRandomSuffix("Image", 10), C = ft(m, GP(P, b)), F = { XObject: (i = {}, i[P] = n.ref, i) }, A = a.formXObject(C, { Resources: F, BBox: a.obj([0, 0, u.width, u.height]), Matrix: a.obj([1, 0, 0, 1, 0, 0]) }); return a.register(A) }, t.prototype.createAppearanceDict = function (e, n, r) { var i = this.acroField.dict.context, s = this.createAppearanceStream(e, n.on), a = this.createAppearanceStream(e, n.off), u = i.obj({}); return u.set(r, s), u.set(O.of("Off"), a), u }, t
}(), pl = function (t) { we(e, t); function e(n, r, i) { var s = t.call(this, n, r, i) || this; return G(n, "acroCheckBox", [[Kf, "PDFAcroCheckBox"]]), s.acroField = n, s } return e.prototype.check = function () { var n, r = (n = this.acroField.getOnValue()) !== null && n !== void 0 ? n : O.of("Yes"); this.markAsDirty(), this.acroField.setValue(r) }, e.prototype.uncheck = function () { this.markAsDirty(), this.acroField.setValue(O.of("Off")) }, e.prototype.isChecked = function () { var n = this.acroField.getOnValue(); return !!n && n === this.acroField.getValue() }, e.prototype.addToPage = function (n, r) { var i, s, a, u, c, f; G(n, "page", [[kr, "PDFPage"]]), da(r), r || (r = {}), "textColor" in r || (r.textColor = St(0, 0, 0)), "backgroundColor" in r || (r.backgroundColor = St(1, 1, 1)), "borderColor" in r || (r.borderColor = St(0, 0, 0)), "borderWidth" in r || (r.borderWidth = 1); var h = this.createWidget({ x: (i = r.x) !== null && i !== void 0 ? i : 0, y: (s = r.y) !== null && s !== void 0 ? s : 0, width: (a = r.width) !== null && a !== void 0 ? a : 50, height: (u = r.height) !== null && u !== void 0 ? u : 50, textColor: r.textColor, backgroundColor: r.backgroundColor, borderColor: r.borderColor, borderWidth: (c = r.borderWidth) !== null && c !== void 0 ? c : 0, rotate: (f = r.rotate) !== null && f !== void 0 ? f : Ge(0), hidden: r.hidden, page: n.ref }), v = this.doc.context.register(h.dict); this.acroField.addWidget(v), h.setAppearanceState(O.of("Off")), this.updateWidgetAppearance(h, O.of("Yes")), n.node.addAnnot(v) }, e.prototype.needsAppearancesUpdate = function () { for (var n, r = this.acroField.getWidgets(), i = 0, s = r.length; i < s; i++) { var a = r[i], u = a.getAppearanceState(), c = (n = a.getAppearances()) === null || n === void 0 ? void 0 : n.normal; if (!(c instanceof et) || u && !c.has(u)) return !0 } return !1 }, e.prototype.defaultUpdateAppearances = function () { this.updateAppearances() }, e.prototype.updateAppearances = function (n) { var r; xe(n, "provider", [Function]); for (var i = this.acroField.getWidgets(), s = 0, a = i.length; s < a; s++) { var u = i[s], c = (r = u.getOnValue()) !== null && r !== void 0 ? r : O.of("Yes"); c && this.updateWidgetAppearance(u, c, n) } this.markAsClean() }, e.prototype.updateWidgetAppearance = function (n, r, i) { var s = i ?? H5, a = fa(s(this, n)); this.updateOnOffWidgetAppearance(n, r, a) }, e.of = function (n, r, i) { return new e(n, r, i) }, e }(os), qc = function (t) { we(e, t); function e(n, r, i) { var s = t.call(this, n, r, i) || this; return G(n, "acroComboBox", [[Hf, "PDFAcroComboBox"]]), s.acroField = n, s } return e.prototype.getOptions = function () { for (var n = this.acroField.getOptions(), r = new Array(n.length), i = 0, s = r.length; i < s; i++) { var a = n[i], u = a.display, c = a.value; r[i] = (u ?? c).decodeText() } return r }, e.prototype.getSelected = function () { for (var n = this.acroField.getValues(), r = new Array(n.length), i = 0, s = n.length; i < s; i++)r[i] = n[i].decodeText(); return r }, e.prototype.setOptions = function (n) { G(n, "options", [Array]); for (var r = new Array(n.length), i = 0, s = n.length; i < s; i++)r[i] = { value: qe.fromText(n[i]) }; this.acroField.setOptions(r) }, e.prototype.addOptions = function (n) { G(n, "options", ["string", Array]); for (var r = Array.isArray(n) ? n : [n], i = this.acroField.getOptions(), s = new Array(r.length), a = 0, u = r.length; a < u; a++)s[a] = { value: qe.fromText(r[a]) }; this.acroField.setOptions(i.concat(s)) }, e.prototype.select = function (n, r) { r === void 0 && (r = !1), G(n, "options", ["string", Array]), G(r, "merge", ["boolean"]); var i = Array.isArray(n) ? n : [n], s = this.getOptions(), a = i.find(function (v) { return !s.includes(v) }); a && this.enableEditing(), this.markAsDirty(), (i.length > 1 || i.length === 1 && r) && this.enableMultiselect(); for (var u = new Array(i.length), c = 0, f = i.length; c < f; c++)u[c] = qe.fromText(i[c]); if (r) { var h = this.acroField.getValues(); this.acroField.setValues(h.concat(u)) } else this.acroField.setValues(u) }, e.prototype.clear = function () { this.markAsDirty(), this.acroField.setValues([]) }, e.prototype.setFontSize = function (n) { Uf(n, "fontSize"), this.acroField.setFontSize(n), this.markAsDirty() }, e.prototype.isEditable = function () { return this.acroField.hasFlag(yt.Edit) }, e.prototype.enableEditing = function () { this.acroField.setFlagTo(yt.Edit, !0) }, e.prototype.disableEditing = function () { this.acroField.setFlagTo(yt.Edit, !1) }, e.prototype.isSorted = function () { return this.acroField.hasFlag(yt.Sort) }, e.prototype.enableSorting = function () { this.acroField.setFlagTo(yt.Sort, !0) }, e.prototype.disableSorting = function () { this.acroField.setFlagTo(yt.Sort, !1) }, e.prototype.isMultiselect = function () { return this.acroField.hasFlag(yt.MultiSelect) }, e.prototype.enableMultiselect = function () { this.acroField.setFlagTo(yt.MultiSelect, !0) }, e.prototype.disableMultiselect = function () { this.acroField.setFlagTo(yt.MultiSelect, !1) }, e.prototype.isSpellChecked = function () { return !this.acroField.hasFlag(yt.DoNotSpellCheck) }, e.prototype.enableSpellChecking = function () { this.acroField.setFlagTo(yt.DoNotSpellCheck, !1) }, e.prototype.disableSpellChecking = function () { this.acroField.setFlagTo(yt.DoNotSpellCheck, !0) }, e.prototype.isSelectOnClick = function () { return this.acroField.hasFlag(yt.CommitOnSelChange) }, e.prototype.enableSelectOnClick = function () { this.acroField.setFlagTo(yt.CommitOnSelChange, !0) }, e.prototype.disableSelectOnClick = function () { this.acroField.setFlagTo(yt.CommitOnSelChange, !1) }, e.prototype.addToPage = function (n, r) { var i, s, a, u, c, f, h; G(n, "page", [[kr, "PDFPage"]]), da(r), r || (r = {}), "textColor" in r || (r.textColor = St(0, 0, 0)), "backgroundColor" in r || (r.backgroundColor = St(1, 1, 1)), "borderColor" in r || (r.borderColor = St(0, 0, 0)), "borderWidth" in r || (r.borderWidth = 1); var v = this.createWidget({ x: (i = r.x) !== null && i !== void 0 ? i : 0, y: (s = r.y) !== null && s !== void 0 ? s : 0, width: (a = r.width) !== null && a !== void 0 ? a : 200, height: (u = r.height) !== null && u !== void 0 ? u : 50, textColor: r.textColor, backgroundColor: r.backgroundColor, borderColor: r.borderColor, borderWidth: (c = r.borderWidth) !== null && c !== void 0 ? c : 0, rotate: (f = r.rotate) !== null && f !== void 0 ? f : Ge(0), hidden: r.hidden, page: n.ref }), m = this.doc.context.register(v.dict); this.acroField.addWidget(m); var g = (h = r.font) !== null && h !== void 0 ? h : this.doc.getForm().getDefaultFont(); this.updateWidgetAppearance(v, g), n.node.addAnnot(m) }, e.prototype.needsAppearancesUpdate = function () { var n; if (this.isDirty()) return !0; for (var r = this.acroField.getWidgets(), i = 0, s = r.length; i < s; i++) { var a = r[i], u = ((n = a.getAppearances()) === null || n === void 0 ? void 0 : n.normal) instanceof or; if (!u) return !0 } return !1 }, e.prototype.defaultUpdateAppearances = function (n) { G(n, "font", [[lr, "PDFFont"]]), this.updateAppearances(n) }, e.prototype.updateAppearances = function (n, r) { G(n, "font", [[lr, "PDFFont"]]), xe(r, "provider", [Function]); for (var i = this.acroField.getWidgets(), s = 0, a = i.length; s < a; s++) { var u = i[s]; this.updateWidgetAppearance(u, n, r) } this.markAsClean() }, e.prototype.updateWidgetAppearance = function (n, r, i) { var s = i ?? Z5, a = fa(s(this, n, r)); this.updateWidgetAppearanceWithFont(n, r, a) }, e.of = function (n, r, i) { return new e(n, r, i) }, e }(os), Gc = function (t) { we(e, t); function e(n, r, i) { var s = t.call(this, n, r, i) || this; return G(n, "acroListBox", [[Zf, "PDFAcroListBox"]]), s.acroField = n, s } return e.prototype.getOptions = function () { for (var n = this.acroField.getOptions(), r = new Array(n.length), i = 0, s = r.length; i < s; i++) { var a = n[i], u = a.display, c = a.value; r[i] = (u ?? c).decodeText() } return r }, e.prototype.getSelected = function () { for (var n = this.acroField.getValues(), r = new Array(n.length), i = 0, s = n.length; i < s; i++)r[i] = n[i].decodeText(); return r }, e.prototype.setOptions = function (n) { G(n, "options", [Array]), this.markAsDirty(); for (var r = new Array(n.length), i = 0, s = n.length; i < s; i++)r[i] = { value: qe.fromText(n[i]) }; this.acroField.setOptions(r) }, e.prototype.addOptions = function (n) { G(n, "options", ["string", Array]), this.markAsDirty(); for (var r = Array.isArray(n) ? n : [n], i = this.acroField.getOptions(), s = new Array(r.length), a = 0, u = r.length; a < u; a++)s[a] = { value: qe.fromText(r[a]) }; this.acroField.setOptions(i.concat(s)) }, e.prototype.select = function (n, r) { r === void 0 && (r = !1), G(n, "options", ["string", Array]), G(r, "merge", ["boolean"]); var i = Array.isArray(n) ? n : [n], s = this.getOptions(); XM(i, "option", s), this.markAsDirty(), (i.length > 1 || i.length === 1 && r) && this.enableMultiselect(); for (var a = new Array(i.length), u = 0, c = i.length; u < c; u++)a[u] = qe.fromText(i[u]); if (r) { var f = this.acroField.getValues(); this.acroField.setValues(f.concat(a)) } else this.acroField.setValues(a) }, e.prototype.clear = function () { this.markAsDirty(), this.acroField.setValues([]) }, e.prototype.setFontSize = function (n) { Uf(n, "fontSize"), this.acroField.setFontSize(n), this.markAsDirty() }, e.prototype.isSorted = function () { return this.acroField.hasFlag(yt.Sort) }, e.prototype.enableSorting = function () { this.acroField.setFlagTo(yt.Sort, !0) }, e.prototype.disableSorting = function () { this.acroField.setFlagTo(yt.Sort, !1) }, e.prototype.isMultiselect = function () { return this.acroField.hasFlag(yt.MultiSelect) }, e.prototype.enableMultiselect = function () { this.acroField.setFlagTo(yt.MultiSelect, !0) }, e.prototype.disableMultiselect = function () { this.acroField.setFlagTo(yt.MultiSelect, !1) }, e.prototype.isSelectOnClick = function () { return this.acroField.hasFlag(yt.CommitOnSelChange) }, e.prototype.enableSelectOnClick = function () { this.acroField.setFlagTo(yt.CommitOnSelChange, !0) }, e.prototype.disableSelectOnClick = function () { this.acroField.setFlagTo(yt.CommitOnSelChange, !1) }, e.prototype.addToPage = function (n, r) { var i, s, a, u, c, f, h; G(n, "page", [[kr, "PDFPage"]]), da(r), r || (r = {}), "textColor" in r || (r.textColor = St(0, 0, 0)), "backgroundColor" in r || (r.backgroundColor = St(1, 1, 1)), "borderColor" in r || (r.borderColor = St(0, 0, 0)), "borderWidth" in r || (r.borderWidth = 1); var v = this.createWidget({ x: (i = r.x) !== null && i !== void 0 ? i : 0, y: (s = r.y) !== null && s !== void 0 ? s : 0, width: (a = r.width) !== null && a !== void 0 ? a : 200, height: (u = r.height) !== null && u !== void 0 ? u : 100, textColor: r.textColor, backgroundColor: r.backgroundColor, borderColor: r.borderColor, borderWidth: (c = r.borderWidth) !== null && c !== void 0 ? c : 0, rotate: (f = r.rotate) !== null && f !== void 0 ? f : Ge(0), hidden: r.hidden, page: n.ref }), m = this.doc.context.register(v.dict); this.acroField.addWidget(m); var g = (h = r.font) !== null && h !== void 0 ? h : this.doc.getForm().getDefaultFont(); this.updateWidgetAppearance(v, g), n.node.addAnnot(m) }, e.prototype.needsAppearancesUpdate = function () { var n; if (this.isDirty()) return !0; for (var r = this.acroField.getWidgets(), i = 0, s = r.length; i < s; i++) { var a = r[i], u = ((n = a.getAppearances()) === null || n === void 0 ? void 0 : n.normal) instanceof or; if (!u) return !0 } return !1 }, e.prototype.defaultUpdateAppearances = function (n) { G(n, "font", [[lr, "PDFFont"]]), this.updateAppearances(n) }, e.prototype.updateAppearances = function (n, r) { G(n, "font", [[lr, "PDFFont"]]), xe(r, "provider", [Function]); for (var i = this.acroField.getWidgets(), s = 0, a = i.length; s < a; s++) { var u = i[s]; this.updateWidgetAppearance(u, n, r) } this.markAsClean() }, e.prototype.updateWidgetAppearance = function (n, r, i) { var s = i ?? Y5, a = fa(s(this, n, r)); this.updateWidgetAppearanceWithFont(n, r, a) }, e.of = function (n, r, i) { return new e(n, r, i) }, e }(os), vl = function (t) { we(e, t); function e(n, r, i) { var s = t.call(this, n, r, i) || this; return G(n, "acroRadioButton", [[Xf, "PDFAcroRadioButton"]]), s.acroField = n, s } return e.prototype.getOptions = function () { var n = this.acroField.getExportValues(); if (n) { for (var r = new Array(n.length), i = 0, s = n.length; i < s; i++)r[i] = n[i].decodeText(); return r } for (var a = this.acroField.getOnValues(), u = new Array(a.length), i = 0, s = u.length; i < s; i++)u[i] = a[i].decodeText(); return u }, e.prototype.getSelected = function () { var n = this.acroField.getValue(); if (n !== O.of("Off")) { var r = this.acroField.getExportValues(); if (r) { for (var i = this.acroField.getOnValues(), s = 0, a = i.length; s < a; s++)if (i[s] === n) return r[s].decodeText() } return n.decodeText() } }, e.prototype.select = function (n) { G(n, "option", ["string"]); var r = this.getOptions(); ao(n, "option", r), this.markAsDirty(); var i = this.acroField.getOnValues(), s = this.acroField.getExportValues(); if (s) for (var a = 0, u = s.length; a < u; a++)s[a].decodeText() === n && this.acroField.setValue(i[a]); else for (var a = 0, u = i.length; a < u; a++) { var c = i[a]; c.decodeText() === n && this.acroField.setValue(c) } }, e.prototype.clear = function () { this.markAsDirty(), this.acroField.setValue(O.of("Off")) }, e.prototype.isOffToggleable = function () { return !this.acroField.hasFlag(Tr.NoToggleToOff) }, e.prototype.enableOffToggling = function () { this.acroField.setFlagTo(Tr.NoToggleToOff, !1) }, e.prototype.disableOffToggling = function () { this.acroField.setFlagTo(Tr.NoToggleToOff, !0) }, e.prototype.isMutuallyExclusive = function () { return !this.acroField.hasFlag(Tr.RadiosInUnison) }, e.prototype.enableMutualExclusion = function () { this.acroField.setFlagTo(Tr.RadiosInUnison, !1) }, e.prototype.disableMutualExclusion = function () { this.acroField.setFlagTo(Tr.RadiosInUnison, !0) }, e.prototype.addOptionToPage = function (n, r, i) { var s, a, u, c, f, h, v, m, g; G(n, "option", ["string"]), G(r, "page", [[kr, "PDFPage"]]), da(i); var S = this.createWidget({ x: (s = i == null ? void 0 : i.x) !== null && s !== void 0 ? s : 0, y: (a = i == null ? void 0 : i.y) !== null && a !== void 0 ? a : 0, width: (u = i == null ? void 0 : i.width) !== null && u !== void 0 ? u : 50, height: (c = i == null ? void 0 : i.height) !== null && c !== void 0 ? c : 50, textColor: (f = i == null ? void 0 : i.textColor) !== null && f !== void 0 ? f : St(0, 0, 0), backgroundColor: (h = i == null ? void 0 : i.backgroundColor) !== null && h !== void 0 ? h : St(1, 1, 1), borderColor: (v = i == null ? void 0 : i.borderColor) !== null && v !== void 0 ? v : St(0, 0, 0), borderWidth: (m = i == null ? void 0 : i.borderWidth) !== null && m !== void 0 ? m : 1, rotate: (g = i == null ? void 0 : i.rotate) !== null && g !== void 0 ? g : Ge(0), hidden: i == null ? void 0 : i.hidden, page: r.ref }), b = this.doc.context.register(S.dict), P = this.acroField.addWidgetWithOpt(b, qe.fromText(n), !this.isMutuallyExclusive()); S.setAppearanceState(O.of("Off")), this.updateWidgetAppearance(S, P), r.node.addAnnot(b) }, e.prototype.needsAppearancesUpdate = function () { for (var n, r = this.acroField.getWidgets(), i = 0, s = r.length; i < s; i++) { var a = r[i], u = a.getAppearanceState(), c = (n = a.getAppearances()) === null || n === void 0 ? void 0 : n.normal; if (!(c instanceof et) || u && !c.has(u)) return !0 } return !1 }, e.prototype.defaultUpdateAppearances = function () { this.updateAppearances() }, e.prototype.updateAppearances = function (n) { xe(n, "provider", [Function]); for (var r = this.acroField.getWidgets(), i = 0, s = r.length; i < s; i++) { var a = r[i], u = a.getOnValue(); u && this.updateWidgetAppearance(a, u, n) } }, e.prototype.updateWidgetAppearance = function (n, r, i) { var s = i ?? q5, a = fa(s(this, n)); this.updateOnOffWidgetAppearance(n, r, a) }, e.of = function (n, r, i) { return new e(n, r, i) }, e }(os), w0 = function (t) { we(e, t); function e(n, r, i) { var s = t.call(this, n, r, i) || this; return G(n, "acroSignature", [[Iv, "PDFAcroSignature"]]), s.acroField = n, s } return e.prototype.needsAppearancesUpdate = function () { return !1 }, e.of = function (n, r, i) { return new e(n, r, i) }, e }(os), Xc = function (t) { we(e, t); function e(n, r, i) { var s = t.call(this, n, r, i) || this; return G(n, "acroText", [[qf, "PDFAcroText"]]), s.acroField = n, s } return e.prototype.getText = function () { var n = this.acroField.getValue(); if (!n && this.isRichFormatted()) throw new V5(this.getName()); return n == null ? void 0 : n.decodeText() }, e.prototype.setText = function (n) { xe(n, "text", ["string"]); var r = this.getMaxLength(); if (r !== void 0 && n && n.length > r) throw new B5(n.length, r, this.getName()); this.markAsDirty(), this.disableRichFormatting(), n ? this.acroField.setValue(qe.fromText(n)) : this.acroField.removeValue() }, e.prototype.getAlignment = function () { var n = this.acroField.getQuadding(); return n === 0 ? sn.Left : n === 1 ? sn.Center : n === 2 ? sn.Right : sn.Left }, e.prototype.setAlignment = function (n) { ao(n, "alignment", sn), this.markAsDirty(), this.acroField.setQuadding(n) }, e.prototype.getMaxLength = function () { return this.acroField.getMaxLength() }, e.prototype.setMaxLength = function (n) { if (Ur(n, "maxLength", 0, Number.MAX_SAFE_INTEGER), this.markAsDirty(), n === void 0) this.acroField.removeMaxLength(); else { var r = this.getText(); if (r && r.length > n) throw new L5(r.length, n, this.getName()); this.acroField.setMaxLength(n) } }, e.prototype.removeMaxLength = function () { this.markAsDirty(), this.acroField.removeMaxLength() }, e.prototype.setImage = function (n) { for (var r = this.getAlignment(), i = r === sn.Center ? uo.Center : r === sn.Right ? uo.Right : uo.Left, s = this.acroField.getWidgets(), a = 0, u = s.length; a < u; a++) { var c = s[a], f = this.createImageAppearanceStream(c, n, i); this.updateWidgetAppearances(c, { normal: f }) } this.markAsClean() }, e.prototype.setFontSize = function (n) { Uf(n, "fontSize"), this.acroField.setFontSize(n), this.markAsDirty() }, e.prototype.isMultiline = function () { return this.acroField.hasFlag(Nt.Multiline) }, e.prototype.enableMultiline = function () { this.markAsDirty(), this.acroField.setFlagTo(Nt.Multiline, !0) }, e.prototype.disableMultiline = function () { this.markAsDirty(), this.acroField.setFlagTo(Nt.Multiline, !1) }, e.prototype.isPassword = function () { return this.acroField.hasFlag(Nt.Password) }, e.prototype.enablePassword = function () { this.acroField.setFlagTo(Nt.Password, !0) }, e.prototype.disablePassword = function () { this.acroField.setFlagTo(Nt.Password, !1) }, e.prototype.isFileSelector = function () { return this.acroField.hasFlag(Nt.FileSelect) }, e.prototype.enableFileSelection = function () { this.acroField.setFlagTo(Nt.FileSelect, !0) }, e.prototype.disableFileSelection = function () { this.acroField.setFlagTo(Nt.FileSelect, !1) }, e.prototype.isSpellChecked = function () { return !this.acroField.hasFlag(Nt.DoNotSpellCheck) }, e.prototype.enableSpellChecking = function () { this.acroField.setFlagTo(Nt.DoNotSpellCheck, !1) }, e.prototype.disableSpellChecking = function () { this.acroField.setFlagTo(Nt.DoNotSpellCheck, !0) }, e.prototype.isScrollable = function () { return !this.acroField.hasFlag(Nt.DoNotScroll) }, e.prototype.enableScrolling = function () { this.acroField.setFlagTo(Nt.DoNotScroll, !1) }, e.prototype.disableScrolling = function () { this.acroField.setFlagTo(Nt.DoNotScroll, !0) }, e.prototype.isCombed = function () { return this.acroField.hasFlag(Nt.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && this.getMaxLength() !== void 0 }, e.prototype.enableCombing = function () { if (this.getMaxLength() === void 0) { var n = "PDFTextFields must have a max length in order to be combed"; console.warn(n) } this.markAsDirty(), this.disableMultiline(), this.disablePassword(), this.disableFileSelection(), this.acroField.setFlagTo(Nt.Comb, !0) }, e.prototype.disableCombing = function () { this.markAsDirty(), this.acroField.setFlagTo(Nt.Comb, !1) }, e.prototype.isRichFormatted = function () { return this.acroField.hasFlag(Nt.RichText) }, e.prototype.enableRichFormatting = function () { this.acroField.setFlagTo(Nt.RichText, !0) }, e.prototype.disableRichFormatting = function () { this.acroField.setFlagTo(Nt.RichText, !1) }, e.prototype.addToPage = function (n, r) { var i, s, a, u, c, f, h; G(n, "page", [[kr, "PDFPage"]]), da(r), r || (r = {}), "textColor" in r || (r.textColor = St(0, 0, 0)), "backgroundColor" in r || (r.backgroundColor = St(1, 1, 1)), "borderColor" in r || (r.borderColor = St(0, 0, 0)), "borderWidth" in r || (r.borderWidth = 1); var v = this.createWidget({ x: (i = r.x) !== null && i !== void 0 ? i : 0, y: (s = r.y) !== null && s !== void 0 ? s : 0, width: (a = r.width) !== null && a !== void 0 ? a : 200, height: (u = r.height) !== null && u !== void 0 ? u : 50, textColor: r.textColor, backgroundColor: r.backgroundColor, borderColor: r.borderColor, borderWidth: (c = r.borderWidth) !== null && c !== void 0 ? c : 0, rotate: (f = r.rotate) !== null && f !== void 0 ? f : Ge(0), hidden: r.hidden, page: n.ref }), m = this.doc.context.register(v.dict); this.acroField.addWidget(m); var g = (h = r.font) !== null && h !== void 0 ? h : this.doc.getForm().getDefaultFont(); this.updateWidgetAppearance(v, g), n.node.addAnnot(m) }, e.prototype.needsAppearancesUpdate = function () { var n; if (this.isDirty()) return !0; for (var r = this.acroField.getWidgets(), i = 0, s = r.length; i < s; i++) { var a = r[i], u = ((n = a.getAppearances()) === null || n === void 0 ? void 0 : n.normal) instanceof or; if (!u) return !0 } return !1 }, e.prototype.defaultUpdateAppearances = function (n) { G(n, "font", [[lr, "PDFFont"]]), this.updateAppearances(n) }, e.prototype.updateAppearances = function (n, r) { G(n, "font", [[lr, "PDFFont"]]), xe(r, "provider", [Function]); for (var i = this.acroField.getWidgets(), s = 0, a = i.length; s < a; s++) { var u = i[s]; this.updateWidgetAppearance(u, n, r) } this.markAsClean() }, e.prototype.updateWidgetAppearance = function (n, r, i) { var s = i ?? X5, a = fa(s(this, n, r)); this.updateWidgetAppearanceWithFont(n, r, a) }, e.of = function (n, r, i) { return new e(n, r, i) }, e }(os), Sf; (function (t) { t.Courier = "Courier", t.CourierBold = "Courier-Bold", t.CourierOblique = "Courier-Oblique", t.CourierBoldOblique = "Courier-BoldOblique", t.Helvetica = "Helvetica", t.HelveticaBold = "Helvetica-Bold", t.HelveticaOblique = "Helvetica-Oblique", t.HelveticaBoldOblique = "Helvetica-BoldOblique", t.TimesRoman = "Times-Roman", t.TimesRomanBold = "Times-Bold", t.TimesRomanItalic = "Times-Italic", t.TimesRomanBoldItalic = "Times-BoldItalic", t.Symbol = "Symbol", t.ZapfDingbats = "ZapfDingbats" })(Sf || (Sf = {})); var Q5 = function () { function t(e, n) { var r = this; this.embedDefaultFont = function () { return r.doc.embedStandardFont(Sf.Helvetica) }, G(e, "acroForm", [[vf, "PDFAcroForm"]]), G(n, "doc", [[_o, "PDFDocument"]]), this.acroForm = e, this.doc = n, this.dirtyFields = new Set, this.defaultFontCache = ki.populatedBy(this.embedDefaultFont) } return t.prototype.hasXFA = function () { return this.acroForm.dict.has(O.of("XFA")) }, t.prototype.deleteXFA = function () { this.acroForm.dict.delete(O.of("XFA")) }, t.prototype.getFields = function () { for (var e = this.acroForm.getAllFields(), n = [], r = 0, i = e.length; r < i; r++) { var s = e[r], a = s[0], u = s[1], c = J5(a, u, this.doc); c && n.push(c) } return n }, t.prototype.getFieldMaybe = function (e) { G(e, "name", ["string"]); for (var n = this.getFields(), r = 0, i = n.length; r < i; r++) { var s = n[r]; if (s.getName() === e) return s } }, t.prototype.getField = function (e) { G(e, "name", ["string"]); var n = this.getFieldMaybe(e); if (n) return n; throw new O5(e) }, t.prototype.getButton = function (e) { G(e, "name", ["string"]); var n = this.getField(e); if (n instanceof Zc) return n; throw new zo(e, Zc, n) }, t.prototype.getCheckBox = function (e) { G(e, "name", ["string"]); var n = this.getField(e); if (n instanceof pl) return n; throw new zo(e, pl, n) }, t.prototype.getDropdown = function (e) { G(e, "name", ["string"]); var n = this.getField(e); if (n instanceof qc) return n; throw new zo(e, qc, n) }, t.prototype.getOptionList = function (e) { G(e, "name", ["string"]); var n = this.getField(e); if (n instanceof Gc) return n; throw new zo(e, Gc, n) }, t.prototype.getRadioGroup = function (e) { G(e, "name", ["string"]); var n = this.getField(e); if (n instanceof vl) return n; throw new zo(e, vl, n) }, t.prototype.getSignature = function (e) { G(e, "name", ["string"]); var n = this.getField(e); if (n instanceof w0) return n; throw new zo(e, w0, n) }, t.prototype.getTextField = function (e) { G(e, "name", ["string"]); var n = this.getField(e); if (n instanceof Xc) return n; throw new zo(e, Xc, n) }, t.prototype.createButton = function (e) { G(e, "name", ["string"]); var n = Ns(e), r = this.findOrCreateNonTerminals(n.nonTerminal), i = Gf.create(this.doc.context); return i.setPartialName(n.terminal), Bs(r, [i, i.ref], n.terminal), Zc.of(i, i.ref, this.doc) }, t.prototype.createCheckBox = function (e) { G(e, "name", ["string"]); var n = Ns(e), r = this.findOrCreateNonTerminals(n.nonTerminal), i = Kf.create(this.doc.context); return i.setPartialName(n.terminal), Bs(r, [i, i.ref], n.terminal), pl.of(i, i.ref, this.doc) }, t.prototype.createDropdown = function (e) { G(e, "name", ["string"]); var n = Ns(e), r = this.findOrCreateNonTerminals(n.nonTerminal), i = Hf.create(this.doc.context); return i.setPartialName(n.terminal), Bs(r, [i, i.ref], n.terminal), qc.of(i, i.ref, this.doc) }, t.prototype.createOptionList = function (e) { G(e, "name", ["string"]); var n = Ns(e), r = this.findOrCreateNonTerminals(n.nonTerminal), i = Zf.create(this.doc.context); return i.setPartialName(n.terminal), Bs(r, [i, i.ref], n.terminal), Gc.of(i, i.ref, this.doc) }, t.prototype.createRadioGroup = function (e) { G(e, "name", ["string"]); var n = Ns(e), r = this.findOrCreateNonTerminals(n.nonTerminal), i = Xf.create(this.doc.context); return i.setPartialName(n.terminal), Bs(r, [i, i.ref], n.terminal), vl.of(i, i.ref, this.doc) }, t.prototype.createTextField = function (e) { G(e, "name", ["string"]); var n = Ns(e), r = this.findOrCreateNonTerminals(n.nonTerminal), i = qf.create(this.doc.context); return i.setPartialName(n.terminal), Bs(r, [i, i.ref], n.terminal), Xc.of(i, i.ref, this.doc) }, t.prototype.flatten = function (e) { e === void 0 && (e = { updateFieldAppearances: !0 }), e.updateFieldAppearances && this.updateFieldAppearances(); for (var n = this.getFields(), r = 0, i = n.length; r < i; r++) { for (var s = n[r], a = s.acroField.getWidgets(), u = 0, c = a.length; u < c; u++) { var f = a[u], h = this.findWidgetPage(f), v = this.findWidgetAppearanceRef(s, f), m = h.node.newXObject("FlatWidget", v), g = f.getRectangle(), S = ft([an(), Er(g.x, g.y)], Co(_e(_e({}, g), { rotation: 0 })), [Xv(m), ln()]).filter(Boolean); h.pushOperators.apply(h, S) } this.removeField(s) } }, t.prototype.removeField = function (e) { for (var n = e.acroField.getWidgets(), r = new Set, i = 0, s = n.length; i < s; i++) { var a = n[i], u = this.findWidgetAppearanceRef(e, a), c = this.findWidgetPage(a); r.add(c), c.node.removeAnnot(u) } r.forEach(function (g) { return g.node.removeAnnot(e.ref) }), this.acroForm.removeField(e.acroField); for (var f = e.acroField.normalizedEntries().Kids, h = f.size(), v = 0; v < h; v++) { var m = f.get(v); m instanceof wt && this.doc.context.delete(m) } this.doc.context.delete(e.ref) }, t.prototype.updateFieldAppearances = function (e) { xe(e, "font", [[lr, "PDFFont"]]), e = e ?? this.getDefaultFont(); for (var n = this.getFields(), r = 0, i = n.length; r < i; r++) { var s = n[r]; s.needsAppearancesUpdate() && s.defaultUpdateAppearances(e) } }, t.prototype.markFieldAsDirty = function (e) { xe(e, "fieldRef", [[wt, "PDFRef"]]), this.dirtyFields.add(e) }, t.prototype.markFieldAsClean = function (e) { xe(e, "fieldRef", [[wt, "PDFRef"]]), this.dirtyFields.delete(e) }, t.prototype.fieldIsDirty = function (e) { return xe(e, "fieldRef", [[wt, "PDFRef"]]), this.dirtyFields.has(e) }, t.prototype.getDefaultFont = function () { return this.defaultFontCache.access() }, t.prototype.findWidgetPage = function (e) { var n = e.P(), r = this.doc.getPages().find(function (s) { return s.ref === n }); if (r === void 0) { var i = this.doc.context.getObjectRef(e.dict); if (i === void 0) throw new Error("Could not find PDFRef for PDFObject"); if (r = this.doc.findPageForAnnotationRef(i), r === void 0) throw new Error("Could not find page for PDFRef " + i) } return r }, t.prototype.findWidgetAppearanceRef = function (e, n) { var r, i = n.getNormalAppearance(); if (i instanceof et && (e instanceof pl || e instanceof vl)) { var s = e.acroField.getValue(), a = (r = i.get(s)) !== null && r !== void 0 ? r : i.get(O.of("Off")); a instanceof wt && (i = a) } if (!(i instanceof wt)) { var u = e.getName(); throw new Error("Failed to extract appearance ref for: " + u) } return i }, t.prototype.findOrCreateNonTerminals = function (e) { for (var n = [this.acroForm], r = 0, i = e.length; r < i; r++) { var s = e[r]; if (!s) throw new M5(s); var a = n[0], u = n[1], c = this.findNonTerminal(s, a); if (c) n = c; else { var f = pf.create(this.doc.context); f.setPartialName(s), f.setParent(u); var h = this.doc.context.register(f.dict); a.addField(h), n = [f, h] } } return n }, t.prototype.findNonTerminal = function (e, n) { for (var r = n instanceof vf ? this.acroForm.getFields() : zv(n.Kids()), i = 0, s = r.length; i < s; i++) { var a = r[i], u = a[0], c = a[1]; if (u.getPartialName() === e) { if (u instanceof pf) return [u, c]; throw new ZP(e) } } }, t.of = function (e, n) { return new t(e, n) }, t }(), J5 = function (t, e, n) { if (t instanceof Gf) return Zc.of(t, e, n); if (t instanceof Kf) return pl.of(t, e, n); if (t instanceof Hf) return qc.of(t, e, n); if (t instanceof Zf) return Gc.of(t, e, n); if (t instanceof qf) return Xc.of(t, e, n); if (t instanceof Xf) return vl.of(t, e, n); if (t instanceof Iv) return w0.of(t, e, n) }, Ns = function (t) { if (t.length === 0) throw new Error("PDF field names must not be empty strings"); for (var e = t.split("."), n = 0, r = e.length; n < r; n++)if (e[n] === "") throw new Error('Periods in PDF field names must be separated by at least one character: "' + t + '"'); return e.length === 1 ? { nonTerminal: [], terminal: e[0] } : { nonTerminal: e.slice(0, e.length - 1), terminal: e[e.length - 1] } }, Bs = function (t, e, n) { for (var r = t[0], i = t[1], s = e[0], a = e[1], u = r.normalizedEntries(), c = zv("Kids" in u ? u.Kids : u.Fields), f = 0, h = c.length; f < h; f++)if (c[f][0].getPartialName() === n) throw new ZP(n); r.addField(a), s.setParent(i) }, _5 = { "4A0": [4767.87, 6740.79], "2A0": [3370.39, 4767.87], A0: [2383.94, 3370.39], A1: [1683.78, 2383.94], A2: [1190.55, 1683.78], A3: [841.89, 1190.55], A4: [595.28, 841.89], A5: [419.53, 595.28], A6: [297.64, 419.53], A7: [209.76, 297.64], A8: [147.4, 209.76], A9: [104.88, 147.4], A10: [73.7, 104.88], B0: [2834.65, 4008.19], B1: [2004.09, 2834.65], B2: [1417.32, 2004.09], B3: [1000.63, 1417.32], B4: [708.66, 1000.63], B5: [498.9, 708.66], B6: [354.33, 498.9], B7: [249.45, 354.33], B8: [175.75, 249.45], B9: [124.72, 175.75], B10: [87.87, 124.72], C0: [2599.37, 3676.54], C1: [1836.85, 2599.37], C2: [1298.27, 1836.85], C3: [918.43, 1298.27], C4: [649.13, 918.43], C5: [459.21, 649.13], C6: [323.15, 459.21], C7: [229.61, 323.15], C8: [161.57, 229.61], C9: [113.39, 161.57], C10: [79.37, 113.39], RA0: [2437.8, 3458.27], RA1: [1729.13, 2437.8], RA2: [1218.9, 1729.13], RA3: [864.57, 1218.9], RA4: [609.45, 864.57], SRA0: [2551.18, 3628.35], SRA1: [1814.17, 2551.18], SRA2: [1275.59, 1814.17], SRA3: [907.09, 1275.59], SRA4: [637.8, 907.09], Executive: [521.86, 756], Folio: [612, 936], Legal: [612, 1008], Letter: [612, 792], Tabloid: [792, 1224] }, S0; (function (t) { t[t.Fastest = 1 / 0] = "Fastest", t[t.Fast = 1500] = "Fast", t[t.Medium = 500] = "Medium", t[t.Slow = 100] = "Slow" })(S0 || (S0 = {})); var $5 = function () { function t(e, n, r) { this.alreadyEmbedded = !1, this.ref = e, this.doc = n, this.embedder = r } return t.prototype.embed = function () { return tt(this, void 0, void 0, function () { var e, n, r, i, s; return nt(this, function (a) { switch (a.label) { case 0: return this.alreadyEmbedded ? [3, 2] : [4, this.embedder.embedIntoContext(this.doc.context, this.ref)]; case 1: e = a.sent(), this.doc.catalog.has(O.of("Names")) || this.doc.catalog.set(O.of("Names"), this.doc.context.obj({})), n = this.doc.catalog.lookup(O.of("Names"), et), n.has(O.of("EmbeddedFiles")) || n.set(O.of("EmbeddedFiles"), this.doc.context.obj({})), r = n.lookup(O.of("EmbeddedFiles"), et), r.has(O.of("Names")) || r.set(O.of("Names"), this.doc.context.obj([])), i = r.lookup(O.of("Names"), mt), i.push(qe.fromText(this.embedder.fileName)), i.push(e), this.doc.catalog.has(O.of("AF")) || this.doc.catalog.set(O.of("AF"), this.doc.context.obj([])), s = this.doc.catalog.lookup(O.of("AF"), mt), s.push(e), this.alreadyEmbedded = !0, a.label = 2; case 2: return [2] } }) }) }, t.of = function (e, n, r) { return new t(e, n, r) }, t }(), eV = function () { function t(e, n, r) { this.alreadyEmbedded = !1, this.ref = e, this.doc = n, this.embedder = r } return t.prototype.embed = function () { return tt(this, void 0, void 0, function () { var e, n, r, i, s, a, u; return nt(this, function (c) { switch (c.label) { case 0: return this.alreadyEmbedded ? [3, 2] : (e = this.doc, n = e.catalog, r = e.context, [4, this.embedder.embedIntoContext(this.doc.context, this.ref)]); case 1: i = c.sent(), n.has(O.of("Names")) || n.set(O.of("Names"), r.obj({})), s = n.lookup(O.of("Names"), et), s.has(O.of("JavaScript")) || s.set(O.of("JavaScript"), r.obj({})), a = s.lookup(O.of("JavaScript"), et), a.has(O.of("Names")) || a.set(O.of("Names"), r.obj([])), u = a.lookup(O.of("Names"), mt), u.push(qe.fromText(this.embedder.scriptName)), u.push(i), this.alreadyEmbedded = !0, c.label = 2; case 2: return [2] } }) }) }, t.of = function (e, n, r) { return new t(e, n, r) }, t }(), tV = function () { function t(e, n) { this.script = e, this.scriptName = n } return t.for = function (e, n) { return new t(e, n) }, t.prototype.embedIntoContext = function (e, n) { return tt(this, void 0, void 0, function () { var r; return nt(this, function (i) { return r = e.obj({ Type: "Action", S: "JavaScript", JS: qe.fromText(this.script) }), n ? (e.assign(n, r), [2, n]) : [2, e.register(r)] }) }) }, t }(), _o = function () { function t(e, n, r) { var i = this; if (this.defaultWordBreaks = [" "], this.computePages = function () { var s = []; return i.catalog.Pages().traverse(function (a, u) { if (a instanceof Ai) { var c = i.pageMap.get(a); c || (c = kr.of(a, u, i), i.pageMap.set(a, c)), s.push(c) } }), s }, this.getOrCreateForm = function () { var s = i.catalog.getOrCreateAcroForm(); return Q5.of(s, i) }, G(e, "context", [[p0, "PDFContext"]]), G(n, "ignoreEncryption", ["boolean"]), this.context = e, this.catalog = e.lookup(e.trailerInfo.Root), this.isEncrypted = !!e.lookup(e.trailerInfo.Encrypt), this.pageCache = ki.populatedBy(this.computePages), this.pageMap = new Map, this.formCache = ki.populatedBy(this.getOrCreateForm), this.fonts = [], this.images = [], this.embeddedPages = [], this.embeddedFiles = [], this.javaScripts = [], !n && this.isEncrypted) throw new E5; r && this.updateInfoDict() } return t.load = function (e, n) { return n === void 0 && (n = {}), tt(this, void 0, void 0, function () { var r, i, s, a, u, c, f, h, v, m, g, S; return nt(this, function (b) { switch (b.label) { case 0: return r = n.ignoreEncryption, i = r === void 0 ? !1 : r, s = n.parseSpeed, a = s === void 0 ? S0.Slow : s, u = n.throwOnInvalidObject, c = u === void 0 ? !1 : u, f = n.updateMetadata, h = f === void 0 ? !0 : f, v = n.capNumbers, m = v === void 0 ? !1 : v, G(e, "pdf", ["string", Uint8Array, ArrayBuffer]), G(i, "ignoreEncryption", ["boolean"]), G(a, "parseSpeed", ["number"]), G(c, "throwOnInvalidObject", ["boolean"]), g = _a(e), [4, r5.forBytesWithOptions(g, a, c, m).parseDocument()]; case 1: return S = b.sent(), [2, new t(S, i, h)] } }) }) }, t.create = function (e) { return e === void 0 && (e = {}), tt(this, void 0, void 0, function () { var n, r, i, s, a, u; return nt(this, function (c) { return n = e.updateMetadata, r = n === void 0 ? !0 : n, i = p0.create(), s = RP.withContext(i), a = i.register(s), u = FP.withContextAndPages(i, a), i.trailerInfo.Root = i.register(u), [2, new t(i, !1, r)] }) }) }, t.prototype.registerFontkit = function (e) { this.fontkit = e }, t.prototype.getForm = function () { var e = this.formCache.access(); return e.hasXFA() && (console.warn("Removing XFA form data as pdf-lib does not support reading or writing XFA"), e.deleteXFA()), e }, t.prototype.getTitle = function () { var e = this.getInfoDict().lookup(O.Title); if (e) return no(e), e.decodeText() }, t.prototype.getAuthor = function () { var e = this.getInfoDict().lookup(O.Author); if (e) return no(e), e.decodeText() }, t.prototype.getSubject = function () { var e = this.getInfoDict().lookup(O.Subject); if (e) return no(e), e.decodeText() }, t.prototype.getKeywords = function () { var e = this.getInfoDict().lookup(O.Keywords); if (e) return no(e), e.decodeText() }, t.prototype.getCreator = function () { var e = this.getInfoDict().lookup(O.Creator); if (e) return no(e), e.decodeText() }, t.prototype.getProducer = function () { var e = this.getInfoDict().lookup(O.Producer); if (e) return no(e), e.decodeText() }, t.prototype.getCreationDate = function () { var e = this.getInfoDict().lookup(O.CreationDate); if (e) return no(e), e.decodeDate() }, t.prototype.getModificationDate = function () { var e = this.getInfoDict().lookup(O.ModDate); if (e) return no(e), e.decodeDate() }, t.prototype.setTitle = function (e, n) { G(e, "title", ["string"]); var r = O.of("Title"); if (this.getInfoDict().set(r, qe.fromText(e)), n != null && n.showInWindowTitleBar) { var i = this.catalog.getOrCreateViewerPreferences(); i.setDisplayDocTitle(!0) } }, t.prototype.setAuthor = function (e) { G(e, "author", ["string"]); var n = O.of("Author"); this.getInfoDict().set(n, qe.fromText(e)) }, t.prototype.setSubject = function (e) { G(e, "author", ["string"]); var n = O.of("Subject"); this.getInfoDict().set(n, qe.fromText(e)) }, t.prototype.setKeywords = function (e) { G(e, "keywords", [Array]); var n = O.of("Keywords"); this.getInfoDict().set(n, qe.fromText(e.join(" "))) }, t.prototype.setCreator = function (e) { G(e, "creator", ["string"]); var n = O.of("Creator"); this.getInfoDict().set(n, qe.fromText(e)) }, t.prototype.setProducer = function (e) { G(e, "creator", ["string"]); var n = O.of("Producer"); this.getInfoDict().set(n, qe.fromText(e)) }, t.prototype.setLanguage = function (e) { G(e, "language", ["string"]); var n = O.of("Lang"); this.catalog.set(n, xt.of(e)) }, t.prototype.setCreationDate = function (e) { G(e, "creationDate", [[Date, "Date"]]); var n = O.of("CreationDate"); this.getInfoDict().set(n, xt.fromDate(e)) }, t.prototype.setModificationDate = function (e) { G(e, "modificationDate", [[Date, "Date"]]); var n = O.of("ModDate"); this.getInfoDict().set(n, xt.fromDate(e)) }, t.prototype.getPageCount = function () { return this.pageCount === void 0 && (this.pageCount = this.getPages().length), this.pageCount }, t.prototype.getPages = function () { return this.pageCache.access() }, t.prototype.getPage = function (e) { var n = this.getPages(); return nr(e, "index", 0, n.length - 1), n[e] }, t.prototype.getPageIndices = function () { return iM(0, this.getPageCount()) }, t.prototype.removePage = function (e) { var n = this.getPageCount(); if (this.pageCount === 0) throw new D5; nr(e, "index", 0, n - 1), this.catalog.removeLeafNode(e), this.pageCount = n - 1 }, t.prototype.addPage = function (e) { return G(e, "page", ["undefined", [kr, "PDFPage"], Array]), this.insertPage(this.getPageCount(), e) }, t.prototype.insertPage = function (e, n) { var r = this.getPageCount(); if (nr(e, "index", 0, r), G(n, "page", ["undefined", [kr, "PDFPage"], Array]), !n || Array.isArray(n)) { var i = Array.isArray(n) ? n : _5.A4; n = kr.create(this), n.setSize.apply(n, i) } else if (n.doc !== this) throw new R5; var s = this.catalog.insertLeafNode(n.ref, e); return n.node.setParent(s), this.pageMap.set(n.node, n), this.pageCache.invalidate(), this.pageCount = r + 1, n }, t.prototype.copyPages = function (e, n) { return tt(this, void 0, void 0, function () { var r, i, s, a, u, c, f, h; return nt(this, function (v) { switch (v.label) { case 0: return G(e, "srcDoc", [[t, "PDFDocument"]]), G(n, "indices", [Array]), [4, e.flush()]; case 1: for (v.sent(), r = xw.for(e.context, this.context), i = e.getPages(), s = new Array(n.length), a = 0, u = n.length; a < u; a++)c = i[n[a]], f = r.copy(c.node), h = this.context.register(f), s[a] = kr.of(f, h, this); return [2, s] } }) }) }, t.prototype.copy = function () { return tt(this, void 0, void 0, function () { var e, n, r, i; return nt(this, function (s) { switch (s.label) { case 0: return [4, t.create()]; case 1: return e = s.sent(), [4, e.copyPages(this, this.getPageIndices())]; case 2: for (n = s.sent(), r = 0, i = n.length; r < i; r++)e.addPage(n[r]); return this.getAuthor() !== void 0 && e.setAuthor(this.getAuthor()), this.getCreationDate() !== void 0 && e.setCreationDate(this.getCreationDate()), this.getCreator() !== void 0 && e.setCreator(this.getCreator()), this.getModificationDate() !== void 0 && e.setModificationDate(this.getModificationDate()), this.getProducer() !== void 0 && e.setProducer(this.getProducer()), this.getSubject() !== void 0 && e.setSubject(this.getSubject()), this.getTitle() !== void 0 && e.setTitle(this.getTitle()), e.defaultWordBreaks = this.defaultWordBreaks, [2, e] } }) }) }, t.prototype.addJavaScript = function (e, n) { G(e, "name", ["string"]), G(n, "script", ["string"]); var r = tV.for(n, e), i = this.context.nextRef(), s = eV.of(i, this, r); this.javaScripts.push(s) }, t.prototype.attach = function (e, n, r) { return r === void 0 && (r = {}), tt(this, void 0, void 0, function () { var i, s, a, u; return nt(this, function (c) { return G(e, "attachment", ["string", Uint8Array, ArrayBuffer]), G(n, "name", ["string"]), xe(r.mimeType, "mimeType", ["string"]), xe(r.description, "description", ["string"]), xe(r.creationDate, "options.creationDate", [Date]), xe(r.modificationDate, "options.modificationDate", [Date]), br(r.afRelationship, "options.afRelationship", v0), i = _a(e), s = F3.for(i, n, r), a = this.context.nextRef(), u = $5.of(a, this, s), this.embeddedFiles.push(u), [2] }) }) }, t.prototype.embedFont = function (e, n) { return n === void 0 && (n = {}), tt(this, void 0, void 0, function () { var r, i, s, a, u, c, f, h, v, m; return nt(this, function (g) { switch (g.label) { case 0: return r = n.subset, i = r === void 0 ? !1 : r, s = n.customName, a = n.features, G(e, "font", ["string", Uint8Array, ArrayBuffer]), G(i, "subset", ["boolean"]), cw(e) ? (u = df.for(e, s), [3, 7]) : [3, 1]; case 1: return sM(e) ? (c = _a(e), f = this.assertFontkit(), i ? [4, E3.for(f, c, s, a)] : [3, 3]) : [3, 6]; case 2: return h = g.sent(), [3, 5]; case 3: return [4, Lv.for(f, c, s, a)]; case 4: h = g.sent(), g.label = 5; case 5: return u = h, [3, 7]; case 6: throw new TypeError("`font` must be one of `StandardFonts | string | Uint8Array | ArrayBuffer`"); case 7: return v = this.context.nextRef(), m = lr.of(v, this, u), this.fonts.push(m), [2, m] } }) }) }, t.prototype.embedStandardFont = function (e, n) { if (G(e, "font", ["string"]), !cw(e)) throw new TypeError("`font` must be one of type `StandardFonts`"); var r = df.for(e, n), i = this.context.nextRef(), s = lr.of(i, this, r); return this.fonts.push(s), s }, t.prototype.embedJpg = function (e) { return tt(this, void 0, void 0, function () { var n, r, i, s; return nt(this, function (a) { switch (a.label) { case 0: return G(e, "jpg", ["string", Uint8Array, ArrayBuffer]), n = _a(e), [4, wP.for(n)]; case 1: return r = a.sent(), i = this.context.nextRef(), s = x0.of(i, this, r), this.images.push(s), [2, s] } }) }) }, t.prototype.embedPng = function (e) { return tt(this, void 0, void 0, function () { var n, r, i, s; return nt(this, function (a) { switch (a.label) { case 0: return G(e, "png", ["string", Uint8Array, ArrayBuffer]), n = _a(e), [4, SP.for(n)]; case 1: return r = a.sent(), i = this.context.nextRef(), s = x0.of(i, this, r), this.images.push(s), [2, s] } }) }) }, t.prototype.embedPdf = function (e, n) { return n === void 0 && (n = [0]), tt(this, void 0, void 0, function () { var r, i, s; return nt(this, function (a) { switch (a.label) { case 0: return G(e, "pdf", ["string", Uint8Array, ArrayBuffer, [t, "PDFDocument"]]), G(n, "indices", [Array]), e instanceof t ? (i = e, [3, 3]) : [3, 1]; case 1: return [4, t.load(e)]; case 2: i = a.sent(), a.label = 3; case 3: return r = i, s = oM(r.getPages(), n), [2, this.embedPages(s)] } }) }) }, t.prototype.embedPage = function (e, n, r) { return tt(this, void 0, void 0, function () { var i; return nt(this, function (s) { switch (s.label) { case 0: return G(e, "page", [[kr, "PDFPage"]]), [4, this.embedPages([e], [n], [r])]; case 1: return i = s.sent()[0], [2, i] } }) }) }, t.prototype.embedPages = function (e, n, r) { return n === void 0 && (n = []), r === void 0 && (r = []), tt(this, void 0, void 0, function () { var f, h, i, s, a, u, c, f, h, v, m, g, S, b, P; return nt(this, function (C) { switch (C.label) { case 0: if (e.length === 0) return [2, []]; for (f = 0, h = e.length - 1; f < h; f++)if (i = e[f], s = e[f + 1], i.node.context !== s.node.context) throw new t3; a = e[0].node.context, u = a === this.context ? function (F) { return F } : xw.for(a, this.context).copy, c = new Array(e.length), f = 0, h = e.length, C.label = 1; case 1: return f < h ? (v = u(e[f].node), m = n[f], g = r[f], [4, PP.for(v, m, g)]) : [3, 4]; case 2: S = C.sent(), b = this.context.nextRef(), c[f] = $P.of(b, this, S), C.label = 3; case 3: return f++, [3, 1]; case 4: return (P = this.embeddedPages).push.apply(P, c), [2, c] } }) }) }, t.prototype.flush = function () { return tt(this, void 0, void 0, function () { return nt(this, function (e) { switch (e.label) { case 0: return [4, this.embedAll(this.fonts)]; case 1: return e.sent(), [4, this.embedAll(this.images)]; case 2: return e.sent(), [4, this.embedAll(this.embeddedPages)]; case 3: return e.sent(), [4, this.embedAll(this.embeddedFiles)]; case 4: return e.sent(), [4, this.embedAll(this.javaScripts)]; case 5: return e.sent(), [2] } }) }) }, t.prototype.save = function (e) { return e === void 0 && (e = {}), tt(this, void 0, void 0, function () { var n, r, i, s, a, u, c, f, h, v; return nt(this, function (m) { switch (m.label) { case 0: return n = e.useObjectStreams, r = n === void 0 ? !0 : n, i = e.addDefaultPage, s = i === void 0 ? !0 : i, a = e.objectsPerTick, u = a === void 0 ? 50 : a, c = e.updateFieldAppearances, f = c === void 0 ? !0 : c, G(r, "useObjectStreams", ["boolean"]), G(s, "addDefaultPage", ["boolean"]), G(u, "objectsPerTick", ["number"]), G(f, "updateFieldAppearances", ["boolean"]), s && this.getPageCount() === 0 && this.addPage(), f && (h = this.formCache.getValue(), h && h.updateFieldAppearances()), [4, this.flush()]; case 1: return m.sent(), v = r ? b3 : yP, [2, v.forContext(this.context, u).serializeToBuffer()] } }) }) }, t.prototype.saveAsBase64 = function (e) { return e === void 0 && (e = {}), tt(this, void 0, void 0, function () { var n, r, i, s, a; return nt(this, function (u) { switch (u.label) { case 0: return n = e.dataUri, r = n === void 0 ? !1 : n, i = UO(e, ["dataUri"]), G(r, "dataUri", ["boolean"]), [4, this.save(i)]; case 1: return s = u.sent(), a = WO(s), [2, r ? "data:application/pdf;base64," + a : a] } }) }) }, t.prototype.findPageForAnnotationRef = function (e) { for (var n = this.getPages(), r = 0, i = n.length; r < i; r++) { var s = n[r], a = s.node.Annots(); if ((a == null ? void 0 : a.indexOf(e)) !== void 0) return s } }, t.prototype.embedAll = function (e) { return tt(this, void 0, void 0, function () { var n, r; return nt(this, function (i) { switch (i.label) { case 0: n = 0, r = e.length, i.label = 1; case 1: return n < r ? [4, e[n].embed()] : [3, 4]; case 2: i.sent(), i.label = 3; case 3: return n++, [3, 1]; case 4: return [2] } }) }) }, t.prototype.updateInfoDict = function () { var e = "pdf-lib (https://github.com/Hopding/pdf-lib)", n = new Date, r = this.getInfoDict(); this.setProducer(e), this.setModificationDate(n), r.get(O.of("Creator")) || this.setCreator(e), r.get(O.of("CreationDate")) || this.setCreationDate(n) }, t.prototype.getInfoDict = function () { var e = this.context.lookup(this.context.trailerInfo.Info); if (e instanceof et) return e; var n = this.context.obj({}); return this.context.trailerInfo.Info = this.context.register(n), n }, t.prototype.assertFontkit = function () { if (!this.fontkit) throw new F5; return this.fontkit }, t }(); function no(t) { if (!(t instanceof qe) && !(t instanceof xt)) throw new cf([qe, xt], t) } var Si; (function (t) { t.Normal = "Normal", t.Multiply = "Multiply", t.Screen = "Screen", t.Overlay = "Overlay", t.Darken = "Darken", t.Lighten = "Lighten", t.ColorDodge = "ColorDodge", t.ColorBurn = "ColorBurn", t.HardLight = "HardLight", t.SoftLight = "SoftLight", t.Difference = "Difference", t.Exclusion = "Exclusion" })(Si || (Si = {})); var kr = function () { function t(e, n, r) { this.fontSize = 24, this.fontColor = St(0, 0, 0), this.lineHeight = 24, this.x = 0, this.y = 0, G(e, "leafNode", [[Ai, "PDFPageLeaf"]]), G(n, "ref", [[wt, "PDFRef"]]), G(r, "doc", [[_o, "PDFDocument"]]), this.node = e, this.ref = n, this.doc = r } return t.prototype.setRotation = function (e) { var n = NP(e); hP(n, "degreesAngle", 90), this.node.set(O.of("Rotate"), this.doc.context.obj(n)) }, t.prototype.getRotation = function () { var e = this.node.Rotate(); return Ge(e ? e.asNumber() : 0) }, t.prototype.setSize = function (e, n) { G(e, "width", ["number"]), G(n, "height", ["number"]); var r = this.getMediaBox(); this.setMediaBox(r.x, r.y, e, n); var i = this.getCropBox(), s = this.getBleedBox(), a = this.getTrimBox(), u = this.getArtBox(), c = this.node.CropBox(), f = this.node.BleedBox(), h = this.node.TrimBox(), v = this.node.ArtBox(); c && Ac(i, r) && this.setCropBox(r.x, r.y, e, n), f && Ac(s, r) && this.setBleedBox(r.x, r.y, e, n), h && Ac(a, r) && this.setTrimBox(r.x, r.y, e, n), v && Ac(u, r) && this.setArtBox(r.x, r.y, e, n) }, t.prototype.setWidth = function (e) { G(e, "width", ["number"]), this.setSize(e, this.getSize().height) }, t.prototype.setHeight = function (e) { G(e, "height", ["number"]), this.setSize(this.getSize().width, e) }, t.prototype.setMediaBox = function (e, n, r, i) { G(e, "x", ["number"]), G(n, "y", ["number"]), G(r, "width", ["number"]), G(i, "height", ["number"]); var s = this.doc.context.obj([e, n, e + r, n + i]); this.node.set(O.MediaBox, s) }, t.prototype.setCropBox = function (e, n, r, i) { G(e, "x", ["number"]), G(n, "y", ["number"]), G(r, "width", ["number"]), G(i, "height", ["number"]); var s = this.doc.context.obj([e, n, e + r, n + i]); this.node.set(O.CropBox, s) }, t.prototype.setBleedBox = function (e, n, r, i) { G(e, "x", ["number"]), G(n, "y", ["number"]), G(r, "width", ["number"]), G(i, "height", ["number"]); var s = this.doc.context.obj([e, n, e + r, n + i]); this.node.set(O.BleedBox, s) }, t.prototype.setTrimBox = function (e, n, r, i) { G(e, "x", ["number"]), G(n, "y", ["number"]), G(r, "width", ["number"]), G(i, "height", ["number"]); var s = this.doc.context.obj([e, n, e + r, n + i]); this.node.set(O.TrimBox, s) }, t.prototype.setArtBox = function (e, n, r, i) { G(e, "x", ["number"]), G(n, "y", ["number"]), G(r, "width", ["number"]), G(i, "height", ["number"]); var s = this.doc.context.obj([e, n, e + r, n + i]); this.node.set(O.ArtBox, s) }, t.prototype.getSize = function () { var e = this.getMediaBox(), n = e.width, r = e.height; return { width: n, height: r } }, t.prototype.getWidth = function () { return this.getSize().width }, t.prototype.getHeight = function () { return this.getSize().height }, t.prototype.getMediaBox = function () { var e = this.node.MediaBox(); return e.asRectangle() }, t.prototype.getCropBox = function () { var e, n = this.node.CropBox(); return (e = n == null ? void 0 : n.asRectangle()) !== null && e !== void 0 ? e : this.getMediaBox() }, t.prototype.getBleedBox = function () { var e, n = this.node.BleedBox(); return (e = n == null ? void 0 : n.asRectangle()) !== null && e !== void 0 ? e : this.getCropBox() }, t.prototype.getTrimBox = function () { var e, n = this.node.TrimBox(); return (e = n == null ? void 0 : n.asRectangle()) !== null && e !== void 0 ? e : this.getCropBox() }, t.prototype.getArtBox = function () { var e, n = this.node.ArtBox(); return (e = n == null ? void 0 : n.asRectangle()) !== null && e !== void 0 ? e : this.getCropBox() }, t.prototype.translateContent = function (e, n) { G(e, "x", ["number"]), G(n, "y", ["number"]), this.node.normalize(), this.getContentStream(); var r = this.createContentStream(an(), Er(e, n)), i = this.doc.context.register(r), s = this.createContentStream(ln()), a = this.doc.context.register(s); this.node.wrapContentStreams(i, a) }, t.prototype.scale = function (e, n) { G(e, "x", ["number"]), G(n, "y", ["number"]), this.setSize(this.getWidth() * e, this.getHeight() * n), this.scaleContent(e, n), this.scaleAnnotations(e, n) }, t.prototype.scaleContent = function (e, n) { G(e, "x", ["number"]), G(n, "y", ["number"]), this.node.normalize(), this.getContentStream(); var r = this.createContentStream(an(), Kl(e, n)), i = this.doc.context.register(r), s = this.createContentStream(ln()), a = this.doc.context.register(s); this.node.wrapContentStreams(i, a) }, t.prototype.scaleAnnotations = function (e, n) { G(e, "x", ["number"]), G(n, "y", ["number"]); var r = this.node.Annots(); if (r) for (var i = 0; i < r.size(); i++) { var s = r.lookup(i); s instanceof et && this.scaleAnnot(s, e, n) } }, t.prototype.resetPosition = function () { this.getContentStream(!1), this.x = 0, this.y = 0 }, t.prototype.setFont = function (e) { G(e, "font", [[lr, "PDFFont"]]), this.font = e, this.fontKey = this.node.newFontDictionary(this.font.name, this.font.ref) }, t.prototype.setFontSize = function (e) { G(e, "fontSize", ["number"]), this.fontSize = e }, t.prototype.setFontColor = function (e) { G(e, "fontColor", [[Object, "Color"]]), this.fontColor = e }, t.prototype.setLineHeight = function (e) { G(e, "lineHeight", ["number"]), this.lineHeight = e }, t.prototype.getPosition = function () { return { x: this.x, y: this.y } }, t.prototype.getX = function () { return this.x }, t.prototype.getY = function () { return this.y }, t.prototype.moveTo = function (e, n) { G(e, "x", ["number"]), G(n, "y", ["number"]), this.x = e, this.y = n }, t.prototype.moveDown = function (e) { G(e, "yDecrease", ["number"]), this.y -= e }, t.prototype.moveUp = function (e) { G(e, "yIncrease", ["number"]), this.y += e }, t.prototype.moveLeft = function (e) { G(e, "xDecrease", ["number"]), this.x -= e }, t.prototype.moveRight = function (e) { G(e, "xIncrease", ["number"]), this.x += e }, t.prototype.pushOperators = function () { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; dP(e, "operator", [[ct, "PDFOperator"]]); var r = this.getContentStream(); r.push.apply(r, e) }, t.prototype.drawText = function (e, n) { var r, i, s, a, u, c, f; n === void 0 && (n = {}), G(e, "text", ["string"]), xe(n.color, "options.color", [[Object, "Color"]]), Ur(n.opacity, "opacity.opacity", 0, 1), xe(n.font, "options.font", [[lr, "PDFFont"]]), xe(n.size, "options.size", ["number"]), xe(n.rotate, "options.rotate", [[Object, "Rotation"]]), xe(n.xSkew, "options.xSkew", [[Object, "Rotation"]]), xe(n.ySkew, "options.ySkew", [[Object, "Rotation"]]), xe(n.x, "options.x", ["number"]), xe(n.y, "options.y", ["number"]), xe(n.lineHeight, "options.lineHeight", ["number"]), xe(n.maxWidth, "options.maxWidth", ["number"]), xe(n.wordBreaks, "options.wordBreaks", [Array]), br(n.blendMode, "options.blendMode", Si); for (var h = this.setOrEmbedFont(n.font), v = h.oldFont, m = h.newFont, g = h.newFontKey, S = n.size || this.fontSize, b = n.wordBreaks || this.doc.defaultWordBreaks, P = function (B) { return m.widthOfTextAtSize(B, S) }, C = n.maxWidth === void 0 ? YC(ru(e)) : JO(e, b, n.maxWidth, P), F = new Array(C.length), A = 0, N = C.length; A < N; A++)F[A] = m.encodeText(C[A]); var D = this.maybeEmbedGraphicsState({ opacity: n.opacity, blendMode: n.blendMode }), V = this.getContentStream(); V.push.apply(V, w5(F, { color: (r = n.color) !== null && r !== void 0 ? r : this.fontColor, font: g, size: S, rotate: (i = n.rotate) !== null && i !== void 0 ? i : Ge(0), xSkew: (s = n.xSkew) !== null && s !== void 0 ? s : Ge(0), ySkew: (a = n.ySkew) !== null && a !== void 0 ? a : Ge(0), x: (u = n.x) !== null && u !== void 0 ? u : this.x, y: (c = n.y) !== null && c !== void 0 ? c : this.y, lineHeight: (f = n.lineHeight) !== null && f !== void 0 ? f : this.lineHeight, graphicsState: D })), n.font && (v ? this.setFont(v) : this.resetFont()) }, t.prototype.drawImage = function (e, n) { var r, i, s, a, u, c, f; n === void 0 && (n = {}), G(e, "image", [[x0, "PDFImage"]]), xe(n.x, "options.x", ["number"]), xe(n.y, "options.y", ["number"]), xe(n.width, "options.width", ["number"]), xe(n.height, "options.height", ["number"]), xe(n.rotate, "options.rotate", [[Object, "Rotation"]]), xe(n.xSkew, "options.xSkew", [[Object, "Rotation"]]), xe(n.ySkew, "options.ySkew", [[Object, "Rotation"]]), Ur(n.opacity, "opacity.opacity", 0, 1), br(n.blendMode, "options.blendMode", Si); var h = this.node.newXObject("Image", e.ref), v = this.maybeEmbedGraphicsState({ opacity: n.opacity, blendMode: n.blendMode }), m = this.getContentStream(); m.push.apply(m, GP(h, { x: (r = n.x) !== null && r !== void 0 ? r : this.x, y: (i = n.y) !== null && i !== void 0 ? i : this.y, width: (s = n.width) !== null && s !== void 0 ? s : e.size().width, height: (a = n.height) !== null && a !== void 0 ? a : e.size().height, rotate: (u = n.rotate) !== null && u !== void 0 ? u : Ge(0), xSkew: (c = n.xSkew) !== null && c !== void 0 ? c : Ge(0), ySkew: (f = n.ySkew) !== null && f !== void 0 ? f : Ge(0), graphicsState: v })) }, t.prototype.drawPage = function (e, n) { var r, i, s, a, u; n === void 0 && (n = {}), G(e, "embeddedPage", [[$P, "PDFEmbeddedPage"]]), xe(n.x, "options.x", ["number"]), xe(n.y, "options.y", ["number"]), xe(n.xScale, "options.xScale", ["number"]), xe(n.yScale, "options.yScale", ["number"]), xe(n.width, "options.width", ["number"]), xe(n.height, "options.height", ["number"]), xe(n.rotate, "options.rotate", [[Object, "Rotation"]]), xe(n.xSkew, "options.xSkew", [[Object, "Rotation"]]), xe(n.ySkew, "options.ySkew", [[Object, "Rotation"]]), Ur(n.opacity, "opacity.opacity", 0, 1), br(n.blendMode, "options.blendMode", Si); var c = this.node.newXObject("EmbeddedPdfPage", e.ref), f = this.maybeEmbedGraphicsState({ opacity: n.opacity, blendMode: n.blendMode }), h = n.width !== void 0 ? n.width / e.width : n.xScale !== void 0 ? n.xScale : 1, v = n.height !== void 0 ? n.height / e.height : n.yScale !== void 0 ? n.yScale : 1, m = this.getContentStream(); m.push.apply(m, S5(c, { x: (r = n.x) !== null && r !== void 0 ? r : this.x, y: (i = n.y) !== null && i !== void 0 ? i : this.y, xScale: h, yScale: v, rotate: (s = n.rotate) !== null && s !== void 0 ? s : Ge(0), xSkew: (a = n.xSkew) !== null && a !== void 0 ? a : Ge(0), ySkew: (u = n.ySkew) !== null && u !== void 0 ? u : Ge(0), graphicsState: f })) }, t.prototype.drawSvgPath = function (e, n) { var r, i, s, a, u, c, f, h, v; n === void 0 && (n = {}), G(e, "path", ["string"]), xe(n.x, "options.x", ["number"]), xe(n.y, "options.y", ["number"]), xe(n.scale, "options.scale", ["number"]), xe(n.rotate, "options.rotate", [[Object, "Rotation"]]), xe(n.borderWidth, "options.borderWidth", ["number"]), xe(n.color, "options.color", [[Object, "Color"]]), Ur(n.opacity, "opacity.opacity", 0, 1), xe(n.borderColor, "options.borderColor", [[Object, "Color"]]), xe(n.borderDashArray, "options.borderDashArray", [Array]), xe(n.borderDashPhase, "options.borderDashPhase", ["number"]), br(n.borderLineCap, "options.borderLineCap", Hs), Ur(n.borderOpacity, "options.borderOpacity", 0, 1), br(n.blendMode, "options.blendMode", Si); var m = this.maybeEmbedGraphicsState({ opacity: n.opacity, borderOpacity: n.borderOpacity, blendMode: n.blendMode }); !("color" in n) && !("borderColor" in n) && (n.borderColor = St(0, 0, 0)); var g = this.getContentStream(); g.push.apply(g, T5(e, { x: (r = n.x) !== null && r !== void 0 ? r : this.x, y: (i = n.y) !== null && i !== void 0 ? i : this.y, scale: n.scale, rotate: (s = n.rotate) !== null && s !== void 0 ? s : Ge(0), color: (a = n.color) !== null && a !== void 0 ? a : void 0, borderColor: (u = n.borderColor) !== null && u !== void 0 ? u : void 0, borderWidth: (c = n.borderWidth) !== null && c !== void 0 ? c : 0, borderDashArray: (f = n.borderDashArray) !== null && f !== void 0 ? f : void 0, borderDashPhase: (h = n.borderDashPhase) !== null && h !== void 0 ? h : void 0, borderLineCap: (v = n.borderLineCap) !== null && v !== void 0 ? v : void 0, graphicsState: m })) }, t.prototype.drawLine = function (e) { var n, r, i, s, a; G(e.start, "options.start", [[Object, "{ x: number, y: number }"]]), G(e.end, "options.end", [[Object, "{ x: number, y: number }"]]), G(e.start.x, "options.start.x", ["number"]), G(e.start.y, "options.start.y", ["number"]), G(e.end.x, "options.end.x", ["number"]), G(e.end.y, "options.end.y", ["number"]), xe(e.thickness, "options.thickness", ["number"]), xe(e.color, "options.color", [[Object, "Color"]]), xe(e.dashArray, "options.dashArray", [Array]), xe(e.dashPhase, "options.dashPhase", ["number"]), br(e.lineCap, "options.lineCap", Hs), Ur(e.opacity, "opacity.opacity", 0, 1), br(e.blendMode, "options.blendMode", Si); var u = this.maybeEmbedGraphicsState({ borderOpacity: e.opacity, blendMode: e.blendMode }); "color" in e || (e.color = St(0, 0, 0)); var c = this.getContentStream(); c.push.apply(c, b5({ start: e.start, end: e.end, thickness: (n = e.thickness) !== null && n !== void 0 ? n : 1, color: (r = e.color) !== null && r !== void 0 ? r : void 0, dashArray: (i = e.dashArray) !== null && i !== void 0 ? i : void 0, dashPhase: (s = e.dashPhase) !== null && s !== void 0 ? s : void 0, lineCap: (a = e.lineCap) !== null && a !== void 0 ? a : void 0, graphicsState: u })) }, t.prototype.drawRectangle = function (e) { var n, r, i, s, a, u, c, f, h, v, m, g, S; e === void 0 && (e = {}), xe(e.x, "options.x", ["number"]), xe(e.y, "options.y", ["number"]), xe(e.width, "options.width", ["number"]), xe(e.height, "options.height", ["number"]), xe(e.rotate, "options.rotate", [[Object, "Rotation"]]), xe(e.xSkew, "options.xSkew", [[Object, "Rotation"]]), xe(e.ySkew, "options.ySkew", [[Object, "Rotation"]]), xe(e.borderWidth, "options.borderWidth", ["number"]), xe(e.color, "options.color", [[Object, "Color"]]), Ur(e.opacity, "opacity.opacity", 0, 1), xe(e.borderColor, "options.borderColor", [[Object, "Color"]]), xe(e.borderDashArray, "options.borderDashArray", [Array]), xe(e.borderDashPhase, "options.borderDashPhase", ["number"]), br(e.borderLineCap, "options.borderLineCap", Hs), Ur(e.borderOpacity, "options.borderOpacity", 0, 1), br(e.blendMode, "options.blendMode", Si); var b = this.maybeEmbedGraphicsState({ opacity: e.opacity, borderOpacity: e.borderOpacity, blendMode: e.blendMode }); !("color" in e) && !("borderColor" in e) && (e.color = St(0, 0, 0)); var P = this.getContentStream(); P.push.apply(P, ra({ x: (n = e.x) !== null && n !== void 0 ? n : this.x, y: (r = e.y) !== null && r !== void 0 ? r : this.y, width: (i = e.width) !== null && i !== void 0 ? i : 150, height: (s = e.height) !== null && s !== void 0 ? s : 100, rotate: (a = e.rotate) !== null && a !== void 0 ? a : Ge(0), xSkew: (u = e.xSkew) !== null && u !== void 0 ? u : Ge(0), ySkew: (c = e.ySkew) !== null && c !== void 0 ? c : Ge(0), borderWidth: (f = e.borderWidth) !== null && f !== void 0 ? f : 0, color: (h = e.color) !== null && h !== void 0 ? h : void 0, borderColor: (v = e.borderColor) !== null && v !== void 0 ? v : void 0, borderDashArray: (m = e.borderDashArray) !== null && m !== void 0 ? m : void 0, borderDashPhase: (g = e.borderDashPhase) !== null && g !== void 0 ? g : void 0, graphicsState: b, borderLineCap: (S = e.borderLineCap) !== null && S !== void 0 ? S : void 0 })) }, t.prototype.drawSquare = function (e) { e === void 0 && (e = {}); var n = e.size; xe(n, "size", ["number"]), this.drawRectangle(_e(_e({}, e), { width: n, height: n })) }, t.prototype.drawEllipse = function (e) { var n, r, i, s, a, u, c, f, h, v, m; e === void 0 && (e = {}), xe(e.x, "options.x", ["number"]), xe(e.y, "options.y", ["number"]), xe(e.xScale, "options.xScale", ["number"]), xe(e.yScale, "options.yScale", ["number"]), xe(e.rotate, "options.rotate", [[Object, "Rotation"]]), xe(e.color, "options.color", [[Object, "Color"]]), Ur(e.opacity, "opacity.opacity", 0, 1), xe(e.borderColor, "options.borderColor", [[Object, "Color"]]), Ur(e.borderOpacity, "options.borderOpacity", 0, 1), xe(e.borderWidth, "options.borderWidth", ["number"]), xe(e.borderDashArray, "options.borderDashArray", [Array]), xe(e.borderDashPhase, "options.borderDashPhase", ["number"]), br(e.borderLineCap, "options.borderLineCap", Hs), br(e.blendMode, "options.blendMode", Si); var g = this.maybeEmbedGraphicsState({ opacity: e.opacity, borderOpacity: e.borderOpacity, blendMode: e.blendMode }); !("color" in e) && !("borderColor" in e) && (e.color = St(0, 0, 0)); var S = this.getContentStream(); S.push.apply(S, y0({ x: (n = e.x) !== null && n !== void 0 ? n : this.x, y: (r = e.y) !== null && r !== void 0 ? r : this.y, xScale: (i = e.xScale) !== null && i !== void 0 ? i : 100, yScale: (s = e.yScale) !== null && s !== void 0 ? s : 100, rotate: (a = e.rotate) !== null && a !== void 0 ? a : void 0, color: (u = e.color) !== null && u !== void 0 ? u : void 0, borderColor: (c = e.borderColor) !== null && c !== void 0 ? c : void 0, borderWidth: (f = e.borderWidth) !== null && f !== void 0 ? f : 0, borderDashArray: (h = e.borderDashArray) !== null && h !== void 0 ? h : void 0, borderDashPhase: (v = e.borderDashPhase) !== null && v !== void 0 ? v : void 0, borderLineCap: (m = e.borderLineCap) !== null && m !== void 0 ? m : void 0, graphicsState: g })) }, t.prototype.drawCircle = function (e) { e === void 0 && (e = {}); var n = e.size, r = n === void 0 ? 100 : n; xe(r, "size", ["number"]), this.drawEllipse(_e(_e({}, e), { xScale: r, yScale: r })) }, t.prototype.setOrEmbedFont = function (e) { var n = this.font, r = this.fontKey; e ? this.setFont(e) : this.getFont(); var i = this.font, s = this.fontKey; return { oldFont: n, oldFontKey: r, newFont: i, newFontKey: s } }, t.prototype.getFont = function () { if (!this.font || !this.fontKey) { var e = this.doc.embedStandardFont(Sf.Helvetica); this.setFont(e) } return [this.font, this.fontKey] }, t.prototype.resetFont = function () { this.font = void 0, this.fontKey = void 0 }, t.prototype.getContentStream = function (e) { return e === void 0 && (e = !0), e && this.contentStream ? this.contentStream : (this.contentStream = this.createContentStream(), this.contentStreamRef = this.doc.context.register(this.contentStream), this.node.addContentStream(this.contentStreamRef), this.contentStream) }, t.prototype.createContentStream = function () { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; var r = this.doc.context.obj({}), i = Cl.of(r, e); return i }, t.prototype.maybeEmbedGraphicsState = function (e) { var n = e.opacity, r = e.borderOpacity, i = e.blendMode; if (!(n === void 0 && r === void 0 && i === void 0)) { var s = this.doc.context.obj({ Type: "ExtGState", ca: n, CA: r, BM: i }), a = this.node.newExtGState("GS", s); return a } }, t.prototype.scaleAnnot = function (e, n, r) { for (var i = ["RD", "CL", "Vertices", "QuadPoints", "L", "Rect"], s = 0, a = i.length; s < a; s++) { var u = e.lookup(O.of(i[s])); u instanceof mt && u.scalePDFNumbers(n, r) } var c = e.lookup(O.of("InkList")); if (c instanceof mt) for (var s = 0, a = c.size(); s < a; s++) { var f = c.lookup(s); f instanceof mt && f.scalePDFNumbers(n, r) } }, t.of = function (e, n, r) { return new t(e, n, r) }, t.create = function (e) { G(e, "doc", [[_o, "PDFDocument"]]); var n = wt.of(-1), r = Ai.withContextAndParent(e.context, n), i = e.context.register(r); return new t(r, i, e) }, t }(), Zc = function (t) { we(e, t); function e(n, r, i) { var s = t.call(this, n, r, i) || this; return G(n, "acroButton", [[Gf, "PDFAcroPushButton"]]), s.acroField = n, s } return e.prototype.setImage = function (n, r) { r === void 0 && (r = uo.Center); for (var i = this.acroField.getWidgets(), s = 0, a = i.length; s < a; s++) { var u = i[s], c = this.createImageAppearanceStream(u, n, r); this.updateWidgetAppearances(u, { normal: c }) } this.markAsClean() }, e.prototype.setFontSize = function (n) { Uf(n, "fontSize"), this.acroField.setFontSize(n), this.markAsDirty() }, e.prototype.addToPage = function (n, r, i) { var s, a, u, c, f, h, v, m, g, S, b; xe(n, "text", ["string"]), xe(r, "page", [[kr, "PDFPage"]]), da(i); var P = this.createWidget({ x: ((s = i == null ? void 0 : i.x) !== null && s !== void 0 ? s : 0) - ((a = i == null ? void 0 : i.borderWidth) !== null && a !== void 0 ? a : 0) / 2, y: ((u = i == null ? void 0 : i.y) !== null && u !== void 0 ? u : 0) - ((c = i == null ? void 0 : i.borderWidth) !== null && c !== void 0 ? c : 0) / 2, width: (f = i == null ? void 0 : i.width) !== null && f !== void 0 ? f : 100, height: (h = i == null ? void 0 : i.height) !== null && h !== void 0 ? h : 50, textColor: (v = i == null ? void 0 : i.textColor) !== null && v !== void 0 ? v : St(0, 0, 0), backgroundColor: (m = i == null ? void 0 : i.backgroundColor) !== null && m !== void 0 ? m : St(.75, .75, .75), borderColor: i == null ? void 0 : i.borderColor, borderWidth: (g = i == null ? void 0 : i.borderWidth) !== null && g !== void 0 ? g : 0, rotate: (S = i == null ? void 0 : i.rotate) !== null && S !== void 0 ? S : Ge(0), caption: n, hidden: i == null ? void 0 : i.hidden, page: r.ref }), C = this.doc.context.register(P.dict); this.acroField.addWidget(C); var F = (b = i == null ? void 0 : i.font) !== null && b !== void 0 ? b : this.doc.getForm().getDefaultFont(); this.updateWidgetAppearance(P, F), r.node.addAnnot(C) }, e.prototype.needsAppearancesUpdate = function () { var n; if (this.isDirty()) return !0; for (var r = this.acroField.getWidgets(), i = 0, s = r.length; i < s; i++) { var a = r[i], u = ((n = a.getAppearances()) === null || n === void 0 ? void 0 : n.normal) instanceof or; if (!u) return !0 } return !1 }, e.prototype.defaultUpdateAppearances = function (n) { G(n, "font", [[lr, "PDFFont"]]), this.updateAppearances(n) }, e.prototype.updateAppearances = function (n, r) { G(n, "font", [[lr, "PDFFont"]]), xe(r, "provider", [Function]); for (var i = this.acroField.getWidgets(), s = 0, a = i.length; s < a; s++) { var u = i[s]; this.updateWidgetAppearance(u, n, r) } }, e.prototype.updateWidgetAppearance = function (n, r, i) { var s = i ?? G5, a = fa(s(this, n, r)); this.updateWidgetAppearanceWithFont(n, r, a) }, e.of = function (n, r, i) { return new e(n, r, i) }, e }(os); function td(t) { return t !== null && typeof t == "object" && typeof t.start == "function" } const b0 = t => Array.isArray(t); function eT(t, e) { if (!Array.isArray(e)) return !1; const n = e.length; if (n !== t.length) return !1; for (let r = 0; r < n; r++)if (e[r] !== t[r]) return !1; return !0 } function Hl(t) { return typeof t == "string" || Array.isArray(t) } function Nw(t) { const e = [{}, {}]; return t == null || t.values.forEach((n, r) => { e[0][r] = n.get(), e[1][r] = n.getVelocity() }), e } function _v(t, e, n, r) { if (typeof e == "function") { const [i, s] = Nw(r); e = e(n !== void 0 ? n : t.custom, i, s) } if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") { const [i, s] = Nw(r); e = e(n !== void 0 ? n : t.custom, i, s) } return e } function nd(t, e, n) { const r = t.getProps(); return _v(r, e, n !== void 0 ? n : r.custom, t) } const $v = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], em = ["initial", ...$v], uu = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], ss = new Set(uu), Ei = t => t * 1e3, Fi = t => t / 1e3, nV = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, rV = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), iV = { type: "keyframes", duration: .8 }, oV = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, sV = (t, { keyframes: e }) => e.length > 2 ? iV : ss.has(t) ? t.startsWith("scale") ? rV(e[1]) : nV : oV; function tm(t, e) { return t ? t[e] || t.default || t : void 0 } const aV = { skipAnimations: !1, useManualTiming: !1 }, lV = t => t !== null; function rd(t, { repeat: e, repeatType: n = "loop" }, r) { const i = t.filter(lV), s = e && n !== "loop" && e % 2 === 1 ? 0 : i.length - 1; return !s || r === void 0 ? i[s] : r } const Ln = t => t; let uV = Ln, C0 = Ln; function cV(t) { let e = new Set, n = new Set, r = !1, i = !1; const s = new WeakSet; let a = { delta: 0, timestamp: 0, isProcessing: !1 }; function u(f) { s.has(f) && (c.schedule(f), t()), f(a) } const c = { schedule: (f, h = !1, v = !1) => { const g = v && r ? e : n; return h && s.add(f), g.has(f) || g.add(f), f }, cancel: f => { n.delete(f), s.delete(f) }, process: f => { if (a = f, r) { i = !0; return } r = !0, [e, n] = [n, e], e.forEach(u), e.clear(), r = !1, i && (i = !1, c.process(f)) } }; return c } const Nc = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], fV = 40; function tT(t, e) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, s = () => n = !0, a = Nc.reduce((C, F) => (C[F] = cV(s), C), {}), { read: u, resolveKeyframes: c, update: f, preRender: h, render: v, postRender: m } = a, g = () => { const C = performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(C - i.timestamp, fV), 1), i.timestamp = C, i.isProcessing = !0, u.process(i), c.process(i), f.process(i), h.process(i), v.process(i), m.process(i), i.isProcessing = !1, n && e && (r = !1, t(g)) }, S = () => { n = !0, r = !0, i.isProcessing || t(g) }; return { schedule: Nc.reduce((C, F) => { const A = a[F]; return C[F] = (N, D = !1, V = !1) => (n || S(), A.schedule(N, D, V)), C }, {}), cancel: C => { for (let F = 0; F < Nc.length; F++)a[Nc[F]].cancel(C) }, state: i, steps: a } } const { schedule: bt, cancel: ai, state: on, steps: Fp } = tT(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Ln, !0), nT = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, dV = 1e-7, hV = 12; function pV(t, e, n, r, i) { let s, a, u = 0; do a = e + (n - e) / 2, s = nT(a, r, i) - t, s > 0 ? n = a : e = a; while (Math.abs(s) > dV && ++u < hV); return a } function cu(t, e, n, r) { if (t === e && n === r) return Ln; const i = s => pV(s, 0, 1, t, n); return s => s === 0 || s === 1 ? s : nT(i(s), e, r) } const rT = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, iT = t => e => 1 - t(1 - e), oT = cu(.33, 1.53, .69, .99), nm = iT(oT), sT = rT(nm), aT = t => (t *= 2) < 1 ? .5 * nm(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), rm = t => 1 - Math.sin(Math.acos(t)), lT = iT(rm), uT = rT(rm), cT = t => /^0[^.\s]+$/u.test(t); function vV(t) { return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || cT(t) : !0 } const fT = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), dT = t => e => typeof e == "string" && e.startsWith(t), hT = dT("--"), mV = dT("var(--"), im = t => mV(t) ? gV.test(t.split("/*")[0].trim()) : !1, gV = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, yV = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function xV(t) { const e = yV.exec(t); if (!e) return [,]; const [, n, r, i] = e; return [`--${n ?? r}`, i] } function pT(t, e, n = 1) { const [r, i] = xV(t); if (!r) return; const s = window.getComputedStyle(e).getPropertyValue(r); if (s) { const a = s.trim(); return fT(a) ? parseFloat(a) : a } return im(i) ? pT(i, e, n + 1) : i } const Di = (t, e, n) => n > e ? e : n < t ? t : n, ha = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, ql = { ...ha, transform: t => Di(0, 1, t) }, Bc = { ...ha, default: 1 }, fu = t => ({ test: e => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1, parse: parseFloat, transform: e => `${e}${t}` }), io = fu("deg"), ri = fu("%"), He = fu("px"), wV = fu("vh"), SV = fu("vw"), Bw = { ...ri, parse: t => ri.parse(t) / 100, transform: t => ri.transform(t * 100) }, bV = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), Lw = t => t === ha || t === He, jw = (t, e) => parseFloat(t.split(", ")[e]), Iw = (t, e) => (n, { transform: r }) => { if (r === "none" || !r) return 0; const i = r.match(/^matrix3d\((.+)\)$/u); if (i) return jw(i[1], e); { const s = r.match(/^matrix\((.+)\)$/u); return s ? jw(s[1], t) : 0 } }, CV = new Set(["x", "y", "z"]), PV = uu.filter(t => !CV.has(t)); function TV(t) { const e = []; return PV.forEach(n => { const r = t.getValue(n); r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), e } const ia = { width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), top: (t, { top: e }) => parseFloat(e), left: (t, { left: e }) => parseFloat(e), bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min), right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min), x: Iw(4, 13), y: Iw(5, 14) }; ia.translateX = ia.x; ia.translateY = ia.y; const vT = t => e => e.test(t), kV = { test: t => t === "auto", parse: t => t }, mT = [ha, He, ri, io, SV, wV, kV], zw = t => mT.find(vT(t)), Jo = new Set; let P0 = !1, T0 = !1; function gT() { if (T0) { const t = Array.from(Jo).filter(r => r.needsMeasurement), e = new Set(t.map(r => r.element)), n = new Map; e.forEach(r => { const i = TV(r); i.length && (n.set(r, i), r.render()) }), t.forEach(r => r.measureInitialState()), e.forEach(r => { r.render(); const i = n.get(r); i && i.forEach(([s, a]) => { var u; (u = r.getValue(s)) === null || u === void 0 || u.set(a) }) }), t.forEach(r => r.measureEndState()), t.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } T0 = !1, P0 = !1, Jo.forEach(t => t.complete()), Jo.clear() } function yT() { Jo.forEach(t => { t.readKeyframes(), t.needsMeasurement && (T0 = !0) }) } function AV() { yT(), gT() } class om { constructor(e, n, r, i, s, a = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = r, this.motionValue = i, this.element = s, this.isAsync = a } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (Jo.add(this), P0 || (P0 = !0, bt.read(yT), bt.resolveKeyframes(gT))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: e, name: n, element: r, motionValue: i } = this; for (let s = 0; s < e.length; s++)if (e[s] === null) if (s === 0) { const a = i == null ? void 0 : i.get(), u = e[e.length - 1]; if (a !== void 0) e[0] = a; else if (r && n) { const c = r.readValue(n, u); c != null && (e[0] = c) } e[0] === void 0 && (e[0] = u), i && a === void 0 && i.set(e[0]) } else e[s] = e[s - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Jo.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, Jo.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const El = t => Math.round(t * 1e5) / 1e5, sm = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function EV(t) { return t == null } const FV = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, am = (t, e) => n => !!(typeof n == "string" && FV.test(n) && n.startsWith(t) || e && !EV(n) && Object.prototype.hasOwnProperty.call(n, e)), xT = (t, e, n) => r => { if (typeof r != "string") return r; const [i, s, a, u] = r.match(sm); return { [t]: parseFloat(i), [e]: parseFloat(s), [n]: parseFloat(a), alpha: u !== void 0 ? parseFloat(u) : 1 } }, RV = t => Di(0, 255, t), Rp = { ...ha, transform: t => Math.round(RV(t)) }, Yo = { test: am("rgb", "red"), parse: xT("red", "green", "blue"), transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + Rp.transform(t) + ", " + Rp.transform(e) + ", " + Rp.transform(n) + ", " + El(ql.transform(r)) + ")" }; function DV(t) { let e = "", n = "", r = "", i = ""; return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), i = t.substring(4, 5), e += e, n += n, r += r, i += i), { red: parseInt(e, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } const k0 = { test: am("#"), parse: DV, transform: Yo.transform }, qs = { test: am("hsl", "hue"), parse: xT("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + ri.transform(El(e)) + ", " + ri.transform(El(n)) + ", " + El(ql.transform(r)) + ")" }, En = { test: t => Yo.test(t) || k0.test(t) || qs.test(t), parse: t => Yo.test(t) ? Yo.parse(t) : qs.test(t) ? qs.parse(t) : k0.parse(t), transform: t => typeof t == "string" ? t : t.hasOwnProperty("red") ? Yo.transform(t) : qs.transform(t) }, OV = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function MV(t) { var e, n; return isNaN(t) && typeof t == "string" && (((e = t.match(sm)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(OV)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } const wT = "number", ST = "color", VV = "var", NV = "var(", Uw = "${}", BV = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Gl(t) { const e = t.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let s = 0; const u = e.replace(BV, c => (En.test(c) ? (r.color.push(s), i.push(ST), n.push(En.parse(c))) : c.startsWith(NV) ? (r.var.push(s), i.push(VV), n.push(c)) : (r.number.push(s), i.push(wT), n.push(parseFloat(c))), ++s, Uw)).split(Uw); return { values: n, split: u, indexes: r, types: i } } function bT(t) { return Gl(t).values } function CT(t) { const { split: e, types: n } = Gl(t), r = e.length; return i => { let s = ""; for (let a = 0; a < r; a++)if (s += e[a], i[a] !== void 0) { const u = n[a]; u === wT ? s += El(i[a]) : u === ST ? s += En.transform(i[a]) : s += i[a] } return s } } const LV = t => typeof t == "number" ? 0 : t; function jV(t) { const e = bT(t); return CT(t)(e.map(LV)) } const mo = { test: MV, parse: bT, createTransformer: CT, getAnimatableNone: jV }, IV = new Set(["brightness", "contrast", "saturate", "opacity"]); function zV(t) { const [e, n] = t.slice(0, -1).split("("); if (e === "drop-shadow") return t; const [r] = n.match(sm) || []; if (!r) return t; const i = n.replace(r, ""); let s = IV.has(e) ? 1 : 0; return r !== n && (s *= 100), e + "(" + s + i + ")" } const UV = /\b([a-z-]*)\(.*?\)/gu, A0 = { ...mo, getAnimatableNone: t => { const e = t.match(UV); return e ? e.map(zV).join(" ") : t } }, WV = { borderWidth: He, borderTopWidth: He, borderRightWidth: He, borderBottomWidth: He, borderLeftWidth: He, borderRadius: He, radius: He, borderTopLeftRadius: He, borderTopRightRadius: He, borderBottomRightRadius: He, borderBottomLeftRadius: He, width: He, maxWidth: He, height: He, maxHeight: He, top: He, right: He, bottom: He, left: He, padding: He, paddingTop: He, paddingRight: He, paddingBottom: He, paddingLeft: He, margin: He, marginTop: He, marginRight: He, marginBottom: He, marginLeft: He, backgroundPositionX: He, backgroundPositionY: He }, KV = { rotate: io, rotateX: io, rotateY: io, rotateZ: io, scale: Bc, scaleX: Bc, scaleY: Bc, scaleZ: Bc, skew: io, skewX: io, skewY: io, distance: He, translateX: He, translateY: He, translateZ: He, x: He, y: He, z: He, perspective: He, transformPerspective: He, opacity: ql, originX: Bw, originY: Bw, originZ: He }, Ww = { ...ha, transform: Math.round }, lm = { ...WV, ...KV, zIndex: Ww, size: He, fillOpacity: ql, strokeOpacity: ql, numOctaves: Ww }, HV = { ...lm, color: En, backgroundColor: En, outlineColor: En, fill: En, stroke: En, borderColor: En, borderTopColor: En, borderRightColor: En, borderBottomColor: En, borderLeftColor: En, filter: A0, WebkitFilter: A0 }, um = t => HV[t]; function PT(t, e) { let n = um(t); return n !== A0 && (n = mo), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0 } const qV = new Set(["auto", "none", "0"]); function GV(t, e, n) { let r = 0, i; for (; r < t.length && !i;) { const s = t[r]; typeof s == "string" && !qV.has(s) && Gl(s).values.length && (i = t[r]), r++ } if (i && n) for (const s of e) t[s] = PT(n, i) } class TT extends om { constructor(e, n, r, i, s) { super(e, n, r, i, s, !0) } readKeyframes() { const { unresolvedKeyframes: e, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let c = 0; c < e.length; c++) { let f = e[c]; if (typeof f == "string" && (f = f.trim(), im(f))) { const h = pT(f, n.current); h !== void 0 && (e[c] = h), c === e.length - 1 && (this.finalKeyframe = f) } } if (this.resolveNoneKeyframes(), !bV.has(r) || e.length !== 2) return; const [i, s] = e, a = zw(i), u = zw(s); if (a !== u) if (Lw(a) && Lw(u)) for (let c = 0; c < e.length; c++) { const f = e[c]; typeof f == "string" && (e[c] = parseFloat(f)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: e, name: n } = this, r = []; for (let i = 0; i < e.length; i++)vV(e[i]) && r.push(i); r.length && GV(e, r, n) } measureInitialState() { const { element: e, unresolvedKeyframes: n, name: r } = this; if (!e || !e.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ia[r](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin; const i = n[n.length - 1]; i !== void 0 && e.getValue(r, i).jump(i, !1) } measureEndState() { var e; const { element: n, name: r, unresolvedKeyframes: i } = this; if (!n || !n.current) return; const s = n.getValue(r); s && s.jump(this.measuredOrigin, !1); const a = i.length - 1, u = i[a]; i[a] = ia[r](n.measureViewportBox(), window.getComputedStyle(n.current)), u !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = u), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([c, f]) => { n.getValue(c).set(f) }), this.resolveNoneKeyframes() } } function cm(t) { return typeof t == "function" } let Yc; function XV() { Yc = void 0 } const ii = { now: () => (Yc === void 0 && ii.set(on.isProcessing || aV.useManualTiming ? on.timestamp : performance.now()), Yc), set: t => { Yc = t, queueMicrotask(XV) } }, Kw = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (mo.test(t) || t === "0") && !t.startsWith("url(")); function ZV(t) { const e = t[0]; if (t.length === 1) return !0; for (let n = 0; n < t.length; n++)if (t[n] !== e) return !0 } function YV(t, e, n, r) { const i = t[0]; if (i === null) return !1; if (e === "display" || e === "visibility") return !0; const s = t[t.length - 1], a = Kw(i, e), u = Kw(s, e); return !a || !u ? !1 : ZV(t) || (n === "spring" || cm(n)) && r } const QV = 40; class kT { constructor({ autoplay: e = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: a = "loop", ...u }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = ii.now(), this.options = { autoplay: e, delay: n, type: r, repeat: i, repeatDelay: s, repeatType: a, ...u }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > QV ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && AV(), this._resolved } onKeyframesResolved(e, n) { this.resolvedAt = ii.now(), this.hasAttemptedResolve = !0; const { name: r, type: i, velocity: s, delay: a, onComplete: u, onUpdate: c, isGenerator: f } = this.options; if (!f && !YV(e, r, i, s)) if (a) this.options.duration = 0; else { c == null || c(rd(e, this.options, n)), u == null || u(), this.resolveFinishedPromise(); return } const h = this.initPlayback(e, n); h !== !1 && (this._resolved = { keyframes: e, finalKeyframe: n, ...h }, this.onPostResolved()) } onPostResolved() { } then(e, n) { return this.currentFinishedPromise.then(e, n) } flatten() { this.options.type = "keyframes", this.options.ease = "linear" } updateFinishedPromise() { this.currentFinishedPromise = new Promise(e => { this.resolveFinishedPromise = e }) } } const $o = (t, e, n) => { const r = e - t; return r === 0 ? 1 : (n - t) / r }, AT = (t, e, n = 10) => { let r = ""; const i = Math.max(Math.round(e / n), 2); for (let s = 0; s < i; s++)r += t($o(0, i - 1, s)) + ", "; return `linear(${r.substring(0, r.length - 2)})` }; function fm(t, e) { return e ? t * (1e3 / e) : 0 } const JV = 5; function ET(t, e, n) { const r = Math.max(e - JV, 0); return fm(n - t(r), e - r) } const Wt = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, Dp = .001; function _V({ duration: t = Wt.duration, bounce: e = Wt.bounce, velocity: n = Wt.velocity, mass: r = Wt.mass }) { let i, s, a = 1 - e; a = Di(Wt.minDamping, Wt.maxDamping, a), t = Di(Wt.minDuration, Wt.maxDuration, Fi(t)), a < 1 ? (i = f => { const h = f * a, v = h * t, m = h - n, g = E0(f, a), S = Math.exp(-v); return Dp - m / g * S }, s = f => { const v = f * a * t, m = v * n + n, g = Math.pow(a, 2) * Math.pow(f, 2) * t, S = Math.exp(-v), b = E0(Math.pow(f, 2), a); return (-i(f) + Dp > 0 ? -1 : 1) * ((m - g) * S) / b }) : (i = f => { const h = Math.exp(-f * t), v = (f - n) * t + 1; return -Dp + h * v }, s = f => { const h = Math.exp(-f * t), v = (n - f) * (t * t); return h * v }); const u = 5 / t, c = e8(i, s, u); if (t = Ei(t), isNaN(c)) return { stiffness: Wt.stiffness, damping: Wt.damping, duration: t }; { const f = Math.pow(c, 2) * r; return { stiffness: f, damping: a * 2 * Math.sqrt(r * f), duration: t } } } const $V = 12; function e8(t, e, n) { let r = n; for (let i = 1; i < $V; i++)r = r - t(r) / e(r); return r } function E0(t, e) { return t * Math.sqrt(1 - e * e) } const F0 = 2e4; function FT(t) { let e = 0; const n = 50; let r = t.next(e); for (; !r.done && e < F0;)e += n, r = t.next(e); return e >= F0 ? 1 / 0 : e } const t8 = ["duration", "bounce"], n8 = ["stiffness", "damping", "mass"]; function Hw(t, e) { return e.some(n => t[n] !== void 0) } function r8(t) { let e = { velocity: Wt.velocity, stiffness: Wt.stiffness, damping: Wt.damping, mass: Wt.mass, isResolvedFromDuration: !1, ...t }; if (!Hw(t, n8) && Hw(t, t8)) if (t.visualDuration) { const n = t.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, s = 2 * Di(.05, 1, 1 - t.bounce) * Math.sqrt(i); e = { ...e, mass: Wt.mass, stiffness: i, damping: s } } else { const n = _V(t); e = { ...e, ...n, mass: Wt.mass }, e.isResolvedFromDuration = !0 } return e } function RT(t = Wt.visualDuration, e = Wt.bounce) { const n = typeof t != "object" ? { visualDuration: t, keyframes: [0, 1], bounce: e } : t; let { restSpeed: r, restDelta: i } = n; const s = n.keyframes[0], a = n.keyframes[n.keyframes.length - 1], u = { done: !1, value: s }, { stiffness: c, damping: f, mass: h, duration: v, velocity: m, isResolvedFromDuration: g } = r8({ ...n, velocity: -Fi(n.velocity || 0) }), S = m || 0, b = f / (2 * Math.sqrt(c * h)), P = a - s, C = Fi(Math.sqrt(c / h)), F = Math.abs(P) < 5; r || (r = F ? Wt.restSpeed.granular : Wt.restSpeed.default), i || (i = F ? Wt.restDelta.granular : Wt.restDelta.default); let A; if (b < 1) { const D = E0(C, b); A = V => { const B = Math.exp(-b * C * V); return a - B * ((S + b * C * P) / D * Math.sin(D * V) + P * Math.cos(D * V)) } } else if (b === 1) A = D => a - Math.exp(-C * D) * (P + (S + C * P) * D); else { const D = C * Math.sqrt(b * b - 1); A = V => { const B = Math.exp(-b * C * V), I = Math.min(D * V, 300); return a - B * ((S + b * C * P) * Math.sinh(I) + D * P * Math.cosh(I)) / D } } const N = { calculatedDuration: g && v || null, next: D => { const V = A(D); if (g) u.done = D >= v; else { let B = 0; b < 1 && (B = D === 0 ? Ei(S) : ET(A, D, V)); const I = Math.abs(B) <= r, Y = Math.abs(a - V) <= i; u.done = I && Y } return u.value = u.done ? a : V, u }, toString: () => { const D = Math.min(FT(N), F0), V = AT(B => N.next(D * B).value, D, 30); return D + "ms " + V } }; return N } function qw({ keyframes: t, velocity: e = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: a, min: u, max: c, restDelta: f = .5, restSpeed: h }) { const v = t[0], m = { done: !1, value: v }, g = I => u !== void 0 && I < u || c !== void 0 && I > c, S = I => u === void 0 ? c : c === void 0 || Math.abs(u - I) < Math.abs(c - I) ? u : c; let b = n * e; const P = v + b, C = a === void 0 ? P : a(P); C !== P && (b = C - v); const F = I => -b * Math.exp(-I / r), A = I => C + F(I), N = I => { const Y = F(I), Z = A(I); m.done = Math.abs(Y) <= f, m.value = m.done ? C : Z }; let D, V; const B = I => { g(m.value) && (D = I, V = RT({ keyframes: [m.value, S(m.value)], velocity: ET(A, I, m.value), damping: i, stiffness: s, restDelta: f, restSpeed: h })) }; return B(0), { calculatedDuration: null, next: I => { let Y = !1; return !V && D === void 0 && (Y = !0, N(I), B(I)), D !== void 0 && I >= D ? V.next(I - D) : (!Y && N(I), m) } } } const i8 = cu(.42, 0, 1, 1), o8 = cu(0, 0, .58, 1), DT = cu(.42, 0, .58, 1), s8 = t => Array.isArray(t) && typeof t[0] != "number", dm = t => Array.isArray(t) && typeof t[0] == "number", Gw = { linear: Ln, easeIn: i8, easeInOut: DT, easeOut: o8, circIn: rm, circInOut: uT, circOut: lT, backIn: nm, backInOut: sT, backOut: oT, anticipate: aT }, Xw = t => { if (dm(t)) { C0(t.length === 4); const [e, n, r, i] = t; return cu(e, n, r, i) } else if (typeof t == "string") return C0(Gw[t] !== void 0), Gw[t]; return t }, a8 = (t, e) => n => e(t(n)), du = (...t) => t.reduce(a8), Lt = (t, e, n) => t + (e - t) * n; function Op(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } function l8({ hue: t, saturation: e, lightness: n, alpha: r }) { t /= 360, e /= 100, n /= 100; let i = 0, s = 0, a = 0; if (!e) i = s = a = n; else { const u = n < .5 ? n * (1 + e) : n + e - n * e, c = 2 * n - u; i = Op(c, u, t + 1 / 3), s = Op(c, u, t), a = Op(c, u, t - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(s * 255), blue: Math.round(a * 255), alpha: r } } function bf(t, e) { return n => n > 0 ? e : t } const Mp = (t, e, n) => { const r = t * t, i = n * (e * e - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, u8 = [k0, Yo, qs], c8 = t => u8.find(e => e.test(t)); function Zw(t) { const e = c8(t); if (!e) return !1; let n = e.parse(t); return e === qs && (n = l8(n)), n } const Yw = (t, e) => { const n = Zw(t), r = Zw(e); if (!n || !r) return bf(t, e); const i = { ...n }; return s => (i.red = Mp(n.red, r.red, s), i.green = Mp(n.green, r.green, s), i.blue = Mp(n.blue, r.blue, s), i.alpha = Lt(n.alpha, r.alpha, s), Yo.transform(i)) }, R0 = new Set(["none", "hidden"]); function f8(t, e) { return R0.has(t) ? n => n <= 0 ? t : e : n => n >= 1 ? e : t } function d8(t, e) { return n => Lt(t, e, n) } function hm(t) { return typeof t == "number" ? d8 : typeof t == "string" ? im(t) ? bf : En.test(t) ? Yw : v8 : Array.isArray(t) ? OT : typeof t == "object" ? En.test(t) ? Yw : h8 : bf } function OT(t, e) { const n = [...t], r = n.length, i = t.map((s, a) => hm(s)(s, e[a])); return s => { for (let a = 0; a < r; a++)n[a] = i[a](s); return n } } function h8(t, e) { const n = { ...t, ...e }, r = {}; for (const i in n) t[i] !== void 0 && e[i] !== void 0 && (r[i] = hm(t[i])(t[i], e[i])); return i => { for (const s in r) n[s] = r[s](i); return n } } function p8(t, e) { var n; const r = [], i = { color: 0, var: 0, number: 0 }; for (let s = 0; s < e.values.length; s++) { const a = e.types[s], u = t.indexes[a][i[a]], c = (n = t.values[u]) !== null && n !== void 0 ? n : 0; r[s] = c, i[a]++ } return r } const v8 = (t, e) => { const n = mo.createTransformer(e), r = Gl(t), i = Gl(e); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? R0.has(t) && !i.values.length || R0.has(e) && !r.values.length ? f8(t, e) : du(OT(p8(r, i), i.values), n) : bf(t, e) }; function MT(t, e, n) { return typeof t == "number" && typeof e == "number" && typeof n == "number" ? Lt(t, e, n) : hm(t)(t, e) } function m8(t, e, n) { const r = [], i = n || MT, s = t.length - 1; for (let a = 0; a < s; a++) { let u = i(t[a], t[a + 1]); if (e) { const c = Array.isArray(e) ? e[a] || Ln : e; u = du(c, u) } r.push(u) } return r } function VT(t, e, { clamp: n = !0, ease: r, mixer: i } = {}) { const s = t.length; if (C0(s === e.length), s === 1) return () => e[0]; if (s === 2 && t[0] === t[1]) return () => e[1]; t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse()); const a = m8(e, r, i), u = a.length, c = f => { let h = 0; if (u > 1) for (; h < t.length - 2 && !(f < t[h + 1]); h++); const v = $o(t[h], t[h + 1], f); return a[h](v) }; return n ? f => c(Di(t[0], t[s - 1], f)) : c } function g8(t, e) { const n = t[t.length - 1]; for (let r = 1; r <= e; r++) { const i = $o(0, e, r); t.push(Lt(n, 1, i)) } } function NT(t) { const e = [0]; return g8(e, t.length - 1), e } function y8(t, e) { return t.map(n => n * e) } function x8(t, e) { return t.map(() => e || DT).splice(0, t.length - 1) } function Cf({ duration: t = 300, keyframes: e, times: n, ease: r = "easeInOut" }) { const i = s8(r) ? r.map(Xw) : Xw(r), s = { done: !1, value: e[0] }, a = y8(n && n.length === e.length ? n : NT(e), t), u = VT(a, e, { ease: Array.isArray(i) ? i : x8(e, i) }); return { calculatedDuration: t, next: c => (s.value = u(c), s.done = c >= t, s) } } const w8 = t => { const e = ({ timestamp: n }) => t(n); return { start: () => bt.update(e, !0), stop: () => ai(e), now: () => on.isProcessing ? on.timestamp : ii.now() } }, S8 = { decay: qw, inertia: qw, tween: Cf, keyframes: Cf, spring: RT }, b8 = t => t / 100; class id extends kT { constructor(e) { super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); const { onStop: c } = this.options; c && c() }; const { name: n, motionValue: r, element: i, keyframes: s } = this.options, a = (i == null ? void 0 : i.KeyframeResolver) || om, u = (c, f) => this.onKeyframesResolved(c, f); this.resolver = new a(s, u, n, r, i), this.resolver.scheduleResolve() } flatten() { super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)) } initPlayback(e) { const { type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: s, velocity: a = 0 } = this.options, u = cm(n) ? n : S8[n] || Cf; let c, f; u !== Cf && typeof e[0] != "number" && (c = du(b8, MT(e[0], e[1])), e = [0, 100]); const h = u({ ...this.options, keyframes: e }); s === "mirror" && (f = u({ ...this.options, keyframes: [...e].reverse(), velocity: -a })), h.calculatedDuration === null && (h.calculatedDuration = FT(h)); const { calculatedDuration: v } = h, m = v + i, g = m * (r + 1) - i; return { generator: h, mirroredGenerator: f, mapPercentToKeyframes: c, calculatedDuration: v, resolvedDuration: m, totalDuration: g } } onPostResolved() { const { autoplay: e = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState } tick(e, n = !1) { const { resolved: r } = this; if (!r) { const { keyframes: I } = this.options; return { done: !0, value: I[I.length - 1] } } const { finalKeyframe: i, generator: s, mirroredGenerator: a, mapPercentToKeyframes: u, keyframes: c, calculatedDuration: f, totalDuration: h, resolvedDuration: v } = r; if (this.startTime === null) return s.next(0); const { delay: m, repeat: g, repeatType: S, repeatDelay: b, onUpdate: P } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - h / this.speed, this.startTime)), n ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed; const C = this.currentTime - m * (this.speed >= 0 ? 1 : -1), F = this.speed >= 0 ? C < 0 : C > h; this.currentTime = Math.max(C, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = h); let A = this.currentTime, N = s; if (g) { const I = Math.min(this.currentTime, h) / v; let Y = Math.floor(I), Z = I % 1; !Z && I >= 1 && (Z = 1), Z === 1 && Y--, Y = Math.min(Y, g + 1), !!(Y % 2) && (S === "reverse" ? (Z = 1 - Z, b && (Z -= b / v)) : S === "mirror" && (N = a)), A = Di(0, 1, Z) * v } const D = F ? { done: !1, value: c[0] } : N.next(A); u && (D.value = u(D.value)); let { done: V } = D; !F && f !== null && (V = this.speed >= 0 ? this.currentTime >= h : this.currentTime <= 0); const B = this.holdTime === null && (this.state === "finished" || this.state === "running" && V); return B && i !== void 0 && (D.value = rd(c, this.options, i)), P && P(D.value), B && this.finish(), D } get duration() { const { resolved: e } = this; return e ? Fi(e.calculatedDuration) : 0 } get time() { return Fi(this.currentTime) } set time(e) { e = Ei(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed) } get speed() { return this.playbackSpeed } set speed(e) { const n = this.playbackSpeed !== e; this.playbackSpeed = e, n && (this.time = Fi(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; const { driver: e = w8, onPlay: n, startTime: r } = this.options; this.driver || (this.driver = e(s => this.tick(s))), n && n(); const i = this.driver.now(); this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var e; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: e } = this.options; e && e() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } } function C8(t) { return new id(t) } const P8 = new Set(["opacity", "clipPath", "filter", "transform"]); function pm(t) { let e; return () => (e === void 0 && (e = t()), e) } const T8 = { linearEasing: void 0 }; function k8(t, e) { const n = pm(t); return () => { var r; return (r = T8[e]) !== null && r !== void 0 ? r : n() } } const Pf = k8(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"); function BT(t) { return !!(typeof t == "function" && Pf() || !t || typeof t == "string" && (t in D0 || Pf()) || dm(t) || Array.isArray(t) && t.every(BT)) } const ml = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`, D0 = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: ml([0, .65, .55, 1]), circOut: ml([.55, 0, 1, .45]), backIn: ml([.31, .01, .66, -.59]), backOut: ml([.33, 1.53, .69, .99]) }; function LT(t, e) { if (t) return typeof t == "function" && Pf() ? AT(t, e) : dm(t) ? ml(t) : Array.isArray(t) ? t.map(n => LT(n, e) || D0.easeOut) : D0[t] } function A8(t, e, n, { delay: r = 0, duration: i = 300, repeat: s = 0, repeatType: a = "loop", ease: u = "easeInOut", times: c } = {}) { const f = { [e]: n }; c && (f.offset = c); const h = LT(u, i); return Array.isArray(h) && (f.easing = h), t.animate(f, { delay: r, duration: i, easing: Array.isArray(h) ? "linear" : h, fill: "both", iterations: s + 1, direction: a === "reverse" ? "alternate" : "normal" }) } function Qw(t, e) { t.timeline = e, t.onfinish = null } const E8 = pm(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Tf = 10, F8 = 2e4; function R8(t) { return cm(t.type) || t.type === "spring" || !BT(t.ease) } function D8(t, e) { const n = new id({ ...e, keyframes: t, repeat: 0, delay: 0, isGenerator: !0 }); let r = { done: !1, value: t[0] }; const i = []; let s = 0; for (; !r.done && s < F8;)r = n.sample(s), i.push(r.value), s += Tf; return { times: void 0, keyframes: i, duration: s - Tf, ease: "linear" } } const jT = { anticipate: aT, backInOut: sT, circInOut: uT }; function O8(t) { return t in jT } class Jw extends kT { constructor(e) { super(e); const { name: n, motionValue: r, element: i, keyframes: s } = this.options; this.resolver = new TT(s, (a, u) => this.onKeyframesResolved(a, u), n, r, i), this.resolver.scheduleResolve() } initPlayback(e, n) { var r; let { duration: i = 300, times: s, ease: a, type: u, motionValue: c, name: f, startTime: h } = this.options; if (!(!((r = c.owner) === null || r === void 0) && r.current)) return !1; if (typeof a == "string" && Pf() && O8(a) && (a = jT[a]), R8(this.options)) { const { onComplete: m, onUpdate: g, motionValue: S, element: b, ...P } = this.options, C = D8(e, P); e = C.keyframes, e.length === 1 && (e[1] = e[0]), i = C.duration, s = C.times, a = C.ease, u = "keyframes" } const v = A8(c.owner.current, f, e, { ...this.options, duration: i, times: s, ease: a }); return v.startTime = h ?? this.calcStartTime(), this.pendingTimeline ? (Qw(v, this.pendingTimeline), this.pendingTimeline = void 0) : v.onfinish = () => { const { onComplete: m } = this.options; c.set(rd(e, this.options, n)), m && m(), this.cancel(), this.resolveFinishedPromise() }, { animation: v, duration: i, times: s, type: u, ease: a, keyframes: e } } get duration() { const { resolved: e } = this; if (!e) return 0; const { duration: n } = e; return Fi(n) } get time() { const { resolved: e } = this; if (!e) return 0; const { animation: n } = e; return Fi(n.currentTime || 0) } set time(e) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.currentTime = Ei(e) } get speed() { const { resolved: e } = this; if (!e) return 1; const { animation: n } = e; return n.playbackRate } set speed(e) { const { resolved: n } = this; if (!n) return; const { animation: r } = n; r.playbackRate = e } get state() { const { resolved: e } = this; if (!e) return "idle"; const { animation: n } = e; return n.playState } get startTime() { const { resolved: e } = this; if (!e) return null; const { animation: n } = e; return n.startTime } attachTimeline(e) { if (!this._resolved) this.pendingTimeline = e; else { const { resolved: n } = this; if (!n) return Ln; const { animation: r } = n; Qw(r, e) } return Ln } play() { if (this.isStopped) return; const { resolved: e } = this; if (!e) return; const { animation: n } = e; n.playState === "finished" && this.updateFinishedPromise(), n.play() } pause() { const { resolved: e } = this; if (!e) return; const { animation: n } = e; n.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); const { resolved: e } = this; if (!e) return; const { animation: n, keyframes: r, duration: i, type: s, ease: a, times: u } = e; if (n.playState === "idle" || n.playState === "finished") return; if (this.time) { const { motionValue: f, onUpdate: h, onComplete: v, element: m, ...g } = this.options, S = new id({ ...g, keyframes: r, duration: i, type: s, ease: a, times: u, isGenerator: !0 }), b = Ei(this.time); f.setWithVelocity(S.sample(b - Tf).value, S.sample(b).value, Tf) } const { onStop: c } = this.options; c && c(), this.cancel() } complete() { const { resolved: e } = this; e && e.animation.finish() } cancel() { const { resolved: e } = this; e && e.animation.cancel() } static supports(e) { const { motionValue: n, name: r, repeatDelay: i, repeatType: s, damping: a, type: u } = e; return E8() && r && P8.has(r) && n && n.owner && n.owner.current instanceof HTMLElement && !n.owner.getProps().onUpdate && !i && s !== "mirror" && a !== 0 && u !== "inertia" } } const IT = pm(() => window.ScrollTimeline !== void 0); class M8 { constructor(e) { this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean) } then(e, n) { return Promise.all(this.animations).then(e).catch(n) } getAll(e) { return this.animations[0][e] } setAll(e, n) { for (let r = 0; r < this.animations.length; r++)this.animations[r][e] = n } attachTimeline(e, n) { const r = this.animations.map(i => IT() && i.attachTimeline ? i.attachTimeline(e) : n(i)); return () => { r.forEach((i, s) => { i && i(), this.animations[s].stop() }) } } get time() { return this.getAll("time") } set time(e) { this.setAll("time", e) } get speed() { return this.getAll("speed") } set speed(e) { this.setAll("speed", e) } get startTime() { return this.getAll("startTime") } get duration() { let e = 0; for (let n = 0; n < this.animations.length; n++)e = Math.max(e, this.animations[n].duration); return e } runAll(e) { this.animations.forEach(n => n[e]()) } flatten() { this.runAll("flatten") } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } function V8({ when: t, delay: e, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: a, repeatDelay: u, from: c, elapsed: f, ...h }) { return !!Object.keys(h).length } const vm = (t, e, n, r = {}, i, s) => a => { const u = tm(r, t) || {}, c = u.delay || r.delay || 0; let { elapsed: f = 0 } = r; f = f - Ei(c); let h = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: e.getVelocity(), ...u, delay: -f, onUpdate: m => { e.set(m), u.onUpdate && u.onUpdate(m) }, onComplete: () => { a(), u.onComplete && u.onComplete() }, name: t, motionValue: e, element: s ? void 0 : i }; V8(u) || (h = { ...h, ...sV(t, h) }), h.duration && (h.duration = Ei(h.duration)), h.repeatDelay && (h.repeatDelay = Ei(h.repeatDelay)), h.from !== void 0 && (h.keyframes[0] = h.from); let v = !1; if ((h.type === !1 || h.duration === 0 && !h.repeatDelay) && (h.duration = 0, h.delay === 0 && (v = !0)), v && !s && e.get() !== void 0) { const m = rd(h.keyframes, u); if (m !== void 0) return bt.update(() => { h.onUpdate(m), h.onComplete() }), new M8([]) } return !s && Jw.supports(h) ? new Jw(h) : new id(h) }, N8 = t => !!(t && typeof t == "object" && t.mix && t.toValue), B8 = t => b0(t) ? t[t.length - 1] || 0 : t; function mm(t, e) { t.indexOf(e) === -1 && t.push(e) } function gm(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class ym { constructor() { this.subscriptions = [] } add(e) { return mm(this.subscriptions, e), () => gm(this.subscriptions, e) } notify(e, n, r) { const i = this.subscriptions.length; if (i) if (i === 1) this.subscriptions[0](e, n, r); else for (let s = 0; s < i; s++) { const a = this.subscriptions[s]; a && a(e, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const _w = 30, L8 = t => !isNaN(parseFloat(t)); class j8 { constructor(e, n = {}) { this.version = "11.15.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, i = !0) => { const s = ii.now(); this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner } setCurrent(e) { this.current = e, this.updatedAt = ii.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = L8(this.current)) } setPrevFrameValue(e = this.current) { this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, n) { this.events[e] || (this.events[e] = new ym); const r = this.events[e].add(n); return e === "change" ? () => { r(), bt.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, n) { this.passiveEffect = e, this.stopPassiveEffect = n } set(e, n = !0) { !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - r } jump(e, n = !0) { this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const e = ii.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > _w) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, _w); return fm(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(e) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function ei(t, e) { return new j8(t, e) } function I8(t, e, n) { t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, ei(n)) } function z8(t, e) { const n = nd(t, e); let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {}; s = { ...s, ...r }; for (const a in s) { const u = B8(s[a]); I8(t, a, u) } } const xm = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), U8 = "framerAppearId", zT = "data-" + xm(U8); function UT(t) { return t.props[zT] } const pn = t => !!(t && t.getVelocity); function W8(t) { return !!(pn(t) && t.add) } function O0(t, e) { const n = t.getValue("willChange"); if (W8(n)) return n.add(e) } function K8({ protectedKeys: t, needsAnimating: e }, n) { const r = t.hasOwnProperty(n) && e[n] !== !0; return e[n] = !1, r } function WT(t, e, { delay: n = 0, transitionOverride: r, type: i } = {}) { var s; let { transition: a = t.getDefaultTransition(), transitionEnd: u, ...c } = e; r && (a = r); const f = [], h = i && t.animationState && t.animationState.getState()[i]; for (const v in c) { const m = t.getValue(v, (s = t.latestValues[v]) !== null && s !== void 0 ? s : null), g = c[v]; if (g === void 0 || h && K8(h, v)) continue; const S = { delay: n, ...tm(a || {}, v) }; let b = !1; if (window.MotionHandoffAnimation) { const C = UT(t); if (C) { const F = window.MotionHandoffAnimation(C, v, bt); F !== null && (S.startTime = F, b = !0) } } O0(t, v), m.start(vm(v, m, g, t.shouldReduceMotion && ss.has(v) ? { type: !1 } : S, t, b)); const P = m.animation; P && f.push(P) } return u && Promise.all(f).then(() => { bt.update(() => { u && z8(t, u) }) }), f } function M0(t, e, n = {}) { var r; const i = nd(t, e, n.type === "exit" ? (r = t.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0); let { transition: s = t.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (s = n.transitionOverride); const a = i ? () => Promise.all(WT(t, i, n)) : () => Promise.resolve(), u = t.variantChildren && t.variantChildren.size ? (f = 0) => { const { delayChildren: h = 0, staggerChildren: v, staggerDirection: m } = s; return H8(t, e, h + f, v, m, n) } : () => Promise.resolve(), { when: c } = s; if (c) { const [f, h] = c === "beforeChildren" ? [a, u] : [u, a]; return f().then(() => h()) } else return Promise.all([a(), u(n.delay)]) } function H8(t, e, n = 0, r = 0, i = 1, s) { const a = [], u = (t.variantChildren.size - 1) * r, c = i === 1 ? (f = 0) => f * r : (f = 0) => u - f * r; return Array.from(t.variantChildren).sort(q8).forEach((f, h) => { f.notify("AnimationStart", e), a.push(M0(f, e, { ...s, delay: n + c(h) }).then(() => f.notify("AnimationComplete", e))) }), Promise.all(a) } function q8(t, e) { return t.sortNodePosition(e) } function G8(t, e, n = {}) { t.notify("AnimationStart", e); let r; if (Array.isArray(e)) { const i = e.map(s => M0(t, s, n)); r = Promise.all(i) } else if (typeof e == "string") r = M0(t, e, n); else { const i = typeof e == "function" ? nd(t, e, n.custom) : e; r = Promise.all(WT(t, i, n)) } return r.then(() => { t.notify("AnimationComplete", e) }) } const X8 = em.length; function KT(t) { if (!t) return; if (!t.isControllingVariants) { const n = t.parent ? KT(t.parent) || {} : {}; return t.props.initial !== void 0 && (n.initial = t.props.initial), n } const e = {}; for (let n = 0; n < X8; n++) { const r = em[n], i = t.props[r]; (Hl(i) || i === !1) && (e[r] = i) } return e } const Z8 = [...$v].reverse(), Y8 = $v.length; function Q8(t) { return e => Promise.all(e.map(({ animation: n, options: r }) => G8(t, n, r))) } function J8(t) { let e = Q8(t), n = $w(), r = !0; const i = c => (f, h) => { var v; const m = nd(t, h, c === "exit" ? (v = t.presenceContext) === null || v === void 0 ? void 0 : v.custom : void 0); if (m) { const { transition: g, transitionEnd: S, ...b } = m; f = { ...f, ...b, ...S } } return f }; function s(c) { e = c(t) } function a(c) { const { props: f } = t, h = KT(t.parent) || {}, v = [], m = new Set; let g = {}, S = 1 / 0; for (let P = 0; P < Y8; P++) { const C = Z8[P], F = n[C], A = f[C] !== void 0 ? f[C] : h[C], N = Hl(A), D = C === c ? F.isActive : null; D === !1 && (S = P); let V = A === h[C] && A !== f[C] && N; if (V && r && t.manuallyAnimateOnMount && (V = !1), F.protectedKeys = { ...g }, !F.isActive && D === null || !A && !F.prevProp || td(A) || typeof A == "boolean") continue; const B = _8(F.prevProp, A); let I = B || C === c && F.isActive && !V && N || P > S && N, Y = !1; const Z = Array.isArray(A) ? A : [A]; let ie = Z.reduce(i(C), {}); D === !1 && (ie = {}); const { prevResolvedValues: se = {} } = F, q = { ...se, ...ie }, ue = _ => { I = !0, m.has(_) && (Y = !0, m.delete(_)), F.needsAnimating[_] = !0; const Q = t.getValue(_); Q && (Q.liveStyle = !1) }; for (const _ in q) { const Q = ie[_], le = se[_]; if (g.hasOwnProperty(_)) continue; let ce = !1; b0(Q) && b0(le) ? ce = !eT(Q, le) : ce = Q !== le, ce ? Q != null ? ue(_) : m.add(_) : Q !== void 0 && m.has(_) ? ue(_) : F.protectedKeys[_] = !0 } F.prevProp = A, F.prevResolvedValues = ie, F.isActive && (g = { ...g, ...ie }), r && t.blockInitialAnimation && (I = !1), I && (!(V && B) || Y) && v.push(...Z.map(_ => ({ animation: _, options: { type: C } }))) } if (m.size) { const P = {}; m.forEach(C => { const F = t.getBaseTarget(C), A = t.getValue(C); A && (A.liveStyle = !0), P[C] = F ?? null }), v.push({ animation: P }) } let b = !!v.length; return r && (f.initial === !1 || f.initial === f.animate) && !t.manuallyAnimateOnMount && (b = !1), r = !1, b ? e(v) : Promise.resolve() } function u(c, f) { var h; if (n[c].isActive === f) return Promise.resolve(); (h = t.variantChildren) === null || h === void 0 || h.forEach(m => { var g; return (g = m.animationState) === null || g === void 0 ? void 0 : g.setActive(c, f) }), n[c].isActive = f; const v = a(c); for (const m in n) n[m].protectedKeys = {}; return v } return { animateChanges: a, setActive: u, setAnimateFunction: s, getState: () => n, reset: () => { n = $w(), r = !0 } } } function _8(t, e) { return typeof e == "string" ? e !== t : Array.isArray(e) ? !eT(e, t) : !1 } function Uo(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function $w() { return { animate: Uo(!0), whileInView: Uo(), whileHover: Uo(), whileTap: Uo(), whileDrag: Uo(), whileFocus: Uo(), exit: Uo() } } class Po { constructor(e) { this.isMounted = !1, this.node = e } update() { } } class $8 extends Po { constructor(e) { super(e), e.animationState || (e.animationState = J8(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); td(e) && (this.unmountControls = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; e !== n && this.updateAnimationControlsSubscription() } unmount() { var e; this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this) } } let eN = 0; class tN extends Po { constructor() { super(...arguments), this.id = eN++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === r) return; const i = this.node.animationState.setActive("exit", !e); n && !e && i.then(() => n(this.id)) } mount() { const { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } } const nN = { animation: { Feature: $8 }, exit: { Feature: tN } }, Hr = { x: !1, y: !1 }; function HT() { return Hr.x || Hr.y } function rN(t) { return t === "x" || t === "y" ? Hr[t] ? null : (Hr[t] = !0, () => { Hr[t] = !1 }) : Hr.x || Hr.y ? null : (Hr.x = Hr.y = !0, () => { Hr.x = Hr.y = !1 }) } const wm = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1; function hu(t) { return { point: { x: t.pageX, y: t.pageY } } } const iN = t => e => wm(e) && t(e, hu(e)); function Xl(t, e, n, r = { passive: !0 }) { return t.addEventListener(e, n, r), () => t.removeEventListener(e, n) } function Fl(t, e, n, r) { return Xl(t, e, iN(n), r) } const eS = (t, e) => Math.abs(t - e); function oN(t, e) { const n = eS(t.x, e.x), r = eS(t.y, e.y); return Math.sqrt(n ** 2 + r ** 2) } class qT { constructor(e, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: s = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const v = Np(this.lastMoveEventInfo, this.history), m = this.startEvent !== null, g = oN(v.offset, { x: 0, y: 0 }) >= 3; if (!m && !g) return; const { point: S } = v, { timestamp: b } = on; this.history.push({ ...S, timestamp: b }); const { onStart: P, onMove: C } = this.handlers; m || (P && P(this.lastMoveEvent, v), this.startEvent = this.lastMoveEvent), C && C(this.lastMoveEvent, v) }, this.handlePointerMove = (v, m) => { this.lastMoveEvent = v, this.lastMoveEventInfo = Vp(m, this.transformPagePoint), bt.update(this.updatePoint, !0) }, this.handlePointerUp = (v, m) => { this.end(); const { onEnd: g, onSessionEnd: S, resumeAnimation: b } = this.handlers; if (this.dragSnapToOrigin && b && b(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const P = Np(v.type === "pointercancel" ? this.lastMoveEventInfo : Vp(m, this.transformPagePoint), this.history); this.startEvent && g && g(v, P), S && S(v, P) }, !wm(e)) return; this.dragSnapToOrigin = s, this.handlers = n, this.transformPagePoint = r, this.contextWindow = i || window; const a = hu(e), u = Vp(a, this.transformPagePoint), { point: c } = u, { timestamp: f } = on; this.history = [{ ...c, timestamp: f }]; const { onSessionStart: h } = n; h && h(e, Np(u, this.history)), this.removeListeners = du(Fl(this.contextWindow, "pointermove", this.handlePointerMove), Fl(this.contextWindow, "pointerup", this.handlePointerUp), Fl(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), ai(this.updatePoint) } } function Vp(t, e) { return e ? { point: e(t.point) } : t } function tS(t, e) { return { x: t.x - e.x, y: t.y - e.y } } function Np({ point: t }, e) { return { point: t, delta: tS(t, GT(e)), offset: tS(t, sN(e)), velocity: aN(e, .1) } } function sN(t) { return t[0] } function GT(t) { return t[t.length - 1] } function aN(t, e) { if (t.length < 2) return { x: 0, y: 0 }; let n = t.length - 1, r = null; const i = GT(t); for (; n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > Ei(e)));)n--; if (!r) return { x: 0, y: 0 }; const s = Fi(i.timestamp - r.timestamp); if (s === 0) return { x: 0, y: 0 }; const a = { x: (i.x - r.x) / s, y: (i.y - r.y) / s }; return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a } function Gs(t) { return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } const XT = 1e-4, lN = 1 - XT, uN = 1 + XT, ZT = .01, cN = 0 - ZT, fN = 0 + ZT; function ur(t) { return t.max - t.min } function dN(t, e, n) { return Math.abs(t - e) <= n } function nS(t, e, n, r = .5) { t.origin = r, t.originPoint = Lt(e.min, e.max, t.origin), t.scale = ur(n) / ur(e), t.translate = Lt(n.min, n.max, t.origin) - t.originPoint, (t.scale >= lN && t.scale <= uN || isNaN(t.scale)) && (t.scale = 1), (t.translate >= cN && t.translate <= fN || isNaN(t.translate)) && (t.translate = 0) } function Rl(t, e, n, r) { nS(t.x, e.x, n.x, r ? r.originX : void 0), nS(t.y, e.y, n.y, r ? r.originY : void 0) } function rS(t, e, n) { t.min = n.min + e.min, t.max = t.min + ur(e) } function hN(t, e, n) { rS(t.x, e.x, n.x), rS(t.y, e.y, n.y) } function iS(t, e, n) { t.min = e.min - n.min, t.max = t.min + ur(e) } function Dl(t, e, n) { iS(t.x, e.x, n.x), iS(t.y, e.y, n.y) } function pN(t, { min: e, max: n }, r) { return e !== void 0 && t < e ? t = r ? Lt(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? Lt(n, t, r.max) : Math.min(t, n)), t } function oS(t, e, n) { return { min: e !== void 0 ? t.min + e : void 0, max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0 } } function vN(t, { top: e, left: n, bottom: r, right: i }) { return { x: oS(t.x, n, i), y: oS(t.y, e, r) } } function sS(t, e) { let n = e.min - t.min, r = e.max - t.max; return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), { min: n, max: r } } function mN(t, e) { return { x: sS(t.x, e.x), y: sS(t.y, e.y) } } function gN(t, e) { let n = .5; const r = ur(t), i = ur(e); return i > r ? n = $o(e.min, e.max - r, t.min) : r > i && (n = $o(t.min, t.max - i, e.min)), Di(0, 1, n) } function yN(t, e) { const n = {}; return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n } const V0 = .35; function xN(t = V0) { return t === !1 ? t = 0 : t === !0 && (t = V0), { x: aS(t, "left", "right"), y: aS(t, "top", "bottom") } } function aS(t, e, n) { return { min: lS(t, e), max: lS(t, n) } } function lS(t, e) { return typeof t == "number" ? t : t[e] || 0 } const uS = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Xs = () => ({ x: uS(), y: uS() }), cS = () => ({ min: 0, max: 0 }), Yt = () => ({ x: cS(), y: cS() }); function Pr(t) { return [t("x"), t("y")] } function YT({ top: t, left: e, right: n, bottom: r }) { return { x: { min: e, max: n }, y: { min: t, max: r } } } function wN({ x: t, y: e }) { return { top: e.min, right: t.max, bottom: e.max, left: t.min } } function SN(t, e) { if (!e) return t; const n = e({ x: t.left, y: t.top }), r = e({ x: t.right, y: t.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function Bp(t) { return t === void 0 || t === 1 } function N0({ scale: t, scaleX: e, scaleY: n }) { return !Bp(t) || !Bp(e) || !Bp(n) } function qo(t) { return N0(t) || QT(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function QT(t) { return fS(t.x) || fS(t.y) } function fS(t) { return t && t !== "0%" } function kf(t, e, n) { const r = t - n, i = e * r; return n + i } function dS(t, e, n, r, i) { return i !== void 0 && (t = kf(t, i, r)), kf(t, n, r) + e } function B0(t, e = 0, n = 1, r, i) { t.min = dS(t.min, e, n, r, i), t.max = dS(t.max, e, n, r, i) } function JT(t, { x: e, y: n }) { B0(t.x, e.translate, e.scale, e.originPoint), B0(t.y, n.translate, n.scale, n.originPoint) } const hS = .999999999999, pS = 1.0000000000001; function bN(t, e, n, r = !1) { const i = n.length; if (!i) return; e.x = e.y = 1; let s, a; for (let u = 0; u < i; u++) { s = n[u], a = s.projectionDelta; const { visualElement: c } = s.options; c && c.props.style && c.props.style.display === "contents" || (r && s.options.layoutScroll && s.scroll && s !== s.root && Ys(t, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), a && (e.x *= a.x.scale, e.y *= a.y.scale, JT(t, a)), r && qo(s.latestValues) && Ys(t, s.latestValues)) } e.x < pS && e.x > hS && (e.x = 1), e.y < pS && e.y > hS && (e.y = 1) } function Zs(t, e) { t.min = t.min + e, t.max = t.max + e } function vS(t, e, n, r, i = .5) { const s = Lt(t.min, t.max, i); B0(t, e, n, s, r) } function Ys(t, e) { vS(t.x, e.x, e.scaleX, e.scale, e.originX), vS(t.y, e.y, e.scaleY, e.scale, e.originY) } function _T(t, e) { return YT(SN(t.getBoundingClientRect(), e)) } function CN(t, e, n) { const r = _T(t, n), { scroll: i } = e; return i && (Zs(r.x, i.offset.x), Zs(r.y, i.offset.y)), r } const $T = ({ current: t }) => t ? t.ownerDocument.defaultView : null, PN = new WeakMap; class TN { constructor(e) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Yt(), this.visualElement = e } start(e, { snapToCursor: n = !1 } = {}) { const { presenceContext: r } = this.visualElement; if (r && r.isPresent === !1) return; const i = h => { const { dragSnapToOrigin: v } = this.getProps(); v ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(hu(h).point) }, s = (h, v) => { const { drag: m, dragPropagation: g, onDragStart: S } = this.getProps(); if (m && !g && (this.openDragLock && this.openDragLock(), this.openDragLock = rN(m), !this.openDragLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Pr(P => { let C = this.getAxisMotionValue(P).get() || 0; if (ri.test(C)) { const { projection: F } = this.visualElement; if (F && F.layout) { const A = F.layout.layoutBox[P]; A && (C = ur(A) * (parseFloat(C) / 100)) } } this.originPoint[P] = C }), S && bt.postRender(() => S(h, v)), O0(this.visualElement, "transform"); const { animationState: b } = this.visualElement; b && b.setActive("whileDrag", !0) }, a = (h, v) => { const { dragPropagation: m, dragDirectionLock: g, onDirectionLock: S, onDrag: b } = this.getProps(); if (!m && !this.openDragLock) return; const { offset: P } = v; if (g && this.currentDirection === null) { this.currentDirection = kN(P), this.currentDirection !== null && S && S(this.currentDirection); return } this.updateAxis("x", v.point, P), this.updateAxis("y", v.point, P), this.visualElement.render(), b && b(h, v) }, u = (h, v) => this.stop(h, v), c = () => Pr(h => { var v; return this.getAnimationState(h) === "paused" && ((v = this.getAxisMotionValue(h).animation) === null || v === void 0 ? void 0 : v.play()) }), { dragSnapToOrigin: f } = this.getProps(); this.panSession = new qT(e, { onSessionStart: i, onStart: s, onMove: a, onSessionEnd: u, resumeAnimation: c }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: f, contextWindow: $T(this.visualElement) }) } stop(e, n) { const r = this.isDragging; if (this.cancel(), !r) return; const { velocity: i } = n; this.startAnimation(i); const { onDragEnd: s } = this.getProps(); s && bt.postRender(() => s(e, n)) } cancel() { this.isDragging = !1; const { projection: e, animationState: n } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } updateAxis(e, n, r) { const { drag: i } = this.getProps(); if (!r || !Lc(e, i, this.currentDirection)) return; const s = this.getAxisMotionValue(e); let a = this.originPoint[e] + r[e]; this.constraints && this.constraints[e] && (a = pN(a, this.constraints[e], this.elastic[e])), s.set(a) } resolveConstraints() { var e; const { dragConstraints: n, dragElastic: r } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s = this.constraints; n && Gs(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && i ? this.constraints = vN(i.layoutBox, n) : this.constraints = !1, this.elastic = xN(r), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Pr(a => { this.constraints !== !1 && this.getAxisMotionValue(a) && (this.constraints[a] = yN(i.layoutBox[a], this.constraints[a])) }) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps(); if (!e || !Gs(e)) return !1; const r = e.current, { projection: i } = this.visualElement; if (!i || !i.layout) return !1; const s = CN(r, i.root, this.visualElement.getTransformPagePoint()); let a = mN(i.layout.layoutBox, s); if (n) { const u = n(wN(a)); this.hasMutatedConstraints = !!u, u && (a = YT(u)) } return a } startAnimation(e) { const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: s, dragSnapToOrigin: a, onDragTransitionEnd: u } = this.getProps(), c = this.constraints || {}, f = Pr(h => { if (!Lc(h, n, this.currentDirection)) return; let v = c[h] || {}; a && (v = { min: 0, max: 0 }); const m = i ? 200 : 1e6, g = i ? 40 : 1e7, S = { type: "inertia", velocity: r ? e[h] : 0, bounceStiffness: m, bounceDamping: g, timeConstant: 750, restDelta: 1, restSpeed: 10, ...s, ...v }; return this.startAxisValueAnimation(h, S) }); return Promise.all(f).then(u) } startAxisValueAnimation(e, n) { const r = this.getAxisMotionValue(e); return O0(this.visualElement, e), r.start(vm(e, r, 0, n, this.visualElement, !1)) } stopAnimation() { Pr(e => this.getAxisMotionValue(e).stop()) } pauseAnimation() { Pr(e => { var n; return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.pause() }) } getAnimationState(e) { var n; return (n = this.getAxisMotionValue(e).animation) === null || n === void 0 ? void 0 : n.state } getAxisMotionValue(e) { const n = `_drag${e.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n]; return i || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0) } snapToCursor(e) { Pr(n => { const { drag: r } = this.getProps(); if (!Lc(n, r, this.currentDirection)) return; const { projection: i } = this.visualElement, s = this.getAxisMotionValue(n); if (i && i.layout) { const { min: a, max: u } = i.layout.layoutBox[n]; s.set(e[n] - Lt(a, u, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!Gs(n) || !r || !this.constraints) return; this.stopAnimation(); const i = { x: 0, y: 0 }; Pr(a => { const u = this.getAxisMotionValue(a); if (u && this.constraints !== !1) { const c = u.get(); i[a] = gN({ min: c, max: c }, this.constraints[a]) } }); const { transformTemplate: s } = this.visualElement.getProps(); this.visualElement.current.style.transform = s ? s({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Pr(a => { if (!Lc(a, e, null)) return; const u = this.getAxisMotionValue(a), { min: c, max: f } = this.constraints[a]; u.set(Lt(c, f, i[a])) }) } addListeners() { if (!this.visualElement.current) return; PN.set(this.visualElement, this); const e = this.visualElement.current, n = Fl(e, "pointerdown", c => { const { drag: f, dragListener: h = !0 } = this.getProps(); f && h && this.start(c) }), r = () => { const { dragConstraints: c } = this.getProps(); Gs(c) && c.current && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, s = i.addEventListener("measure", r); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), bt.read(r); const a = Xl(window, "resize", () => this.scalePositionWithinConstraints()), u = i.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: f }) => { this.isDragging && f && (Pr(h => { const v = this.getAxisMotionValue(h); v && (this.originPoint[h] += c[h].translate, v.set(v.get() + c[h].translate)) }), this.visualElement.render()) }); return () => { a(), n(), s(), u && u() } } getProps() { const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: s = !1, dragElastic: a = V0, dragMomentum: u = !0 } = e; return { ...e, drag: n, dragDirectionLock: r, dragPropagation: i, dragConstraints: s, dragElastic: a, dragMomentum: u } } } function Lc(t, e, n) { return (e === !0 || e === t) && (n === null || n === t) } function kN(t, e = 10) { let n = null; return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n } class AN extends Po { constructor(e) { super(e), this.removeGroupControls = Ln, this.removeListeners = Ln, this.controls = new TN(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Ln } unmount() { this.removeGroupControls(), this.removeListeners() } } const mS = t => (e, n) => { t && bt.postRender(() => t(e, n)) }; class EN extends Po { constructor() { super(...arguments), this.removePointerDownListener = Ln } onPointerDown(e) { this.session = new qT(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: $T(this.node) }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps(); return { onSessionStart: mS(e), onStart: mS(n), onMove: r, onEnd: (s, a) => { delete this.session, i && bt.postRender(() => i(s, a)) } } } mount() { this.removePointerDownListener = Fl(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const Sm = j.createContext(null); function FN() { const t = j.useContext(Sm); if (t === null) return [!0, null]; const { isPresent: e, onExitComplete: n, register: r } = t, i = j.useId(); j.useEffect(() => r(i), []); const s = j.useCallback(() => n && n(i), [i, n]); return !e && n ? [!1, s] : [!0] } const e2 = j.createContext({}), t2 = j.createContext({}), Qc = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function gS(t, e) { return e.max === e.min ? 0 : t / (e.max - e.min) * 100 } const ol = { correct: (t, e) => { if (!e.target) return t; if (typeof t == "string") if (He.test(t)) t = parseFloat(t); else return t; const n = gS(t, e.target.x), r = gS(t, e.target.y); return `${n}% ${r}%` } }, RN = { correct: (t, { treeScale: e, projectionDelta: n }) => { const r = t, i = mo.parse(t); if (i.length > 5) return r; const s = mo.createTransformer(t), a = typeof i[0] != "number" ? 1 : 0, u = n.x.scale * e.x, c = n.y.scale * e.y; i[0 + a] /= u, i[1 + a] /= c; const f = Lt(u, c, .5); return typeof i[2 + a] == "number" && (i[2 + a] /= f), typeof i[3 + a] == "number" && (i[3 + a] /= f), s(i) } }, Af = {}; function DN(t) { Object.assign(Af, t) } const { schedule: bm, cancel: fz } = tT(queueMicrotask, !1); class ON extends j.Component { componentDidMount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: s } = e; DN(MN), s && (n.group && n.group.add(s), r && r.register && i && r.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => { this.safeToRemove() }), s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })), Qc.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: n, visualElement: r, drag: i, isPresent: s } = this.props, a = r.projection; return a && (a.isPresent = s, i || e.layoutDependency !== n || n === void 0 ? a.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? a.promote() : a.relegate() || bt.postRender(() => { const u = a.getStack(); (!u || !u.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), bm.postRender(() => { !e.currentAnimation && e.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = e; i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } } function n2(t) { const [e, n] = FN(), r = j.useContext(e2); return De.jsx(ON, { ...t, layoutGroup: r, switchLayoutGroup: j.useContext(t2), isPresent: e, safeToRemove: n }) } const MN = { borderRadius: { ...ol, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: ol, borderTopRightRadius: ol, borderBottomLeftRadius: ol, borderBottomRightRadius: ol, boxShadow: RN }, r2 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], VN = r2.length, yS = t => typeof t == "string" ? parseFloat(t) : t, xS = t => typeof t == "number" || He.test(t); function NN(t, e, n, r, i, s) { i ? (t.opacity = Lt(0, n.opacity !== void 0 ? n.opacity : 1, BN(r)), t.opacityExit = Lt(e.opacity !== void 0 ? e.opacity : 1, 0, LN(r))) : s && (t.opacity = Lt(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r)); for (let a = 0; a < VN; a++) { const u = `border${r2[a]}Radius`; let c = wS(e, u), f = wS(n, u); if (c === void 0 && f === void 0) continue; c || (c = 0), f || (f = 0), c === 0 || f === 0 || xS(c) === xS(f) ? (t[u] = Math.max(Lt(yS(c), yS(f), r), 0), (ri.test(f) || ri.test(c)) && (t[u] += "%")) : t[u] = f } (e.rotate || n.rotate) && (t.rotate = Lt(e.rotate || 0, n.rotate || 0, r)) } function wS(t, e) { return t[e] !== void 0 ? t[e] : t.borderRadius } const BN = i2(0, .5, lT), LN = i2(.5, .95, Ln); function i2(t, e, n) { return r => r < t ? 0 : r > e ? 1 : n($o(t, e, r)) } function SS(t, e) { t.min = e.min, t.max = e.max } function Sr(t, e) { SS(t.x, e.x), SS(t.y, e.y) } function bS(t, e) { t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin } function CS(t, e, n, r, i) { return t -= e, t = kf(t, 1 / n, r), i !== void 0 && (t = kf(t, 1 / i, r)), t } function jN(t, e = 0, n = 1, r = .5, i, s = t, a = t) { if (ri.test(e) && (e = parseFloat(e), e = Lt(a.min, a.max, e / 100) - a.min), typeof e != "number") return; let u = Lt(s.min, s.max, r); t === s && (u -= e), t.min = CS(t.min, e, n, u, i), t.max = CS(t.max, e, n, u, i) } function PS(t, e, [n, r, i], s, a) { jN(t, e[n], e[r], e[i], e.scale, s, a) } const IN = ["x", "scaleX", "originX"], zN = ["y", "scaleY", "originY"]; function TS(t, e, n, r) { PS(t.x, e, IN, n ? n.x : void 0, r ? r.x : void 0), PS(t.y, e, zN, n ? n.y : void 0, r ? r.y : void 0) } function kS(t) { return t.translate === 0 && t.scale === 1 } function o2(t) { return kS(t.x) && kS(t.y) } function AS(t, e) { return t.min === e.min && t.max === e.max } function UN(t, e) { return AS(t.x, e.x) && AS(t.y, e.y) } function ES(t, e) { return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max) } function s2(t, e) { return ES(t.x, e.x) && ES(t.y, e.y) } function FS(t) { return ur(t.x) / ur(t.y) } function RS(t, e) { return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint } class WN { constructor() { this.members = [] } add(e) { mm(this.members, e), e.scheduleRender() } remove(e) { if (gm(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(e) { const n = this.members.findIndex(i => e === i); if (n === 0) return !1; let r; for (let i = n; i >= 0; i--) { const s = this.members[i]; if (s.isPresent !== !1) { r = s; break } } return r ? (this.promote(r), !0) : !1 } promote(e, n) { const r = this.lead; if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) { r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: i } = e.options; i === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(e => { const { options: n, resumingFrom: r } = e; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function KN(t, e, n) { let r = ""; const i = t.x.translate / e.x, s = t.y.translate / e.y, a = (n == null ? void 0 : n.z) || 0; if ((i || s || a) && (r = `translate3d(${i}px, ${s}px, ${a}px) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `), n) { const { transformPerspective: f, rotate: h, rotateX: v, rotateY: m, skewX: g, skewY: S } = n; f && (r = `perspective(${f}px) ${r}`), h && (r += `rotate(${h}deg) `), v && (r += `rotateX(${v}deg) `), m && (r += `rotateY(${m}deg) `), g && (r += `skewX(${g}deg) `), S && (r += `skewY(${S}deg) `) } const u = t.x.scale * e.x, c = t.y.scale * e.y; return (u !== 1 || c !== 1) && (r += `scale(${u}, ${c})`), r || "none" } const HN = (t, e) => t.depth - e.depth; class qN { constructor() { this.children = [], this.isDirty = !1 } add(e) { mm(this.children, e), this.isDirty = !0 } remove(e) { gm(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(HN), this.isDirty = !1, this.children.forEach(e) } } function Jc(t) { const e = pn(t) ? t.get() : t; return N8(e) ? e.toValue() : e } function GN(t, e) { const n = ii.now(), r = ({ timestamp: i }) => { const s = i - n; s >= e && (ai(r), t(s - e)) }; return bt.read(r, !0), () => ai(r) } function XN(t) { return t instanceof SVGElement && t.tagName !== "svg" } function ZN(t, e, n) { const r = pn(t) ? t : ei(t); return r.start(vm("", r, e, n)), r.animation } const Go = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, gl = typeof window < "u" && window.MotionDebug !== void 0, Lp = ["", "X", "Y", "Z"], YN = { visibility: "hidden" }, DS = 1e3; let QN = 0; function jp(t, e, n, r) { const { latestValues: i } = e; i[t] && (n[t] = i[t], e.setStaticValue(t, 0), r && (r[t] = 0)) } function a2(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; const { visualElement: e } = t.options; if (!e) return; const n = UT(e); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: i, layoutId: s } = t.options; window.MotionCancelOptimisedAnimation(n, "transform", bt, !(i || s)) } const { parent: r } = t; r && !r.hasCheckedOptimisedAppear && a2(r) } function l2({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(a = {}, u = e == null ? void 0 : e()) { this.id = QN++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, gl && (Go.totalNodes = Go.resolvedTargetDeltas = Go.recalculatedProjection = 0), this.nodes.forEach($N), this.nodes.forEach(iB), this.nodes.forEach(oB), this.nodes.forEach(eB), gl && window.MotionDebug.record(Go) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = a, this.root = u ? u.root || u : this, this.path = u ? [...u.path, u] : [], this.parent = u, this.depth = u ? u.depth + 1 : 0; for (let c = 0; c < this.path.length; c++)this.path[c].shouldResetTransform = !0; this.root === this && (this.nodes = new qN) } addEventListener(a, u) { return this.eventHandlers.has(a) || this.eventHandlers.set(a, new ym), this.eventHandlers.get(a).add(u) } notifyListeners(a, ...u) { const c = this.eventHandlers.get(a); c && c.notify(...u) } hasListeners(a) { return this.eventHandlers.has(a) } mount(a, u = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = XN(a), this.instance = a; const { layoutId: c, layout: f, visualElement: h } = this.options; if (h && !h.current && h.mount(a), this.root.nodes.add(this), this.parent && this.parent.children.add(this), u && (f || c) && (this.isLayoutDirty = !0), t) { let v; const m = () => this.root.updateBlockedByResize = !1; t(a, () => { this.root.updateBlockedByResize = !0, v && v(), v = GN(m, 250), Qc.hasAnimatedSinceResize && (Qc.hasAnimatedSinceResize = !1, this.nodes.forEach(MS)) }) } c && this.root.registerSharedNode(c, this), this.options.animate !== !1 && h && (c || f) && this.addEventListener("didUpdate", ({ delta: v, hasLayoutChanged: m, hasRelativeTargetChanged: g, layout: S }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const b = this.options.transition || h.getDefaultTransition() || cB, { onLayoutAnimationStart: P, onLayoutAnimationComplete: C } = h.getProps(), F = !this.targetLayout || !s2(this.targetLayout, S) || g, A = !m && g; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || A || m && (F || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(v, A); const N = { ...tm(b, "layout"), onPlay: P, onComplete: C }; (h.shouldReduceMotion || this.options.layoutRoot) && (N.delay = 0, N.type = !1), this.startAnimation(N) } else m || MS(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = S }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const a = this.getStack(); a && a.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, ai(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(sB), this.animationId++) } getTransformTemplate() { const { visualElement: a } = this.options; return a && a.getProps().transformTemplate } willUpdate(a = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && a2(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let h = 0; h < this.path.length; h++) { const v = this.path[h]; v.shouldResetTransform = !0, v.updateScroll("snapshot"), v.options.layoutRoot && v.willUpdate(!1) } const { layoutId: u, layout: c } = this.options; if (u === void 0 && !c) return; const f = this.getTransformTemplate(); this.prevTransformTemplateValue = f ? f(this.latestValues, "") : void 0, this.updateSnapshot(), a && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(OS); return } this.isUpdating || this.nodes.forEach(nB), this.isUpdating = !1, this.nodes.forEach(rB), this.nodes.forEach(JN), this.nodes.forEach(_N), this.clearAllSnapshots(); const u = ii.now(); on.delta = Di(0, 1e3 / 60, u - on.timestamp), on.timestamp = u, on.isProcessing = !0, Fp.update.process(on), Fp.preRender.process(on), Fp.render.process(on), on.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, bm.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(tB), this.sharedNodes.forEach(aB) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, bt.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { bt.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let c = 0; c < this.path.length; c++)this.path[c].updateScroll(); const a = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Yt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: u } = this.options; u && u.notify("LayoutMeasure", this.layout.layoutBox, a ? a.layoutBox : void 0) } updateScroll(a = "measure") { let u = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === a && (u = !1), u) { const c = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: a, isRoot: c, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : c } } } resetTransform() { if (!i) return; const a = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, u = this.projectionDelta && !o2(this.projectionDelta), c = this.getTransformTemplate(), f = c ? c(this.latestValues, "") : void 0, h = f !== this.prevTransformTemplateValue; a && (u || qo(this.latestValues) || h) && (i(this.instance, f), this.shouldResetTransform = !1, this.scheduleRender()) } measure(a = !0) { const u = this.measurePageBox(); let c = this.removeElementScroll(u); return a && (c = this.removeTransform(c)), fB(c), { animationId: this.root.animationId, measuredBox: u, layoutBox: c, latestValues: {}, source: this.id } } measurePageBox() { var a; const { visualElement: u } = this.options; if (!u) return Yt(); const c = u.measureViewportBox(); if (!(((a = this.scroll) === null || a === void 0 ? void 0 : a.wasRoot) || this.path.some(dB))) { const { scroll: h } = this.root; h && (Zs(c.x, h.offset.x), Zs(c.y, h.offset.y)) } return c } removeElementScroll(a) { var u; const c = Yt(); if (Sr(c, a), !((u = this.scroll) === null || u === void 0) && u.wasRoot) return c; for (let f = 0; f < this.path.length; f++) { const h = this.path[f], { scroll: v, options: m } = h; h !== this.root && v && m.layoutScroll && (v.wasRoot && Sr(c, a), Zs(c.x, v.offset.x), Zs(c.y, v.offset.y)) } return c } applyTransform(a, u = !1) { const c = Yt(); Sr(c, a); for (let f = 0; f < this.path.length; f++) { const h = this.path[f]; !u && h.options.layoutScroll && h.scroll && h !== h.root && Ys(c, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }), qo(h.latestValues) && Ys(c, h.latestValues) } return qo(this.latestValues) && Ys(c, this.latestValues), c } removeTransform(a) { const u = Yt(); Sr(u, a); for (let c = 0; c < this.path.length; c++) { const f = this.path[c]; if (!f.instance || !qo(f.latestValues)) continue; N0(f.latestValues) && f.updateSnapshot(); const h = Yt(), v = f.measurePageBox(); Sr(h, v), TS(u, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, h) } return qo(this.latestValues) && TS(u, this.latestValues), u } setTargetDelta(a) { this.targetDelta = a, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(a) { this.options = { ...this.options, ...a, crossfade: a.crossfade !== void 0 ? a.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== on.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(a = !1) { var u; const c = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = c.isSharedProjectionDirty); const f = !!this.resumingFrom || this !== c; if (!(a || f && this.isSharedProjectionDirty || this.isProjectionDirty || !((u = this.parent) === null || u === void 0) && u.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: v, layoutId: m } = this.options; if (!(!this.layout || !(v || m))) { if (this.resolvedRelativeTargetAt = on.timestamp, !this.targetDelta && !this.relativeTarget) { const g = this.getClosestProjectingParent(); g && g.layout && this.animationProgress !== 1 ? (this.relativeParent = g, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Yt(), this.relativeTargetOrigin = Yt(), Dl(this.relativeTargetOrigin, this.layout.layoutBox, g.layout.layoutBox), Sr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Yt(), this.targetWithTransforms = Yt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), hN(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Sr(this.target, this.layout.layoutBox), JT(this.target, this.targetDelta)) : Sr(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const g = this.getClosestProjectingParent(); g && !!g.resumingFrom == !!this.resumingFrom && !g.options.layoutScroll && g.target && this.animationProgress !== 1 ? (this.relativeParent = g, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Yt(), this.relativeTargetOrigin = Yt(), Dl(this.relativeTargetOrigin, this.target, g.target), Sr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } gl && Go.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || N0(this.parent.latestValues) || QT(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var a; const u = this.getLead(), c = !!this.resumingFrom || this !== u; let f = !0; if ((this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty) && (f = !1), c && (this.isSharedProjectionDirty || this.isTransformDirty) && (f = !1), this.resolvedRelativeTargetAt === on.timestamp && (f = !1), f) return; const { layout: h, layoutId: v } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || v)) return; Sr(this.layoutCorrected, this.layout.layoutBox); const m = this.treeScale.x, g = this.treeScale.y; bN(this.layoutCorrected, this.treeScale, this.path, c), u.layout && !u.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (u.target = u.layout.layoutBox, u.targetWithTransforms = Yt()); const { target: S } = u; if (!S) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (bS(this.prevProjectionDelta.x, this.projectionDelta.x), bS(this.prevProjectionDelta.y, this.projectionDelta.y)), Rl(this.projectionDelta, this.layoutCorrected, S, this.latestValues), (this.treeScale.x !== m || this.treeScale.y !== g || !RS(this.projectionDelta.x, this.prevProjectionDelta.x) || !RS(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", S)), gl && Go.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(a = !0) { var u; if ((u = this.options.visualElement) === null || u === void 0 || u.scheduleRender(), a) { const c = this.getStack(); c && c.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Xs(), this.projectionDelta = Xs(), this.projectionDeltaWithTransform = Xs() } setAnimationOrigin(a, u = !1) { const c = this.snapshot, f = c ? c.latestValues : {}, h = { ...this.latestValues }, v = Xs(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !u; const m = Yt(), g = c ? c.source : void 0, S = this.layout ? this.layout.source : void 0, b = g !== S, P = this.getStack(), C = !P || P.members.length <= 1, F = !!(b && !C && this.options.crossfade === !0 && !this.path.some(uB)); this.animationProgress = 0; let A; this.mixTargetDelta = N => { const D = N / 1e3; VS(v.x, a.x, D), VS(v.y, a.y, D), this.setTargetDelta(v), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Dl(m, this.layout.layoutBox, this.relativeParent.layout.layoutBox), lB(this.relativeTarget, this.relativeTargetOrigin, m, D), A && UN(this.relativeTarget, A) && (this.isProjectionDirty = !1), A || (A = Yt()), Sr(A, this.relativeTarget)), b && (this.animationValues = h, NN(h, f, this.latestValues, D, F, C)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = D }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(a) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (ai(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = bt.update(() => { Qc.hasAnimatedSinceResize = !0, this.currentAnimation = ZN(0, DS, { ...a, onUpdate: u => { this.mixTargetDelta(u), a.onUpdate && a.onUpdate(u) }, onComplete: () => { a.onComplete && a.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const a = this.getStack(); a && a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(DS), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const a = this.getLead(); let { targetWithTransforms: u, target: c, layout: f, latestValues: h } = a; if (!(!u || !c || !f)) { if (this !== a && this.layout && f && u2(this.options.animationType, this.layout.layoutBox, f.layoutBox)) { c = this.target || Yt(); const v = ur(this.layout.layoutBox.x); c.x.min = a.target.x.min, c.x.max = c.x.min + v; const m = ur(this.layout.layoutBox.y); c.y.min = a.target.y.min, c.y.max = c.y.min + m } Sr(u, c), Ys(u, h), Rl(this.projectionDeltaWithTransform, this.layoutCorrected, u, h) } } registerSharedNode(a, u) { this.sharedNodes.has(a) || this.sharedNodes.set(a, new WN), this.sharedNodes.get(a).add(u); const f = u.options.initialPromotionConfig; u.promote({ transition: f ? f.transition : void 0, preserveFollowOpacity: f && f.shouldPreserveFollowOpacity ? f.shouldPreserveFollowOpacity(u) : void 0 }) } isLead() { const a = this.getStack(); return a ? a.lead === this : !0 } getLead() { var a; const { layoutId: u } = this.options; return u ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) || this : this } getPrevLead() { var a; const { layoutId: u } = this.options; return u ? (a = this.getStack()) === null || a === void 0 ? void 0 : a.prevLead : void 0 } getStack() { const { layoutId: a } = this.options; if (a) return this.root.sharedNodes.get(a) } promote({ needsReset: a, transition: u, preserveFollowOpacity: c } = {}) { const f = this.getStack(); f && f.promote(this, c), a && (this.projectionDelta = void 0, this.needsReset = !0), u && this.setOptions({ transition: u }) } relegate() { const a = this.getStack(); return a ? a.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: a } = this.options; if (!a) return; let u = !1; const { latestValues: c } = a; if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (u = !0), !u) return; const f = {}; c.z && jp("z", a, f, this.animationValues); for (let h = 0; h < Lp.length; h++)jp(`rotate${Lp[h]}`, a, f, this.animationValues), jp(`skew${Lp[h]}`, a, f, this.animationValues); a.render(); for (const h in f) a.setStaticValue(h, f[h]), this.animationValues && (this.animationValues[h] = f[h]); a.scheduleRender() } getProjectionStyles(a) { var u, c; if (!this.instance || this.isSVG) return; if (!this.isVisible) return YN; const f = { visibility: "" }, h = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, f.opacity = "", f.pointerEvents = Jc(a == null ? void 0 : a.pointerEvents) || "", f.transform = h ? h(this.latestValues, "") : "none", f; const v = this.getLead(); if (!this.projectionDelta || !this.layout || !v.target) { const b = {}; return this.options.layoutId && (b.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, b.pointerEvents = Jc(a == null ? void 0 : a.pointerEvents) || ""), this.hasProjected && !qo(this.latestValues) && (b.transform = h ? h({}, "") : "none", this.hasProjected = !1), b } const m = v.animationValues || v.latestValues; this.applyTransformsToTarget(), f.transform = KN(this.projectionDeltaWithTransform, this.treeScale, m), h && (f.transform = h(m, f.transform)); const { x: g, y: S } = this.projectionDelta; f.transformOrigin = `${g.origin * 100}% ${S.origin * 100}% 0`, v.animationValues ? f.opacity = v === this ? (c = (u = m.opacity) !== null && u !== void 0 ? u : this.latestValues.opacity) !== null && c !== void 0 ? c : 1 : this.preserveOpacity ? this.latestValues.opacity : m.opacityExit : f.opacity = v === this ? m.opacity !== void 0 ? m.opacity : "" : m.opacityExit !== void 0 ? m.opacityExit : 0; for (const b in Af) { if (m[b] === void 0) continue; const { correct: P, applyTo: C } = Af[b], F = f.transform === "none" ? m[b] : P(m[b], v); if (C) { const A = C.length; for (let N = 0; N < A; N++)f[C[N]] = F } else f[b] = F } return this.options.layoutId && (f.pointerEvents = v === this ? Jc(a == null ? void 0 : a.pointerEvents) || "" : "none"), f } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(a => { var u; return (u = a.currentAnimation) === null || u === void 0 ? void 0 : u.stop() }), this.root.nodes.forEach(OS), this.root.sharedNodes.clear() } } } function JN(t) { t.updateLayout() } function _N(t) { var e; const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot; if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) { const { layoutBox: r, measuredBox: i } = t.layout, { animationType: s } = t.options, a = n.source !== t.layout.source; s === "size" ? Pr(v => { const m = a ? n.measuredBox[v] : n.layoutBox[v], g = ur(m); m.min = r[v].min, m.max = m.min + g }) : u2(s, n.layoutBox, r) && Pr(v => { const m = a ? n.measuredBox[v] : n.layoutBox[v], g = ur(r[v]); m.max = m.min + g, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[v].max = t.relativeTarget[v].min + g) }); const u = Xs(); Rl(u, r, n.layoutBox); const c = Xs(); a ? Rl(c, t.applyTransform(i, !0), n.measuredBox) : Rl(c, r, n.layoutBox); const f = !o2(u); let h = !1; if (!t.resumeFrom) { const v = t.getClosestProjectingParent(); if (v && !v.resumeFrom) { const { snapshot: m, layout: g } = v; if (m && g) { const S = Yt(); Dl(S, n.layoutBox, m.layoutBox); const b = Yt(); Dl(b, r, g.layoutBox), s2(S, b) || (h = !0), v.options.layoutRoot && (t.relativeTarget = b, t.relativeTargetOrigin = S, t.relativeParent = v) } } } t.notifyListeners("didUpdate", { layout: r, snapshot: n, delta: c, layoutDelta: u, hasLayoutChanged: f, hasRelativeTargetChanged: h }) } else if (t.isLead()) { const { onExitComplete: r } = t.options; r && r() } t.options.transition = void 0 } function $N(t) { gl && Go.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function eB(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function tB(t) { t.clearSnapshot() } function OS(t) { t.clearMeasurements() } function nB(t) { t.isLayoutDirty = !1 } function rB(t) { const { visualElement: e } = t.options; e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform() } function MS(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function iB(t) { t.resolveTargetDelta() } function oB(t) { t.calcProjection() } function sB(t) { t.resetSkewAndRotation() } function aB(t) { t.removeLeadSnapshot() } function VS(t, e, n) { t.translate = Lt(e.translate, 0, n), t.scale = Lt(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint } function NS(t, e, n, r) { t.min = Lt(e.min, n.min, r), t.max = Lt(e.max, n.max, r) } function lB(t, e, n, r) { NS(t.x, e.x, n.x, r), NS(t.y, e.y, n.y, r) } function uB(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const cB = { duration: .45, ease: [.4, 0, .1, 1] }, BS = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), LS = BS("applewebkit/") && !BS("chrome/") ? Math.round : Ln; function jS(t) { t.min = LS(t.min), t.max = LS(t.max) } function fB(t) { jS(t.x), jS(t.y) } function u2(t, e, n) { return t === "position" || t === "preserve-aspect" && !dN(FS(e), FS(n), .2) } function dB(t) { var e; return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot) } const hB = l2({ attachResizeListener: (t, e) => Xl(t, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Ip = { current: void 0 }, c2 = l2({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!Ip.current) { const t = new hB({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), Ip.current = t } return Ip.current }, resetTransform: (t, e) => { t.style.transform = e !== void 0 ? e : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), pB = { pan: { Feature: EN }, drag: { Feature: AN, ProjectionNode: c2, MeasureLayout: n2 } }; function f2(t, e, n) { var r; if (t instanceof Element) return [t]; if (typeof t == "string") { let i = document; const s = (r = void 0) !== null && r !== void 0 ? r : i.querySelectorAll(t); return s ? Array.from(s) : [] } return Array.from(t) } function d2(t, e) { const n = f2(t), r = new AbortController, i = { passive: !0, ...e, signal: r.signal }; return [n, i, () => r.abort()] } function IS(t) { return e => { e.pointerType === "touch" || HT() || t(e) } } function vB(t, e, n = {}) { const [r, i, s] = d2(t, n), a = IS(u => { const { target: c } = u, f = e(u); if (!f || !c) return; const h = IS(v => { f(v), c.removeEventListener("pointerleave", h) }); c.addEventListener("pointerleave", h, i) }); return r.forEach(u => { u.addEventListener("pointerenter", a, i) }), s } function zS(t, e, n) { const { props: r } = t; t.animationState && r.whileHover && t.animationState.setActive("whileHover", n === "Start"); const i = "onHover" + n, s = r[i]; s && bt.postRender(() => s(e, hu(e))) } class mB extends Po { mount() { const { current: e } = this.node; e && (this.unmount = vB(e, n => (zS(this.node, n, "Start"), r => zS(this.node, r, "End")))) } unmount() { } } class gB extends Po { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = du(Xl(this.node.current, "focus", () => this.onFocus()), Xl(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const yl = new WeakSet; function US(t) { return e => { e.key === "Enter" && t(e) } } function zp(t, e) { t.dispatchEvent(new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 })) } const yB = (t, e) => { const n = t.currentTarget; if (!n) return; const r = US(() => { if (yl.has(n)) return; zp(n, "down"); const i = US(() => { zp(n, "up") }), s = () => zp(n, "cancel"); n.addEventListener("keyup", i, e), n.addEventListener("blur", s, e) }); n.addEventListener("keydown", r, e), n.addEventListener("blur", () => n.removeEventListener("keydown", r), e) }, xB = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function wB(t) { return xB.has(t.tagName) || t.tabIndex !== -1 } const h2 = (t, e) => e ? t === e ? !0 : h2(t, e.parentElement) : !1; function WS(t) { return wm(t) && !HT() } function SB(t, e, n = {}) { const [r, i, s] = d2(t, n), a = u => { const c = u.currentTarget; if (!WS(u) || yl.has(c)) return; yl.add(c); const f = e(u), h = (g, S) => { window.removeEventListener("pointerup", v), window.removeEventListener("pointercancel", m), !(!WS(g) || !yl.has(c)) && (yl.delete(c), f && f(g, { success: S })) }, v = g => { h(g, n.useGlobalTarget || h2(c, g.target)) }, m = g => { h(g, !1) }; window.addEventListener("pointerup", v, i), window.addEventListener("pointercancel", m, i) }; return r.forEach(u => { wB(u) || (u.tabIndex = 0), (n.useGlobalTarget ? window : u).addEventListener("pointerdown", a, i), u.addEventListener("focus", f => yB(f, i), i) }), s } function KS(t, e, n) { const { props: r } = t; t.animationState && r.whileTap && t.animationState.setActive("whileTap", n === "Start"); const i = "onTap" + (n === "End" ? "" : n), s = r[i]; s && bt.postRender(() => s(e, hu(e))) } class bB extends Po { mount() { const { current: e } = this.node; e && (this.unmount = SB(e, n => (KS(this.node, n, "Start"), (r, { success: i }) => KS(this.node, r, i ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const L0 = new WeakMap, Up = new WeakMap, CB = t => { const e = L0.get(t.target); e && e(t) }, PB = t => { t.forEach(CB) }; function TB({ root: t, ...e }) { const n = t || document; Up.has(n) || Up.set(n, {}); const r = Up.get(n), i = JSON.stringify(e); return r[i] || (r[i] = new IntersectionObserver(PB, { root: t, ...e })), r[i] } function kB(t, e, n) { const r = TB(e); return L0.set(t, n), r.observe(t), () => { L0.delete(t), r.unobserve(t) } } const AB = { some: 0, all: 1 }; class EB extends Po { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: s } = e, a = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof i == "number" ? i : AB[i] }, u = c => { const { isIntersecting: f } = c; if (this.isInView === f || (this.isInView = f, s && !f && this.hasEnteredView)) return; f && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", f); const { onViewportEnter: h, onViewportLeave: v } = this.node.getProps(), m = f ? h : v; m && m(c) }; return kB(this.node.current, a, u) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: e, prevProps: n } = this.node;["amount", "margin", "root"].some(FB(e, n)) && this.startObserver() } unmount() { } } function FB({ viewport: t = {} }, { viewport: e = {} } = {}) { return n => t[n] !== e[n] } const RB = { inView: { Feature: EB }, tap: { Feature: bB }, focus: { Feature: gB }, hover: { Feature: mB } }, DB = { layout: { ProjectionNode: c2, MeasureLayout: n2 } }, od = j.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }), sd = j.createContext({}), Cm = typeof window < "u", Pm = Cm ? j.useLayoutEffect : j.useEffect, p2 = j.createContext({ strict: !1 }); function OB(t, e, n, r, i) { var s, a; const { visualElement: u } = j.useContext(sd), c = j.useContext(p2), f = j.useContext(Sm), h = j.useContext(od).reducedMotion, v = j.useRef(null); r = r || c.renderer, !v.current && r && (v.current = r(t, { visualState: e, parent: u, props: n, presenceContext: f, blockInitialAnimation: f ? f.initial === !1 : !1, reducedMotionConfig: h })); const m = v.current, g = j.useContext(t2); m && !m.projection && i && (m.type === "html" || m.type === "svg") && MB(v.current, n, i, g); const S = j.useRef(!1); j.useInsertionEffect(() => { m && S.current && m.update(n, f) }); const b = n[zT], P = j.useRef(!!b && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, b)) && ((a = window.MotionHasOptimisedAnimation) === null || a === void 0 ? void 0 : a.call(window, b))); return Pm(() => { m && (S.current = !0, window.MotionIsMounted = !0, m.updateFeatures(), bm.render(m.render), P.current && m.animationState && m.animationState.animateChanges()) }), j.useEffect(() => { m && (!P.current && m.animationState && m.animationState.animateChanges(), P.current && (queueMicrotask(() => { var C; (C = window.MotionHandoffMarkAsComplete) === null || C === void 0 || C.call(window, b) }), P.current = !1)) }), m } function MB(t, e, n, r) { const { layoutId: i, layout: s, drag: a, dragConstraints: u, layoutScroll: c, layoutRoot: f } = e; t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : v2(t.parent)), t.projection.setOptions({ layoutId: i, layout: s, alwaysMeasureLayout: !!a || u && Gs(u), visualElement: t, animationType: typeof s == "string" ? s : "both", initialPromotionConfig: r, layoutScroll: c, layoutRoot: f }) } function v2(t) { if (t) return t.options.allowProjection !== !1 ? t.projection : v2(t.parent) } function VB(t, e, n) { return j.useCallback(r => { r && t.mount && t.mount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : Gs(n) && (n.current = r)) }, [e]) } function ad(t) { return td(t.animate) || em.some(e => Hl(t[e])) } function m2(t) { return !!(ad(t) || t.variants) } function NB(t, e) { if (ad(t)) { const { initial: n, animate: r } = t; return { initial: n === !1 || Hl(n) ? n : void 0, animate: Hl(r) ? r : void 0 } } return t.inherit !== !1 ? e : {} } function BB(t) { const { initial: e, animate: n } = NB(t, j.useContext(sd)); return j.useMemo(() => ({ initial: e, animate: n }), [HS(e), HS(n)]) } function HS(t) { return Array.isArray(t) ? t.join(" ") : t } const qS = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, oa = {}; for (const t in qS) oa[t] = { isEnabled: e => qS[t].some(n => !!e[n]) }; function LB(t) { for (const e in t) oa[e] = { ...oa[e], ...t[e] } } const jB = Symbol.for("motionComponentSymbol"); function IB({ preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: r, Component: i }) { t && LB(t); function s(u, c) { let f; const h = { ...j.useContext(od), ...u, layoutId: zB(u) }, { isStatic: v } = h, m = BB(u), g = r(u, v); if (!v && Cm) { UB(); const S = WB(h); f = S.MeasureLayout, m.visualElement = OB(i, g, h, e, S.ProjectionNode) } return De.jsxs(sd.Provider, { value: m, children: [f && m.visualElement ? De.jsx(f, { visualElement: m.visualElement, ...h }) : null, n(i, u, VB(g, m.visualElement, c), g, v, m.visualElement)] }) } const a = j.forwardRef(s); return a[jB] = i, a } function zB({ layoutId: t }) { const e = j.useContext(e2).id; return e && t !== void 0 ? e + "-" + t : t } function UB(t, e) { j.useContext(p2).strict } function WB(t) { const { drag: e, layout: n } = oa; if (!e && !n) return {}; const r = { ...e, ...n }; return { MeasureLayout: e != null && e.isEnabled(t) || n != null && n.isEnabled(t) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } const KB = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Tm(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(KB.indexOf(t) > -1 || /[A-Z]/u.test(t)) } function g2(t, { style: e, vars: n }, r, i) { Object.assign(t.style, e, i && i.getProjectionStyles(r)); for (const s in n) t.style.setProperty(s, n[s]) } const y2 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function x2(t, e, n, r) { g2(t, e, void 0, r); for (const i in e.attrs) t.setAttribute(y2.has(i) ? i : xm(i), e.attrs[i]) } function w2(t, { layout: e, layoutId: n }) { return ss.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!Af[t] || t === "opacity") } function km(t, e, n) { var r; const { style: i } = t, s = {}; for (const a in i) (pn(i[a]) || e.style && pn(e.style[a]) || w2(a, t) || ((r = n == null ? void 0 : n.getValue(a)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (s[a] = i[a]); return s } function S2(t, e, n) { const r = km(t, e, n); for (const i in t) if (pn(t[i]) || pn(e[i])) { const s = uu.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[s] = t[i] } return r } function Am(t) { const e = j.useRef(null); return e.current === null && (e.current = t()), e.current } function HB({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: n }, r, i, s) { const a = { latestValues: qB(r, i, s, t), renderState: e() }; return n && (a.mount = u => n(r, u, a)), a } const b2 = t => (e, n) => { const r = j.useContext(sd), i = j.useContext(Sm), s = () => HB(t, e, r, i); return n ? s() : Am(s) }; function qB(t, e, n, r) { const i = {}, s = r(t, {}); for (const m in s) i[m] = Jc(s[m]); let { initial: a, animate: u } = t; const c = ad(t), f = m2(t); e && f && !c && t.inherit !== !1 && (a === void 0 && (a = e.initial), u === void 0 && (u = e.animate)); let h = n ? n.initial === !1 : !1; h = h || a === !1; const v = h ? u : a; if (v && typeof v != "boolean" && !td(v)) { const m = Array.isArray(v) ? v : [v]; for (let g = 0; g < m.length; g++) { const S = _v(t, m[g]); if (S) { const { transitionEnd: b, transition: P, ...C } = S; for (const F in C) { let A = C[F]; if (Array.isArray(A)) { const N = h ? A.length - 1 : 0; A = A[N] } A !== null && (i[F] = A) } for (const F in b) i[F] = b[F] } } } return i } const Em = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }), C2 = () => ({ ...Em(), attrs: {} }), P2 = (t, e) => e && typeof t == "number" ? e.transform(t) : t, GB = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, XB = uu.length; function ZB(t, e, n) { let r = "", i = !0; for (let s = 0; s < XB; s++) { const a = uu[s], u = t[a]; if (u === void 0) continue; let c = !0; if (typeof u == "number" ? c = u === (a.startsWith("scale") ? 1 : 0) : c = parseFloat(u) === 0, !c || n) { const f = P2(u, lm[a]); if (!c) { i = !1; const h = GB[a] || a; r += `${h}(${f}) ` } n && (e[a] = f) } } return r = r.trim(), n ? r = n(e, i ? "" : r) : i && (r = "none"), r } function Fm(t, e, n) { const { style: r, vars: i, transformOrigin: s } = t; let a = !1, u = !1; for (const c in e) { const f = e[c]; if (ss.has(c)) { a = !0; continue } else if (hT(c)) { i[c] = f; continue } else { const h = P2(f, lm[c]); c.startsWith("origin") ? (u = !0, s[c] = h) : r[c] = h } } if (e.transform || (a || n ? r.transform = ZB(e, t.transform, n) : r.transform && (r.transform = "none")), u) { const { originX: c = "50%", originY: f = "50%", originZ: h = 0 } = s; r.transformOrigin = `${c} ${f} ${h}` } } function GS(t, e, n) { return typeof t == "string" ? t : He.transform(e + n * t) } function YB(t, e, n) { const r = GS(e, t.x, t.width), i = GS(n, t.y, t.height); return `${r} ${i}` } const QB = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, JB = { offset: "strokeDashoffset", array: "strokeDasharray" }; function _B(t, e, n = 1, r = 0, i = !0) { t.pathLength = 1; const s = i ? QB : JB; t[s.offset] = He.transform(-r); const a = He.transform(e), u = He.transform(n); t[s.array] = `${a} ${u}` } function Rm(t, { attrX: e, attrY: n, attrScale: r, originX: i, originY: s, pathLength: a, pathSpacing: u = 1, pathOffset: c = 0, ...f }, h, v) { if (Fm(t, f, v), h) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: m, style: g, dimensions: S } = t; m.transform && (S && (g.transform = m.transform), delete m.transform), S && (i !== void 0 || s !== void 0 || g.transform) && (g.transformOrigin = YB(S, i !== void 0 ? i : .5, s !== void 0 ? s : .5)), e !== void 0 && (m.x = e), n !== void 0 && (m.y = n), r !== void 0 && (m.scale = r), a !== void 0 && _B(m, a, u, c, !1) } const Dm = t => typeof t == "string" && t.toLowerCase() === "svg", $B = { useVisualState: b2({ scrapeMotionValuesFromProps: S2, createRenderState: C2, onMount: (t, e, { renderState: n, latestValues: r }) => { bt.read(() => { try { n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), bt.render(() => { Rm(n, r, Dm(e.tagName), t.transformTemplate), x2(e, n) }) } }) }, eL = { useVisualState: b2({ scrapeMotionValuesFromProps: km, createRenderState: Em }) }; function T2(t, e, n) { for (const r in e) !pn(e[r]) && !w2(r, n) && (t[r] = e[r]) } function tL({ transformTemplate: t }, e) { return j.useMemo(() => { const n = Em(); return Fm(n, e, t), Object.assign({}, n.vars, n.style) }, [e]) } function nL(t, e) { const n = t.style || {}, r = {}; return T2(r, n, t), Object.assign(r, tL(t, e)), r } function rL(t, e) { const n = {}, r = nL(t, e); return t.drag && t.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = r, n } const iL = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function Ef(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || iL.has(t) } let k2 = t => !Ef(t); function oL(t) { t && (k2 = e => e.startsWith("on") ? !Ef(e) : t(e)) } try { oL(require("@emotion/is-prop-valid").default) } catch { } function sL(t, e, n) { const r = {}; for (const i in t) i === "values" && typeof t.values == "object" || (k2(i) || n === !0 && Ef(i) || !e && !Ef(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]); return r } function aL(t, e, n, r) { const i = j.useMemo(() => { const s = C2(); return Rm(s, e, Dm(r), t.transformTemplate), { ...s.attrs, style: { ...s.style } } }, [e]); if (t.style) { const s = {}; T2(s, t.style, t), i.style = { ...s, ...i.style } } return i } function lL(t = !1) { return (n, r, i, { latestValues: s }, a) => { const c = (Tm(n) ? aL : rL)(r, s, a, n), f = sL(r, typeof n == "string", t), h = n !== j.Fragment ? { ...f, ...c, ref: i } : {}, { children: v } = r, m = j.useMemo(() => pn(v) ? v.get() : v, [v]); return j.createElement(n, { ...h, children: m }) } } function uL(t, e) { return function (r, { forwardMotionProps: i } = { forwardMotionProps: !1 }) { const a = { ...Tm(r) ? $B : eL, preloadedFeatures: t, useRender: lL(i), createVisualElement: e, Component: r }; return IB(a) } } const j0 = { current: null }, A2 = { current: !1 }; function cL() { if (A2.current = !0, !!Cm) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), e = () => j0.current = t.matches; t.addListener(e), e() } else j0.current = !1 } function fL(t, e, n) { for (const r in e) { const i = e[r], s = n[r]; if (pn(i)) t.addValue(r, i); else if (pn(s)) t.addValue(r, ei(i, { owner: t })); else if (s !== i) if (t.hasValue(r)) { const a = t.getValue(r); a.liveStyle === !0 ? a.jump(i) : a.hasAnimated || a.set(i) } else { const a = t.getStaticValue(r); t.addValue(r, ei(a !== void 0 ? a : i, { owner: t })) } } for (const r in n) e[r] === void 0 && t.removeValue(r); return e } const XS = new WeakMap, dL = [...mT, En, mo], hL = t => dL.find(vT(t)), ZS = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class pL { scrapeMotionValuesFromProps(e, n, r) { return {} } constructor({ parent: e, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: a }, u = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = om, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const m = ii.now(); this.renderScheduledAt < m && (this.renderScheduledAt = m, bt.render(this.render, !1, !0)) }; const { latestValues: c, renderState: f } = a; this.latestValues = c, this.baseTarget = { ...c }, this.initialValues = n.initial ? { ...c } : {}, this.renderState = f, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = u, this.blockInitialAnimation = !!s, this.isControllingVariants = ad(n), this.isVariantNode = m2(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); const { willChange: h, ...v } = this.scrapeMotionValuesFromProps(n, {}, this); for (const m in v) { const g = v[m]; c[m] !== void 0 && pn(g) && g.set(c[m], !1) } } mount(e) { this.current = e, XS.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), A2.current || cL(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : j0.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { XS.delete(this.current), this.projection && this.projection.unmount(), ai(this.notifyUpdate), ai(this.render), this.valueSubscriptions.forEach(e => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const e in this.events) this.events[e].clear(); for (const e in this.features) { const n = this.features[e]; n && (n.unmount(), n.isMounted = !1) } this.current = null } bindToMotionValue(e, n) { this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)(); const r = ss.has(e), i = n.on("change", u => { this.latestValues[e] = u, this.props.onUpdate && bt.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0) }), s = n.on("renderRequest", this.scheduleRender); let a; window.MotionCheckAppearSync && (a = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => { i(), s(), a && a(), n.owner && n.stop() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } updateFeatures() { let e = "animation"; for (e in oa) { const n = oa[e]; if (!n) continue; const { isEnabled: r, Feature: i } = n; if (!this.features[e] && i && r(this.props) && (this.features[e] = new i(this)), this.features[e]) { const s = this.features[e]; s.isMounted ? s.update() : (s.mount(), s.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Yt() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, n) { this.latestValues[e] = n } update(e, n) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < ZS.length; r++) { const i = ZS[r]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); const s = "on" + i, a = e[s]; a && (this.propEventSubscriptions[i] = this.on(i, a)) } this.prevMotionValues = fL(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(e) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e) } addValue(e, n) { const r = this.values.get(e); n !== r && (r && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get()) } removeValue(e) { this.values.delete(e); const n = this.valueSubscriptions.get(e); n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, n) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let r = this.values.get(e); return r === void 0 && n !== void 0 && (r = ei(n === null ? void 0 : n, { owner: this }), this.addValue(e, r)), r } readValue(e, n) { var r; let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (r = this.getBaseTargetFromProps(this.props, e)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, e, this.options); return i != null && (typeof i == "string" && (fT(i) || cT(i)) ? i = parseFloat(i) : !hL(i) && mo.test(n) && (i = PT(e, n)), this.setBaseTarget(e, pn(i) ? i.get() : i)), pn(i) ? i.get() : i } setBaseTarget(e, n) { this.baseTarget[e] = n } getBaseTarget(e) { var n; const { initial: r } = this.props; let i; if (typeof r == "string" || typeof r == "object") { const a = _v(this.props, r, (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom); a && (i = a[e]) } if (r && i !== void 0) return i; const s = this.getBaseTargetFromProps(this.props, e); return s !== void 0 && !pn(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e] } on(e, n) { return this.events[e] || (this.events[e] = new ym), this.events[e].add(n) } notify(e, ...n) { this.events[e] && this.events[e].notify(...n) } } class E2 extends pL { constructor() { super(...arguments), this.KeyframeResolver = TT } sortInstanceNodePosition(e, n) { return e.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(e, n) { return e.style ? e.style[n] : void 0 } removeValueFromRenderState(e, { vars: n, style: r }) { delete n[e], delete r[e] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; pn(e) && (this.childSubscription = e.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } } function vL(t) { return window.getComputedStyle(t) } class mL extends E2 { constructor() { super(...arguments), this.type = "html", this.renderInstance = g2 } readValueFromInstance(e, n) { if (ss.has(n)) { const r = um(n); return r && r.default || 0 } else { const r = vL(e), i = (hT(n) ? r.getPropertyValue(n) : r[n]) || 0; return typeof i == "string" ? i.trim() : i } } measureInstanceViewportBox(e, { transformPagePoint: n }) { return _T(e, n) } build(e, n, r) { Fm(e, n, r.transformTemplate) } scrapeMotionValuesFromProps(e, n, r) { return km(e, n, r) } } class gL extends E2 { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Yt } getBaseTargetFromProps(e, n) { return e[n] } readValueFromInstance(e, n) { if (ss.has(n)) { const r = um(n); return r && r.default || 0 } return n = y2.has(n) ? n : xm(n), e.getAttribute(n) } scrapeMotionValuesFromProps(e, n, r) { return S2(e, n, r) } build(e, n, r) { Rm(e, n, this.isSVGTag, r.transformTemplate) } renderInstance(e, n, r, i) { x2(e, n, r, i) } mount(e) { this.isSVGTag = Dm(e.tagName), super.mount(e) } } const yL = (t, e) => Tm(t) ? new gL(e) : new mL(e, { allowProjection: t !== j.Fragment }), F2 = uL({ ...nN, ...RB, ...pB, ...DB }, yL), YS = F2("div"), xL = "/ImageCompressionn-BOHpXUfW.jpg", wL = "/MergePdf-CkXg5QUO.jpg", SL = "/PdfCompression-BTRnV3xC.jpg", bL = "/PdfFromExcel-B8wsx-ZG.jpg", CL = "/webpdf/blob/main/PdfFromImage-DVGqYy_v.jpg", PL = "/WordToPdf-go1EIhm3.jpg"; function TL() { return De.jsx("div", { style: EL, children: OL.map(([t, e, n, r], i) => De.jsx(kL, { i, emoji: t, image: e, hueA: n, hueB: r }, t)) }) } function kL({ emoji: t, image: e, hueA: n, hueB: r, i }) { const s = `linear-gradient(306deg, ${QS(n)}, ${QS(r)})`; return De.jsxs(YS, { className: `card-container-${i} gap-5`, style: FL, initial: "offscreen", whileInView: "onscreen", viewport: { amount: .8 }, children: [De.jsx("div", { style: { ...RL, background: s } }), De.jsxs(YS, { style: DL, variants: AL, className: "card flex flex-col gap-5", children: [De.jsx("h1", { children: t }), De.jsx("img", { src: e, className: "", alt: "image" })] })] }) } const AL = { offscreen: { y: 300 }, onscreen: { y: 50, rotate: -10, transition: { type: "spring", bounce: .4, duration: .8 } } }, QS = t => `hsl(${t}, 100%, 50%)`, EL = { margin: "100px auto", maxWidth: 500, paddingBottom: 100, width: "100%" }, FL = { overflow: "hidden", display: "flex", justifyContent: "center", alignItems: "center", position: "relative", paddingTop: 20, marginBottom: -120 }, RL = { position: "absolute", top: 0, left: 0, right: 0, bottom: 0, clipPath: 'path("M 0 303.5 C 0 292.454 8.995 285.101 20 283.5 L 460 219.5 C 470.085 218.033 480 228.454 480 239.5 L 500 430 C 500 441.046 491.046 450 480 450 L 20 450 C 8.954 450 0 441.046 0 430 Z")' }, DL = { fontSize: 32, fontWeight: "bold", width: 300, height: 430, display: "flex", justifyContent: "center", alignItems: "center", borderRadius: 20, background: "#f5f5f5", boxShadow: "0 0 1px hsl(0deg 0% 0% / 0.075), 0 0 2px hsl(0deg 0% 0% / 0.075), 0 0 4px hsl(0deg 0% 0% / 0.075), 0 0 8px hsl(0deg 0% 0% / 0.075), 0 0 16px hsl(0deg 0% 0% / 0.075)", transformOrigin: "10% 60%" }, OL = [["Img to Pdf", CL, 250, 100], ["Pdf Compressor", SL, 200, 0], ["Pdf Merger", wL, 60, 200], ["Image Compressor", xL, 50, 290], ["Excel to Pdf", bL, 10, 100], ["Word to Pdf", PL, 290, 50]]; var R2 = wb(); function JS(t, e) { if (typeof t == "function") return t(e); t != null && (t.current = e) } function D2(...t) { return e => { let n = !1; const r = t.map(i => { const s = JS(i, e); return !n && typeof s == "function" && (n = !0), s }); if (n) return () => { for (let i = 0; i < r.length; i++) { const s = r[i]; typeof s == "function" ? s() : JS(t[i], null) } } } } function as(...t) { return j.useCallback(D2(...t), t) } var ld = j.forwardRef((t, e) => { const { children: n, ...r } = t, i = j.Children.toArray(n), s = i.find(ML); if (s) { const a = s.props.children, u = i.map(c => c === s ? j.Children.count(a) > 1 ? j.Children.only(null) : j.isValidElement(a) ? a.props.children : null : c); return De.jsx(I0, { ...r, ref: e, children: j.isValidElement(a) ? j.cloneElement(a, void 0, u) : null }) } return De.jsx(I0, { ...r, ref: e, children: n }) }); ld.displayName = "Slot"; var I0 = j.forwardRef((t, e) => { const { children: n, ...r } = t; if (j.isValidElement(n)) { const i = NL(n); return j.cloneElement(n, { ...VL(r, n.props), ref: e ? D2(e, i) : i }) } return j.Children.count(n) > 1 ? j.Children.only(null) : null }); I0.displayName = "SlotClone"; var O2 = ({ children: t }) => De.jsx(De.Fragment, { children: t }); function ML(t) { return j.isValidElement(t) && t.type === O2 } function VL(t, e) { const n = { ...e }; for (const r in e) { const i = t[r], s = e[r]; /^on[A-Z]/.test(r) ? i && s ? n[r] = (...u) => { s(...u), i(...u) } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...s } : r === "className" && (n[r] = [i, s].filter(Boolean).join(" ")) } return { ...t, ...n } } function NL(t) { var r, i; let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning; return n ? t.ref : (e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref) } var BL = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], ls = BL.reduce((t, e) => { const n = j.forwardRef((r, i) => { const { asChild: s, ...a } = r, u = s ? ld : e; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), De.jsx(u, { ...a, ref: i }) }); return n.displayName = `Primitive.${e}`, { ...t, [e]: n } }, {}); function LL(t, e) { t && R2.flushSync(() => t.dispatchEvent(e)) } var jL = "VisuallyHidden", M2 = j.forwardRef((t, e) => De.jsx(ls.span, { ...t, ref: e, style: { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal", ...t.style } })); M2.displayName = jL; var IL = M2, Wp = { exports: {} };/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/var _S; function zL() { return _S || (_S = 1, function (t) { (function () { var e = {}.hasOwnProperty; function n() { for (var s = "", a = 0; a < arguments.length; a++) { var u = arguments[a]; u && (s = i(s, r(u))) } return s } function r(s) { if (typeof s == "string" || typeof s == "number") return s; if (typeof s != "object") return ""; if (Array.isArray(s)) return n.apply(null, s); if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) return s.toString(); var a = ""; for (var u in s) e.call(s, u) && s[u] && (a = i(a, u)); return a } function i(s, a) { return a ? s ? s + " " + a : s + a : s } t.exports ? (n.default = n, t.exports = n) : window.classNames = n })() }(Wp)), Wp.exports } var UL = zL(); const Qs = Y0(UL); function V2(t, e = []) { let n = []; function r(s, a) { const u = j.createContext(a), c = n.length; n = [...n, a]; const f = v => { var C; const { scope: m, children: g, ...S } = v, b = ((C = m == null ? void 0 : m[t]) == null ? void 0 : C[c]) || u, P = j.useMemo(() => S, Object.values(S)); return De.jsx(b.Provider, { value: P, children: g }) }; f.displayName = s + "Provider"; function h(v, m) { var b; const g = ((b = m == null ? void 0 : m[t]) == null ? void 0 : b[c]) || u, S = j.useContext(g); if (S) return S; if (a !== void 0) return a; throw new Error(`\`${v}\` must be used within \`${s}\``) } return [f, h] } const i = () => { const s = n.map(a => j.createContext(a)); return function (u) { const c = (u == null ? void 0 : u[t]) || s; return j.useMemo(() => ({ [`__scope${t}`]: { ...u, [t]: c } }), [u, c]) } }; return i.scopeName = t, [r, WL(i, ...e)] } function WL(...t) { const e = t[0]; if (t.length === 1) return e; const n = () => { const r = t.map(i => ({ useScope: i(), scopeName: i.scopeName })); return function (s) { const a = r.reduce((u, { useScope: c, scopeName: f }) => { const v = c(s)[`__scope${f}`]; return { ...u, ...v } }, {}); return j.useMemo(() => ({ [`__scope${e.scopeName}`]: a }), [a]) } }; return n.scopeName = e.scopeName, n } function bi(t, e, { checkForDefaultPrevented: n = !0 } = {}) { return function (i) { if (t == null || t(i), n === !1 || !i.defaultPrevented) return e == null ? void 0 : e(i) } } var Zl = globalThis != null && globalThis.document ? j.useLayoutEffect : () => { }; function ud(t) { const e = j.useRef(t); return j.useEffect(() => { e.current = t }), j.useMemo(() => (...n) => { var r; return (r = e.current) == null ? void 0 : r.call(e, ...n) }, []) } function KL(t, e = globalThis == null ? void 0 : globalThis.document) { const n = ud(t); j.useEffect(() => { const r = i => { i.key === "Escape" && n(i) }; return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 }) }, [n, e]) } var HL = "DismissableLayer", z0 = "dismissableLayer.update", qL = "dismissableLayer.pointerDownOutside", GL = "dismissableLayer.focusOutside", $S, N2 = j.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), B2 = j.forwardRef((t, e) => { const { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: i, onFocusOutside: s, onInteractOutside: a, onDismiss: u, ...c } = t, f = j.useContext(N2), [h, v] = j.useState(null), m = (h == null ? void 0 : h.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, g] = j.useState({}), S = as(e, B => v(B)), b = Array.from(f.layers), [P] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1), C = b.indexOf(P), F = h ? b.indexOf(h) : -1, A = f.layersWithOutsidePointerEventsDisabled.size > 0, N = F >= C, D = YL(B => { const I = B.target, Y = [...f.branches].some(Z => Z.contains(I)); !N || Y || (i == null || i(B), a == null || a(B), B.defaultPrevented || u == null || u()) }, m), V = QL(B => { const I = B.target;[...f.branches].some(Z => Z.contains(I)) || (s == null || s(B), a == null || a(B), B.defaultPrevented || u == null || u()) }, m); return KL(B => { F === f.layers.size - 1 && (r == null || r(B), !B.defaultPrevented && u && (B.preventDefault(), u())) }, m), j.useEffect(() => { if (h) return n && (f.layersWithOutsidePointerEventsDisabled.size === 0 && ($S = m.body.style.pointerEvents, m.body.style.pointerEvents = "none"), f.layersWithOutsidePointerEventsDisabled.add(h)), f.layers.add(h), eb(), () => { n && f.layersWithOutsidePointerEventsDisabled.size === 1 && (m.body.style.pointerEvents = $S) } }, [h, m, n, f]), j.useEffect(() => () => { h && (f.layers.delete(h), f.layersWithOutsidePointerEventsDisabled.delete(h), eb()) }, [h, f]), j.useEffect(() => { const B = () => g({}); return document.addEventListener(z0, B), () => document.removeEventListener(z0, B) }, []), De.jsx(ls.div, { ...c, ref: S, style: { pointerEvents: A ? N ? "auto" : "none" : void 0, ...t.style }, onFocusCapture: bi(t.onFocusCapture, V.onFocusCapture), onBlurCapture: bi(t.onBlurCapture, V.onBlurCapture), onPointerDownCapture: bi(t.onPointerDownCapture, D.onPointerDownCapture) }) }); B2.displayName = HL; var XL = "DismissableLayerBranch", ZL = j.forwardRef((t, e) => { const n = j.useContext(N2), r = j.useRef(null), i = as(e, r); return j.useEffect(() => { const s = r.current; if (s) return n.branches.add(s), () => { n.branches.delete(s) } }, [n.branches]), De.jsx(ls.div, { ...t, ref: i }) }); ZL.displayName = XL; function YL(t, e = globalThis == null ? void 0 : globalThis.document) { const n = ud(t), r = j.useRef(!1), i = j.useRef(() => { }); return j.useEffect(() => { const s = u => { if (u.target && !r.current) { let c = function () { L2(qL, n, f, { discrete: !0 }) }; const f = { originalEvent: u }; u.pointerType === "touch" ? (e.removeEventListener("click", i.current), i.current = c, e.addEventListener("click", i.current, { once: !0 })) : c() } else e.removeEventListener("click", i.current); r.current = !1 }, a = window.setTimeout(() => { e.addEventListener("pointerdown", s) }, 0); return () => { window.clearTimeout(a), e.removeEventListener("pointerdown", s), e.removeEventListener("click", i.current) } }, [e, n]), { onPointerDownCapture: () => r.current = !0 } } function QL(t, e = globalThis == null ? void 0 : globalThis.document) { const n = ud(t), r = j.useRef(!1); return j.useEffect(() => { const i = s => { s.target && !r.current && L2(GL, n, { originalEvent: s }, { discrete: !1 }) }; return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i) }, [e, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } } function eb() { const t = new CustomEvent(z0); document.dispatchEvent(t) } function L2(t, e, n, { discrete: r }) { const i = n.originalEvent.target, s = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n }); e && i.addEventListener(t, e, { once: !0 }), r ? LL(i, s) : i.dispatchEvent(s) } function JL(t, e) { return j.useReducer((n, r) => e[n][r] ?? n, t) } var j2 = t => { const { present: e, children: n } = t, r = _L(e), i = typeof n == "function" ? n({ present: r.isPresent }) : j.Children.only(n), s = as(r.ref, $L(i)); return typeof n == "function" || r.isPresent ? j.cloneElement(i, { ref: s }) : null }; j2.displayName = "Presence"; function _L(t) { const [e, n] = j.useState(), r = j.useRef({}), i = j.useRef(t), s = j.useRef("none"), a = t ? "mounted" : "unmounted", [u, c] = JL(a, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return j.useEffect(() => { const f = jc(r.current); s.current = u === "mounted" ? f : "none" }, [u]), Zl(() => { const f = r.current, h = i.current; if (h !== t) { const m = s.current, g = jc(f); t ? c("MOUNT") : g === "none" || (f == null ? void 0 : f.display) === "none" ? c("UNMOUNT") : c(h && m !== g ? "ANIMATION_OUT" : "UNMOUNT"), i.current = t } }, [t, c]), Zl(() => { if (e) { let f; const h = e.ownerDocument.defaultView ?? window, v = g => { const b = jc(r.current).includes(g.animationName); if (g.target === e && b && (c("ANIMATION_END"), !i.current)) { const P = e.style.animationFillMode; e.style.animationFillMode = "forwards", f = h.setTimeout(() => { e.style.animationFillMode === "forwards" && (e.style.animationFillMode = P) }) } }, m = g => { g.target === e && (s.current = jc(r.current)) }; return e.addEventListener("animationstart", m), e.addEventListener("animationcancel", v), e.addEventListener("animationend", v), () => { h.clearTimeout(f), e.removeEventListener("animationstart", m), e.removeEventListener("animationcancel", v), e.removeEventListener("animationend", v) } } else c("ANIMATION_END") }, [e, c]), { isPresent: ["mounted", "unmountSuspended"].includes(u), ref: j.useCallback(f => { f && (r.current = getComputedStyle(f)), n(f) }, []) } } function jc(t) { return (t == null ? void 0 : t.animationName) || "none" } function $L(t) { var r, i; let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning; return n ? t.ref : (e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref) } const I2 = { asChild: { type: "boolean" } }, z2 = ["gray", "gold", "bronze", "brown", "yellow", "amber", "orange", "tomato", "red", "ruby", "crimson", "pink", "plum", "purple", "violet", "iris", "indigo", "blue", "cyan", "teal", "jade", "green", "grass", "lime", "mint", "sky"], ej = ["auto", "gray", "mauve", "slate", "sage", "olive", "sand"], tj = { color: { type: "enum", values: z2, default: void 0 } }, nj = { highContrast: { type: "boolean", className: "rt-high-contrast", default: void 0 } }, rj = ["normal", "start", "end", "both"], ij = { trim: { type: "enum", className: "rt-r-lt", values: rj, responsive: !0 } }, oj = ["left", "center", "right"], sj = { align: { type: "enum", className: "rt-r-ta", values: oj, responsive: !0 } }, aj = ["wrap", "nowrap", "pretty", "balance"], lj = { wrap: { type: "enum", className: "rt-r-tw", values: aj, responsive: !0 } }, uj = { truncate: { type: "boolean", className: "rt-truncate" } }, cj = ["light", "regular", "medium", "bold"], fj = { weight: { type: "enum", className: "rt-r-weight", values: cj, responsive: !0 } }, Om = ["initial", "xs", "sm", "md", "lg", "xl"]; function U2(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } function Ol(t) { return typeof t == "object" && Object.keys(t).some(e => Om.includes(e)) } function dj({ className: t, customProperties: e, ...n }) { const r = W2({ allowArbitraryValues: !0, className: t, ...n }), i = hj({ customProperties: e, ...n }); return [r, i] } function W2({ allowArbitraryValues: t, value: e, className: n, propValues: r, parseValue: i = s => s }) { const s = []; if (e) { if (typeof e == "string" && r.includes(e)) return tb(n, e, i); if (Ol(e)) { const a = e; for (const u in a) { if (!U2(a, u) || !Om.includes(u)) continue; const c = a[u]; if (c !== void 0) { if (r.includes(c)) { const f = tb(n, c, i), h = u === "initial" ? f : `${u}:${f}`; s.push(h) } else if (t) { const f = u === "initial" ? n : `${u}:${n}`; s.push(f) } } } return s.join(" ") } if (t) return n } } function tb(t, e, n) { const r = t ? "-" : "", i = n(e), s = i == null ? void 0 : i.startsWith("-"), a = s ? "-" : "", u = s ? i == null ? void 0 : i.substring(1) : i; return `${a}${t}${r}${u}` } function hj({ customProperties: t, value: e, propValues: n, parseValue: r = i => i }) { let i = {}; if (!(!e || typeof e == "string" && n.includes(e))) { if (typeof e == "string" && (i = Object.fromEntries(t.map(s => [s, e]))), Ol(e)) { const s = e; for (const a in s) { if (!U2(s, a) || !Om.includes(a)) continue; const u = s[a]; if (!n.includes(u)) for (const c of t) i = { [a === "initial" ? c : `${c}-${a}`]: u, ...i } } } for (const s in i) { const a = i[s]; a !== void 0 && (i[s] = r(a)) } return i } } function nb(...t) { let e = {}; for (const n of t) n && (e = { ...e, ...n }); return Object.keys(e).length ? e : void 0 } function pj(...t) { return Object.assign({}, ...t) } function vj(t, ...e) { let n, r; const i = { ...t }, s = pj(...e); for (const a in s) { let u = i[a]; const c = s[a]; if (c.default !== void 0 && u === void 0 && (u = c.default), c.type === "enum" && ![c.default, ...c.values].includes(u) && !Ol(u) && (u = c.default), i[a] = u, "className" in c && c.className) { delete i[a]; const f = "responsive" in c; if (!u || Ol(u) && !f) continue; if (Ol(u) && (c.default !== void 0 && u.initial === void 0 && (u.initial = c.default), c.type === "enum" && ([c.default, ...c.values].includes(u.initial) || (u.initial = c.default))), c.type === "enum") { const h = W2({ allowArbitraryValues: !1, value: u, className: c.className, propValues: c.values, parseValue: c.parseValue }); n = Qs(n, h); continue } if (c.type === "string" || c.type === "enum | string") { const h = c.type === "string" ? [] : c.values, [v, m] = dj({ className: c.className, customProperties: c.customProperties, propValues: h, parseValue: c.parseValue, value: u }); r = nb(r, m), n = Qs(n, v); continue } if (c.type === "boolean" && u) { n = Qs(n, c.className); continue } } } return i.className = Qs(n, t.className), i.style = nb(r, t.style), i } const Wo = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"], mj = { m: { type: "enum | string", values: Wo, responsive: !0, className: "rt-r-m", customProperties: ["--m"] }, mx: { type: "enum | string", values: Wo, responsive: !0, className: "rt-r-mx", customProperties: ["--ml", "--mr"] }, my: { type: "enum | string", values: Wo, responsive: !0, className: "rt-r-my", customProperties: ["--mt", "--mb"] }, mt: { type: "enum | string", values: Wo, responsive: !0, className: "rt-r-mt", customProperties: ["--mt"] }, mr: { type: "enum | string", values: Wo, responsive: !0, className: "rt-r-mr", customProperties: ["--mr"] }, mb: { type: "enum | string", values: Wo, responsive: !0, className: "rt-r-mb", customProperties: ["--mb"] }, ml: { type: "enum | string", values: Wo, responsive: !0, className: "rt-r-ml", customProperties: ["--ml"] } }, gj = ["span", "div", "label", "p"], yj = ["1", "2", "3", "4", "5", "6", "7", "8", "9"], xj = { as: { type: "enum", values: gj, default: "span" }, ...I2, size: { type: "enum", className: "rt-r-size", values: yj, responsive: !0 }, ...fj, ...sj, ...ij, ...uj, ...lj, ...tj, ...nj }, U0 = j.forwardRef((t, e) => { const { children: n, className: r, asChild: i, as: s = "span", color: a, ...u } = vj(t, xj, mj); return j.createElement(ld, { "data-accent-color": a, ...u, ref: e, className: Qs("rt-Text", r) }, i ? n : j.createElement(s, null, n)) }); U0.displayName = "Text"; const wj = ["top", "right", "bottom", "left"], go = Math.min, tr = Math.max, Ff = Math.round, Ic = Math.floor, oi = t => ({ x: t, y: t }), Sj = { left: "right", right: "left", bottom: "top", top: "bottom" }, bj = { start: "end", end: "start" }; function W0(t, e, n) { return tr(t, go(e, n)) } function Oi(t, e) { return typeof t == "function" ? t(e) : t } function Mi(t) { return t.split("-")[0] } function pa(t) { return t.split("-")[1] } function Mm(t) { return t === "x" ? "y" : "x" } function Vm(t) { return t === "y" ? "height" : "width" } function yo(t) { return ["top", "bottom"].includes(Mi(t)) ? "y" : "x" } function Nm(t) { return Mm(yo(t)) } function Cj(t, e, n) { n === void 0 && (n = !1); const r = pa(t), i = Nm(t), s = Vm(i); let a = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top"; return e.reference[s] > e.floating[s] && (a = Rf(a)), [a, Rf(a)] } function Pj(t) { const e = Rf(t); return [K0(t), e, K0(e)] } function K0(t) { return t.replace(/start|end/g, e => bj[e]) } function Tj(t, e, n) { const r = ["left", "right"], i = ["right", "left"], s = ["top", "bottom"], a = ["bottom", "top"]; switch (t) { case "top": case "bottom": return n ? e ? i : r : e ? r : i; case "left": case "right": return e ? s : a; default: return [] } } function kj(t, e, n, r) { const i = pa(t); let s = Tj(Mi(t), n === "start", r); return i && (s = s.map(a => a + "-" + i), e && (s = s.concat(s.map(K0)))), s } function Rf(t) { return t.replace(/left|right|bottom|top/g, e => Sj[e]) } function Aj(t) { return { top: 0, right: 0, bottom: 0, left: 0, ...t } } function K2(t) { return typeof t != "number" ? Aj(t) : { top: t, right: t, bottom: t, left: t } } function Df(t) { const { x: e, y: n, width: r, height: i } = t; return { width: r, height: i, top: n, left: e, right: e + r, bottom: n + i, x: e, y: n } } function rb(t, e, n) { let { reference: r, floating: i } = t; const s = yo(e), a = Nm(e), u = Vm(a), c = Mi(e), f = s === "y", h = r.x + r.width / 2 - i.width / 2, v = r.y + r.height / 2 - i.height / 2, m = r[u] / 2 - i[u] / 2; let g; switch (c) { case "top": g = { x: h, y: r.y - i.height }; break; case "bottom": g = { x: h, y: r.y + r.height }; break; case "right": g = { x: r.x + r.width, y: v }; break; case "left": g = { x: r.x - i.width, y: v }; break; default: g = { x: r.x, y: r.y } }switch (pa(e)) { case "start": g[a] -= m * (n && f ? -1 : 1); break; case "end": g[a] += m * (n && f ? -1 : 1); break }return g } const Ej = async (t, e, n) => { const { placement: r = "bottom", strategy: i = "absolute", middleware: s = [], platform: a } = n, u = s.filter(Boolean), c = await (a.isRTL == null ? void 0 : a.isRTL(e)); let f = await a.getElementRects({ reference: t, floating: e, strategy: i }), { x: h, y: v } = rb(f, r, c), m = r, g = {}, S = 0; for (let b = 0; b < u.length; b++) { const { name: P, fn: C } = u[b], { x: F, y: A, data: N, reset: D } = await C({ x: h, y: v, initialPlacement: r, placement: m, strategy: i, middlewareData: g, rects: f, platform: a, elements: { reference: t, floating: e } }); h = F ?? h, v = A ?? v, g = { ...g, [P]: { ...g[P], ...N } }, D && S <= 50 && (S++, typeof D == "object" && (D.placement && (m = D.placement), D.rects && (f = D.rects === !0 ? await a.getElementRects({ reference: t, floating: e, strategy: i }) : D.rects), { x: h, y: v } = rb(f, m, c)), b = -1) } return { x: h, y: v, placement: m, strategy: i, middlewareData: g } }; async function Yl(t, e) { var n; e === void 0 && (e = {}); const { x: r, y: i, platform: s, rects: a, elements: u, strategy: c } = t, { boundary: f = "clippingAncestors", rootBoundary: h = "viewport", elementContext: v = "floating", altBoundary: m = !1, padding: g = 0 } = Oi(e, t), S = K2(g), P = u[m ? v === "floating" ? "reference" : "floating" : v], C = Df(await s.getClippingRect({ element: (n = await (s.isElement == null ? void 0 : s.isElement(P))) == null || n ? P : P.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(u.floating)), boundary: f, rootBoundary: h, strategy: c })), F = v === "floating" ? { x: r, y: i, width: a.floating.width, height: a.floating.height } : a.reference, A = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u.floating)), N = await (s.isElement == null ? void 0 : s.isElement(A)) ? await (s.getScale == null ? void 0 : s.getScale(A)) || { x: 1, y: 1 } : { x: 1, y: 1 }, D = Df(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: u, rect: F, offsetParent: A, strategy: c }) : F); return { top: (C.top - D.top + S.top) / N.y, bottom: (D.bottom - C.bottom + S.bottom) / N.y, left: (C.left - D.left + S.left) / N.x, right: (D.right - C.right + S.right) / N.x } } const Fj = t => ({ name: "arrow", options: t, async fn(e) { const { x: n, y: r, placement: i, rects: s, platform: a, elements: u, middlewareData: c } = e, { element: f, padding: h = 0 } = Oi(t, e) || {}; if (f == null) return {}; const v = K2(h), m = { x: n, y: r }, g = Nm(i), S = Vm(g), b = await a.getDimensions(f), P = g === "y", C = P ? "top" : "left", F = P ? "bottom" : "right", A = P ? "clientHeight" : "clientWidth", N = s.reference[S] + s.reference[g] - m[g] - s.floating[S], D = m[g] - s.reference[g], V = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(f)); let B = V ? V[A] : 0; (!B || !await (a.isElement == null ? void 0 : a.isElement(V))) && (B = u.floating[A] || s.floating[S]); const I = N / 2 - D / 2, Y = B / 2 - b[S] / 2 - 1, Z = go(v[C], Y), ie = go(v[F], Y), se = Z, q = B - b[S] - ie, ue = B / 2 - b[S] / 2 + I, ye = W0(se, ue, q), ae = !c.arrow && pa(i) != null && ue !== ye && s.reference[S] / 2 - (ue < se ? Z : ie) - b[S] / 2 < 0, _ = ae ? ue < se ? ue - se : ue - q : 0; return { [g]: m[g] + _, data: { [g]: ye, centerOffset: ue - ye - _, ...ae && { alignmentOffset: _ } }, reset: ae } } }), Rj = function (t) { return t === void 0 && (t = {}), { name: "flip", options: t, async fn(e) { var n, r; const { placement: i, middlewareData: s, rects: a, initialPlacement: u, platform: c, elements: f } = e, { mainAxis: h = !0, crossAxis: v = !0, fallbackPlacements: m, fallbackStrategy: g = "bestFit", fallbackAxisSideDirection: S = "none", flipAlignment: b = !0, ...P } = Oi(t, e); if ((n = s.arrow) != null && n.alignmentOffset) return {}; const C = Mi(i), F = yo(u), A = Mi(u) === u, N = await (c.isRTL == null ? void 0 : c.isRTL(f.floating)), D = m || (A || !b ? [Rf(u)] : Pj(u)), V = S !== "none"; !m && V && D.push(...kj(u, b, S, N)); const B = [u, ...D], I = await Yl(e, P), Y = []; let Z = ((r = s.flip) == null ? void 0 : r.overflows) || []; if (h && Y.push(I[C]), v) { const ue = Cj(i, a, N); Y.push(I[ue[0]], I[ue[1]]) } if (Z = [...Z, { placement: i, overflows: Y }], !Y.every(ue => ue <= 0)) { var ie, se; const ue = (((ie = s.flip) == null ? void 0 : ie.index) || 0) + 1, ye = B[ue]; if (ye) return { data: { index: ue, overflows: Z }, reset: { placement: ye } }; let ae = (se = Z.filter(_ => _.overflows[0] <= 0).sort((_, Q) => _.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : se.placement; if (!ae) switch (g) { case "bestFit": { var q; const _ = (q = Z.filter(Q => { if (V) { const le = yo(Q.placement); return le === F || le === "y" } return !0 }).map(Q => [Q.placement, Q.overflows.filter(le => le > 0).reduce((le, ce) => le + ce, 0)]).sort((Q, le) => Q[1] - le[1])[0]) == null ? void 0 : q[0]; _ && (ae = _); break } case "initialPlacement": ae = u; break }if (i !== ae) return { reset: { placement: ae } } } return {} } } }; function ib(t, e) { return { top: t.top - e.height, right: t.right - e.width, bottom: t.bottom - e.height, left: t.left - e.width } } function ob(t) { return wj.some(e => t[e] >= 0) } const Dj = function (t) { return t === void 0 && (t = {}), { name: "hide", options: t, async fn(e) { const { rects: n } = e, { strategy: r = "referenceHidden", ...i } = Oi(t, e); switch (r) { case "referenceHidden": { const s = await Yl(e, { ...i, elementContext: "reference" }), a = ib(s, n.reference); return { data: { referenceHiddenOffsets: a, referenceHidden: ob(a) } } } case "escaped": { const s = await Yl(e, { ...i, altBoundary: !0 }), a = ib(s, n.floating); return { data: { escapedOffsets: a, escaped: ob(a) } } } default: return {} } } } }; async function Oj(t, e) { const { placement: n, platform: r, elements: i } = t, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), a = Mi(n), u = pa(n), c = yo(n) === "y", f = ["left", "top"].includes(a) ? -1 : 1, h = s && c ? -1 : 1, v = Oi(e, t); let { mainAxis: m, crossAxis: g, alignmentAxis: S } = typeof v == "number" ? { mainAxis: v, crossAxis: 0, alignmentAxis: null } : { mainAxis: v.mainAxis || 0, crossAxis: v.crossAxis || 0, alignmentAxis: v.alignmentAxis }; return u && typeof S == "number" && (g = u === "end" ? S * -1 : S), c ? { x: g * h, y: m * f } : { x: m * f, y: g * h } } const Mj = function (t) { return t === void 0 && (t = 0), { name: "offset", options: t, async fn(e) { var n, r; const { x: i, y: s, placement: a, middlewareData: u } = e, c = await Oj(e, t); return a === ((n = u.offset) == null ? void 0 : n.placement) && (r = u.arrow) != null && r.alignmentOffset ? {} : { x: i + c.x, y: s + c.y, data: { ...c, placement: a } } } } }, Vj = function (t) { return t === void 0 && (t = {}), { name: "shift", options: t, async fn(e) { const { x: n, y: r, placement: i } = e, { mainAxis: s = !0, crossAxis: a = !1, limiter: u = { fn: P => { let { x: C, y: F } = P; return { x: C, y: F } } }, ...c } = Oi(t, e), f = { x: n, y: r }, h = await Yl(e, c), v = yo(Mi(i)), m = Mm(v); let g = f[m], S = f[v]; if (s) { const P = m === "y" ? "top" : "left", C = m === "y" ? "bottom" : "right", F = g + h[P], A = g - h[C]; g = W0(F, g, A) } if (a) { const P = v === "y" ? "top" : "left", C = v === "y" ? "bottom" : "right", F = S + h[P], A = S - h[C]; S = W0(F, S, A) } const b = u.fn({ ...e, [m]: g, [v]: S }); return { ...b, data: { x: b.x - n, y: b.y - r, enabled: { [m]: s, [v]: a } } } } } }, Nj = function (t) { return t === void 0 && (t = {}), { options: t, fn(e) { const { x: n, y: r, placement: i, rects: s, middlewareData: a } = e, { offset: u = 0, mainAxis: c = !0, crossAxis: f = !0 } = Oi(t, e), h = { x: n, y: r }, v = yo(i), m = Mm(v); let g = h[m], S = h[v]; const b = Oi(u, e), P = typeof b == "number" ? { mainAxis: b, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...b }; if (c) { const A = m === "y" ? "height" : "width", N = s.reference[m] - s.floating[A] + P.mainAxis, D = s.reference[m] + s.reference[A] - P.mainAxis; g < N ? g = N : g > D && (g = D) } if (f) { var C, F; const A = m === "y" ? "width" : "height", N = ["top", "left"].includes(Mi(i)), D = s.reference[v] - s.floating[A] + (N && ((C = a.offset) == null ? void 0 : C[v]) || 0) + (N ? 0 : P.crossAxis), V = s.reference[v] + s.reference[A] + (N ? 0 : ((F = a.offset) == null ? void 0 : F[v]) || 0) - (N ? P.crossAxis : 0); S < D ? S = D : S > V && (S = V) } return { [m]: g, [v]: S } } } }, Bj = function (t) { return t === void 0 && (t = {}), { name: "size", options: t, async fn(e) { var n, r; const { placement: i, rects: s, platform: a, elements: u } = e, { apply: c = () => { }, ...f } = Oi(t, e), h = await Yl(e, f), v = Mi(i), m = pa(i), g = yo(i) === "y", { width: S, height: b } = s.floating; let P, C; v === "top" || v === "bottom" ? (P = v, C = m === (await (a.isRTL == null ? void 0 : a.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (C = v, P = m === "end" ? "top" : "bottom"); const F = b - h.top - h.bottom, A = S - h.left - h.right, N = go(b - h[P], F), D = go(S - h[C], A), V = !e.middlewareData.shift; let B = N, I = D; if ((n = e.middlewareData.shift) != null && n.enabled.x && (I = A), (r = e.middlewareData.shift) != null && r.enabled.y && (B = F), V && !m) { const Z = tr(h.left, 0), ie = tr(h.right, 0), se = tr(h.top, 0), q = tr(h.bottom, 0); g ? I = S - 2 * (Z !== 0 || ie !== 0 ? Z + ie : tr(h.left, h.right)) : B = b - 2 * (se !== 0 || q !== 0 ? se + q : tr(h.top, h.bottom)) } await c({ ...e, availableWidth: I, availableHeight: B }); const Y = await a.getDimensions(u.floating); return S !== Y.width || b !== Y.height ? { reset: { rects: !0 } } : {} } } }; function cd() { return typeof window < "u" } function va(t) { return H2(t) ? (t.nodeName || "").toLowerCase() : "#document" } function sr(t) { var e; return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window } function ui(t) { var e; return (e = (H2(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement } function H2(t) { return cd() ? t instanceof Node || t instanceof sr(t).Node : !1 } function Gr(t) { return cd() ? t instanceof Element || t instanceof sr(t).Element : !1 } function li(t) { return cd() ? t instanceof HTMLElement || t instanceof sr(t).HTMLElement : !1 } function sb(t) { return !cd() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof sr(t).ShadowRoot } function pu(t) { const { overflow: e, overflowX: n, overflowY: r, display: i } = Xr(t); return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(i) } function Lj(t) { return ["table", "td", "th"].includes(va(t)) } function fd(t) { return [":popover-open", ":modal"].some(e => { try { return t.matches(e) } catch { return !1 } }) } function Bm(t) { const e = Lm(), n = Gr(t) ? Xr(t) : t; return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r)) } function jj(t) { let e = xo(t); for (; li(e) && !sa(e);) { if (Bm(e)) return e; if (fd(e)) return null; e = xo(e) } return null } function Lm() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function sa(t) { return ["html", "body", "#document"].includes(va(t)) } function Xr(t) { return sr(t).getComputedStyle(t) } function dd(t) { return Gr(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.scrollX, scrollTop: t.scrollY } } function xo(t) { if (va(t) === "html") return t; const e = t.assignedSlot || t.parentNode || sb(t) && t.host || ui(t); return sb(e) ? e.host : e } function q2(t) { const e = xo(t); return sa(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : li(e) && pu(e) ? e : q2(e) } function Ql(t, e, n) { var r; e === void 0 && (e = []), n === void 0 && (n = !0); const i = q2(t), s = i === ((r = t.ownerDocument) == null ? void 0 : r.body), a = sr(i); if (s) { const u = H0(a); return e.concat(a, a.visualViewport || [], pu(i) ? i : [], u && n ? Ql(u) : []) } return e.concat(i, Ql(i, [], n)) } function H0(t) { return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null } function G2(t) { const e = Xr(t); let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0; const i = li(t), s = i ? t.offsetWidth : n, a = i ? t.offsetHeight : r, u = Ff(n) !== s || Ff(r) !== a; return u && (n = s, r = a), { width: n, height: r, $: u } } function jm(t) { return Gr(t) ? t : t.contextElement } function _s(t) { const e = jm(t); if (!li(e)) return oi(1); const n = e.getBoundingClientRect(), { width: r, height: i, $: s } = G2(e); let a = (s ? Ff(n.width) : n.width) / r, u = (s ? Ff(n.height) : n.height) / i; return (!a || !Number.isFinite(a)) && (a = 1), (!u || !Number.isFinite(u)) && (u = 1), { x: a, y: u } } const Ij = oi(0); function X2(t) { const e = sr(t); return !Lm() || !e.visualViewport ? Ij : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop } } function zj(t, e, n) { return e === void 0 && (e = !1), !n || e && n !== sr(t) ? !1 : e } function es(t, e, n, r) { e === void 0 && (e = !1), n === void 0 && (n = !1); const i = t.getBoundingClientRect(), s = jm(t); let a = oi(1); e && (r ? Gr(r) && (a = _s(r)) : a = _s(t)); const u = zj(s, n, r) ? X2(s) : oi(0); let c = (i.left + u.x) / a.x, f = (i.top + u.y) / a.y, h = i.width / a.x, v = i.height / a.y; if (s) { const m = sr(s), g = r && Gr(r) ? sr(r) : r; let S = m, b = H0(S); for (; b && r && g !== S;) { const P = _s(b), C = b.getBoundingClientRect(), F = Xr(b), A = C.left + (b.clientLeft + parseFloat(F.paddingLeft)) * P.x, N = C.top + (b.clientTop + parseFloat(F.paddingTop)) * P.y; c *= P.x, f *= P.y, h *= P.x, v *= P.y, c += A, f += N, S = sr(b), b = H0(S) } } return Df({ width: h, height: v, x: c, y: f }) } function Im(t, e) { const n = dd(t).scrollLeft; return e ? e.left + n : es(ui(t)).left + n } function Z2(t, e, n) { n === void 0 && (n = !1); const r = t.getBoundingClientRect(), i = r.left + e.scrollLeft - (n ? 0 : Im(t, r)), s = r.top + e.scrollTop; return { x: i, y: s } } function Uj(t) { let { elements: e, rect: n, offsetParent: r, strategy: i } = t; const s = i === "fixed", a = ui(r), u = e ? fd(e.floating) : !1; if (r === a || u && s) return n; let c = { scrollLeft: 0, scrollTop: 0 }, f = oi(1); const h = oi(0), v = li(r); if ((v || !v && !s) && ((va(r) !== "body" || pu(a)) && (c = dd(r)), li(r))) { const g = es(r); f = _s(r), h.x = g.x + r.clientLeft, h.y = g.y + r.clientTop } const m = a && !v && !s ? Z2(a, c, !0) : oi(0); return { width: n.width * f.x, height: n.height * f.y, x: n.x * f.x - c.scrollLeft * f.x + h.x + m.x, y: n.y * f.y - c.scrollTop * f.y + h.y + m.y } } function Wj(t) { return Array.from(t.getClientRects()) } function Kj(t) { const e = ui(t), n = dd(t), r = t.ownerDocument.body, i = tr(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = tr(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight); let a = -n.scrollLeft + Im(t); const u = -n.scrollTop; return Xr(r).direction === "rtl" && (a += tr(e.clientWidth, r.clientWidth) - i), { width: i, height: s, x: a, y: u } } function Hj(t, e) { const n = sr(t), r = ui(t), i = n.visualViewport; let s = r.clientWidth, a = r.clientHeight, u = 0, c = 0; if (i) { s = i.width, a = i.height; const f = Lm(); (!f || f && e === "fixed") && (u = i.offsetLeft, c = i.offsetTop) } return { width: s, height: a, x: u, y: c } } function qj(t, e) { const n = es(t, !0, e === "fixed"), r = n.top + t.clientTop, i = n.left + t.clientLeft, s = li(t) ? _s(t) : oi(1), a = t.clientWidth * s.x, u = t.clientHeight * s.y, c = i * s.x, f = r * s.y; return { width: a, height: u, x: c, y: f } } function ab(t, e, n) { let r; if (e === "viewport") r = Hj(t, n); else if (e === "document") r = Kj(ui(t)); else if (Gr(e)) r = qj(e, n); else { const i = X2(t); r = { x: e.x - i.x, y: e.y - i.y, width: e.width, height: e.height } } return Df(r) } function Y2(t, e) { const n = xo(t); return n === e || !Gr(n) || sa(n) ? !1 : Xr(n).position === "fixed" || Y2(n, e) } function Gj(t, e) { const n = e.get(t); if (n) return n; let r = Ql(t, [], !1).filter(u => Gr(u) && va(u) !== "body"), i = null; const s = Xr(t).position === "fixed"; let a = s ? xo(t) : t; for (; Gr(a) && !sa(a);) { const u = Xr(a), c = Bm(a); !c && u.position === "fixed" && (i = null), (s ? !c && !i : !c && u.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || pu(a) && !c && Y2(t, a)) ? r = r.filter(h => h !== a) : i = u, a = xo(a) } return e.set(t, r), r } function Xj(t) { let { element: e, boundary: n, rootBoundary: r, strategy: i } = t; const a = [...n === "clippingAncestors" ? fd(e) ? [] : Gj(e, this._c) : [].concat(n), r], u = a[0], c = a.reduce((f, h) => { const v = ab(e, h, i); return f.top = tr(v.top, f.top), f.right = go(v.right, f.right), f.bottom = go(v.bottom, f.bottom), f.left = tr(v.left, f.left), f }, ab(e, u, i)); return { width: c.right - c.left, height: c.bottom - c.top, x: c.left, y: c.top } } function Zj(t) { const { width: e, height: n } = G2(t); return { width: e, height: n } } function Yj(t, e, n) { const r = li(e), i = ui(e), s = n === "fixed", a = es(t, !0, s, e); let u = { scrollLeft: 0, scrollTop: 0 }; const c = oi(0); if (r || !r && !s) if ((va(e) !== "body" || pu(i)) && (u = dd(e)), r) { const m = es(e, !0, s, e); c.x = m.x + e.clientLeft, c.y = m.y + e.clientTop } else i && (c.x = Im(i)); const f = i && !r && !s ? Z2(i, u) : oi(0), h = a.left + u.scrollLeft - c.x - f.x, v = a.top + u.scrollTop - c.y - f.y; return { x: h, y: v, width: a.width, height: a.height } } function Kp(t) { return Xr(t).position === "static" } function lb(t, e) { if (!li(t) || Xr(t).position === "fixed") return null; if (e) return e(t); let n = t.offsetParent; return ui(t) === n && (n = n.ownerDocument.body), n } function Q2(t, e) { const n = sr(t); if (fd(t)) return n; if (!li(t)) { let i = xo(t); for (; i && !sa(i);) { if (Gr(i) && !Kp(i)) return i; i = xo(i) } return n } let r = lb(t, e); for (; r && Lj(r) && Kp(r);)r = lb(r, e); return r && sa(r) && Kp(r) && !Bm(r) ? n : r || jj(t) || n } const Qj = async function (t) { const e = this.getOffsetParent || Q2, n = this.getDimensions, r = await n(t.floating); return { reference: Yj(t.reference, await e(t.floating), t.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } } }; function Jj(t) { return Xr(t).direction === "rtl" } const _j = { convertOffsetParentRelativeRectToViewportRelativeRect: Uj, getDocumentElement: ui, getClippingRect: Xj, getOffsetParent: Q2, getElementRects: Qj, getClientRects: Wj, getDimensions: Zj, getScale: _s, isElement: Gr, isRTL: Jj }; function $j(t, e) { let n = null, r; const i = ui(t); function s() { var u; clearTimeout(r), (u = n) == null || u.disconnect(), n = null } function a(u, c) { u === void 0 && (u = !1), c === void 0 && (c = 1), s(); const { left: f, top: h, width: v, height: m } = t.getBoundingClientRect(); if (u || e(), !v || !m) return; const g = Ic(h), S = Ic(i.clientWidth - (f + v)), b = Ic(i.clientHeight - (h + m)), P = Ic(f), F = { rootMargin: -g + "px " + -S + "px " + -b + "px " + -P + "px", threshold: tr(0, go(1, c)) || 1 }; let A = !0; function N(D) { const V = D[0].intersectionRatio; if (V !== c) { if (!A) return a(); V ? a(!1, V) : r = setTimeout(() => { a(!1, 1e-7) }, 1e3) } A = !1 } try { n = new IntersectionObserver(N, { ...F, root: i.ownerDocument }) } catch { n = new IntersectionObserver(N, F) } n.observe(t) } return a(!0), s } function eI(t, e, n, r) { r === void 0 && (r = {}); const { ancestorScroll: i = !0, ancestorResize: s = !0, elementResize: a = typeof ResizeObserver == "function", layoutShift: u = typeof IntersectionObserver == "function", animationFrame: c = !1 } = r, f = jm(t), h = i || s ? [...f ? Ql(f) : [], ...Ql(e)] : []; h.forEach(C => { i && C.addEventListener("scroll", n, { passive: !0 }), s && C.addEventListener("resize", n) }); const v = f && u ? $j(f, n) : null; let m = -1, g = null; a && (g = new ResizeObserver(C => { let [F] = C; F && F.target === f && g && (g.unobserve(e), cancelAnimationFrame(m), m = requestAnimationFrame(() => { var A; (A = g) == null || A.observe(e) })), n() }), f && !c && g.observe(f), g.observe(e)); let S, b = c ? es(t) : null; c && P(); function P() { const C = es(t); b && (C.x !== b.x || C.y !== b.y || C.width !== b.width || C.height !== b.height) && n(), b = C, S = requestAnimationFrame(P) } return n(), () => { var C; h.forEach(F => { i && F.removeEventListener("scroll", n), s && F.removeEventListener("resize", n) }), v == null || v(), (C = g) == null || C.disconnect(), g = null, c && cancelAnimationFrame(S) } } const tI = Mj, nI = Vj, rI = Rj, iI = Bj, oI = Dj, ub = Fj, sI = Nj, aI = (t, e, n) => { const r = new Map, i = { platform: _j, ...n }, s = { ...i.platform, _c: r }; return Ej(t, e, { ...i, platform: s }) }; var _c = typeof document < "u" ? j.useLayoutEffect : j.useEffect; function Of(t, e) { if (t === e) return !0; if (typeof t != typeof e) return !1; if (typeof t == "function" && t.toString() === e.toString()) return !0; let n, r, i; if (t && e && typeof t == "object") { if (Array.isArray(t)) { if (n = t.length, n !== e.length) return !1; for (r = n; r-- !== 0;)if (!Of(t[r], e[r])) return !1; return !0 } if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length) return !1; for (r = n; r-- !== 0;)if (!{}.hasOwnProperty.call(e, i[r])) return !1; for (r = n; r-- !== 0;) { const s = i[r]; if (!(s === "_owner" && t.$$typeof) && !Of(t[s], e[s])) return !1 } return !0 } return t !== t && e !== e } function J2(t) { return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1 } function cb(t, e) { const n = J2(t); return Math.round(e * n) / n } function Hp(t) { const e = j.useRef(t); return _c(() => { e.current = t }), e } function lI(t) { t === void 0 && (t = {}); const { placement: e = "bottom", strategy: n = "absolute", middleware: r = [], platform: i, elements: { reference: s, floating: a } = {}, transform: u = !0, whileElementsMounted: c, open: f } = t, [h, v] = j.useState({ x: 0, y: 0, strategy: n, placement: e, middlewareData: {}, isPositioned: !1 }), [m, g] = j.useState(r); Of(m, r) || g(r); const [S, b] = j.useState(null), [P, C] = j.useState(null), F = j.useCallback(Q => { Q !== V.current && (V.current = Q, b(Q)) }, []), A = j.useCallback(Q => { Q !== B.current && (B.current = Q, C(Q)) }, []), N = s || S, D = a || P, V = j.useRef(null), B = j.useRef(null), I = j.useRef(h), Y = c != null, Z = Hp(c), ie = Hp(i), se = Hp(f), q = j.useCallback(() => { if (!V.current || !B.current) return; const Q = { placement: e, strategy: n, middleware: m }; ie.current && (Q.platform = ie.current), aI(V.current, B.current, Q).then(le => { const ce = { ...le, isPositioned: se.current !== !1 }; ue.current && !Of(I.current, ce) && (I.current = ce, R2.flushSync(() => { v(ce) })) }) }, [m, e, n, ie, se]); _c(() => { f === !1 && I.current.isPositioned && (I.current.isPositioned = !1, v(Q => ({ ...Q, isPositioned: !1 }))) }, [f]); const ue = j.useRef(!1); _c(() => (ue.current = !0, () => { ue.current = !1 }), []), _c(() => { if (N && (V.current = N), D && (B.current = D), N && D) { if (Z.current) return Z.current(N, D, q); q() } }, [N, D, q, Z, Y]); const ye = j.useMemo(() => ({ reference: V, floating: B, setReference: F, setFloating: A }), [F, A]), ae = j.useMemo(() => ({ reference: N, floating: D }), [N, D]), _ = j.useMemo(() => { const Q = { position: n, left: 0, top: 0 }; if (!ae.floating) return Q; const le = cb(ae.floating, h.x), ce = cb(ae.floating, h.y); return u ? { ...Q, transform: "translate(" + le + "px, " + ce + "px)", ...J2(ae.floating) >= 1.5 && { willChange: "transform" } } : { position: n, left: le, top: ce } }, [n, u, ae.floating, h.x, h.y]); return j.useMemo(() => ({ ...h, update: q, refs: ye, elements: ae, floatingStyles: _ }), [h, q, ye, ae, _]) } const uI = t => { function e(n) { return {}.hasOwnProperty.call(n, "current") } return { name: "arrow", options: t, fn(n) { const { element: r, padding: i } = typeof t == "function" ? t(n) : t; return r && e(r) ? r.current != null ? ub({ element: r.current, padding: i }).fn(n) : {} : r ? ub({ element: r, padding: i }).fn(n) : {} } } }, cI = (t, e) => ({ ...tI(t), options: [t, e] }), fI = (t, e) => ({ ...nI(t), options: [t, e] }), dI = (t, e) => ({ ...sI(t), options: [t, e] }), hI = (t, e) => ({ ...rI(t), options: [t, e] }), pI = (t, e) => ({ ...iI(t), options: [t, e] }), vI = (t, e) => ({ ...oI(t), options: [t, e] }), mI = (t, e) => ({ ...uI(t), options: [t, e] }); var gI = "Arrow", _2 = j.forwardRef((t, e) => { const { children: n, width: r = 10, height: i = 5, ...s } = t; return De.jsx(ls.svg, { ...s, ref: e, width: r, height: i, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: t.asChild ? n : De.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); _2.displayName = gI; var yI = _2; function xI(t) { const [e, n] = j.useState(void 0); return Zl(() => { if (t) { n({ width: t.offsetWidth, height: t.offsetHeight }); const r = new ResizeObserver(i => { if (!Array.isArray(i) || !i.length) return; const s = i[0]; let a, u; if ("borderBoxSize" in s) { const c = s.borderBoxSize, f = Array.isArray(c) ? c[0] : c; a = f.inlineSize, u = f.blockSize } else a = t.offsetWidth, u = t.offsetHeight; n({ width: a, height: u }) }); return r.observe(t, { box: "border-box" }), () => r.unobserve(t) } else n(void 0) }, [t]), e } var $2 = "Popper", [ek, tk] = V2($2), [hz, nk] = ek($2), rk = "PopperAnchor", ik = j.forwardRef((t, e) => { const { __scopePopper: n, virtualRef: r, ...i } = t, s = nk(rk, n), a = j.useRef(null), u = as(e, a); return j.useEffect(() => { s.onAnchorChange((r == null ? void 0 : r.current) || a.current) }), r ? null : De.jsx(ls.div, { ...i, ref: u }) }); ik.displayName = rk; var zm = "PopperContent", [wI, SI] = ek(zm), ok = j.forwardRef((t, e) => { var Ie, be, Je, pt, Qt, ht; const { __scopePopper: n, side: r = "bottom", sideOffset: i = 0, align: s = "center", alignOffset: a = 0, arrowPadding: u = 0, avoidCollisions: c = !0, collisionBoundary: f = [], collisionPadding: h = 0, sticky: v = "partial", hideWhenDetached: m = !1, updatePositionStrategy: g = "optimized", onPlaced: S, ...b } = t, P = nk(zm, n), [C, F] = j.useState(null), A = as(e, Et => F(Et)), [N, D] = j.useState(null), V = xI(N), B = (V == null ? void 0 : V.width) ?? 0, I = (V == null ? void 0 : V.height) ?? 0, Y = r + (s !== "center" ? "-" + s : ""), Z = typeof h == "number" ? h : { top: 0, right: 0, bottom: 0, left: 0, ...h }, ie = Array.isArray(f) ? f : [f], se = ie.length > 0, q = { padding: Z, boundary: ie.filter(CI), altBoundary: se }, { refs: ue, floatingStyles: ye, placement: ae, isPositioned: _, middlewareData: Q } = lI({ strategy: "fixed", placement: Y, whileElementsMounted: (...Et) => eI(...Et, { animationFrame: g === "always" }), elements: { reference: P.anchor }, middleware: [cI({ mainAxis: i + I, alignmentAxis: a }), c && fI({ mainAxis: !0, crossAxis: !1, limiter: v === "partial" ? dI() : void 0, ...q }), c && hI({ ...q }), pI({ ...q, apply: ({ elements: Et, rects: jn, availableWidth: vn, availableHeight: un }) => { const { width: Ct, height: it } = jn.reference, Kt = Et.floating.style; Kt.setProperty("--radix-popper-available-width", `${vn}px`), Kt.setProperty("--radix-popper-available-height", `${un}px`), Kt.setProperty("--radix-popper-anchor-width", `${Ct}px`), Kt.setProperty("--radix-popper-anchor-height", `${it}px`) } }), N && mI({ element: N, padding: u }), PI({ arrowWidth: B, arrowHeight: I }), m && vI({ strategy: "referenceHidden", ...q })] }), [le, ce] = lk(ae), W = ud(S); Zl(() => { _ && (W == null || W()) }, [_, W]); const re = (Ie = Q.arrow) == null ? void 0 : Ie.x, Ae = (be = Q.arrow) == null ? void 0 : be.y, Fe = ((Je = Q.arrow) == null ? void 0 : Je.centerOffset) !== 0, [Be, Ee] = j.useState(); return Zl(() => { C && Ee(window.getComputedStyle(C).zIndex) }, [C]), De.jsx("div", { ref: ue.setFloating, "data-radix-popper-content-wrapper": "", style: { ...ye, transform: _ ? ye.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: Be, "--radix-popper-transform-origin": [(pt = Q.transformOrigin) == null ? void 0 : pt.x, (Qt = Q.transformOrigin) == null ? void 0 : Qt.y].join(" "), ...((ht = Q.hide) == null ? void 0 : ht.referenceHidden) && { visibility: "hidden", pointerEvents: "none" } }, dir: t.dir, children: De.jsx(wI, { scope: n, placedSide: le, onArrowChange: D, arrowX: re, arrowY: Ae, shouldHideArrow: Fe, children: De.jsx(ls.div, { "data-side": le, "data-align": ce, ...b, ref: A, style: { ...b.style, animation: _ ? void 0 : "none" } }) }) }) }); ok.displayName = zm; var sk = "PopperArrow", bI = { top: "bottom", right: "left", bottom: "top", left: "right" }, ak = j.forwardRef(function (e, n) { const { __scopePopper: r, ...i } = e, s = SI(sk, r), a = bI[s.placedSide]; return De.jsx("span", { ref: s.onArrowChange, style: { position: "absolute", left: s.arrowX, top: s.arrowY, [a]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[s.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[s.placedSide], visibility: s.shouldHideArrow ? "hidden" : void 0 }, children: De.jsx(yI, { ...i, ref: n, style: { ...i.style, display: "block" } }) }) }); ak.displayName = sk; function CI(t) { return t !== null } var PI = t => ({ name: "transformOrigin", options: t, fn(e) { var P, C, F; const { placement: n, rects: r, middlewareData: i } = e, a = ((P = i.arrow) == null ? void 0 : P.centerOffset) !== 0, u = a ? 0 : t.arrowWidth, c = a ? 0 : t.arrowHeight, [f, h] = lk(n), v = { start: "0%", center: "50%", end: "100%" }[h], m = (((C = i.arrow) == null ? void 0 : C.x) ?? 0) + u / 2, g = (((F = i.arrow) == null ? void 0 : F.y) ?? 0) + c / 2; let S = "", b = ""; return f === "bottom" ? (S = a ? v : `${m}px`, b = `${-c}px`) : f === "top" ? (S = a ? v : `${m}px`, b = `${r.floating.height + c}px`) : f === "right" ? (S = `${-c}px`, b = a ? v : `${g}px`) : f === "left" && (S = `${r.floating.width + c}px`, b = a ? v : `${g}px`), { data: { x: S, y: b } } } }); function lk(t) { const [e, n = "center"] = t.split("-"); return [e, n] } var TI = ik, kI = ok, AI = ak, [hd, pz] = V2("Tooltip", [tk]), Um = tk(), uk = "TooltipProvider", EI = 700, fb = "tooltip.open", [FI, ck] = hd(uk), fk = t => { const { __scopeTooltip: e, delayDuration: n = EI, skipDelayDuration: r = 300, disableHoverableContent: i = !1, children: s } = t, [a, u] = j.useState(!0), c = j.useRef(!1), f = j.useRef(0); return j.useEffect(() => { const h = f.current; return () => window.clearTimeout(h) }, []), De.jsx(FI, { scope: e, isOpenDelayed: a, delayDuration: n, onOpen: j.useCallback(() => { window.clearTimeout(f.current), u(!1) }, []), onClose: j.useCallback(() => { window.clearTimeout(f.current), f.current = window.setTimeout(() => u(!0), r) }, [r]), isPointerInTransitRef: c, onPointerInTransitChange: j.useCallback(h => { c.current = h }, []), disableHoverableContent: i, children: s }) }; fk.displayName = uk; var dk = "Tooltip", [vz, pd] = hd(dk), q0 = "TooltipTrigger", RI = j.forwardRef((t, e) => { const { __scopeTooltip: n, ...r } = t, i = pd(q0, n), s = ck(q0, n), a = Um(n), u = j.useRef(null), c = as(e, u, i.onTriggerChange), f = j.useRef(!1), h = j.useRef(!1), v = j.useCallback(() => f.current = !1, []); return j.useEffect(() => () => document.removeEventListener("pointerup", v), [v]), De.jsx(TI, { asChild: !0, ...a, children: De.jsx(ls.button, { "aria-describedby": i.open ? i.contentId : void 0, "data-state": i.stateAttribute, ...r, ref: c, onPointerMove: bi(t.onPointerMove, m => { m.pointerType !== "touch" && !h.current && !s.isPointerInTransitRef.current && (i.onTriggerEnter(), h.current = !0) }), onPointerLeave: bi(t.onPointerLeave, () => { i.onTriggerLeave(), h.current = !1 }), onPointerDown: bi(t.onPointerDown, () => { f.current = !0, document.addEventListener("pointerup", v, { once: !0 }) }), onFocus: bi(t.onFocus, () => { f.current || i.onOpen() }), onBlur: bi(t.onBlur, i.onClose), onClick: bi(t.onClick, i.onClose) }) }) }); RI.displayName = q0; var DI = "TooltipPortal", [mz, OI] = hd(DI, { forceMount: void 0 }), aa = "TooltipContent", MI = j.forwardRef((t, e) => { const n = OI(aa, t.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...s } = t, a = pd(aa, t.__scopeTooltip); return De.jsx(j2, { present: r || a.open, children: a.disableHoverableContent ? De.jsx(hk, { side: i, ...s, ref: e }) : De.jsx(VI, { side: i, ...s, ref: e }) }) }), VI = j.forwardRef((t, e) => { const n = pd(aa, t.__scopeTooltip), r = ck(aa, t.__scopeTooltip), i = j.useRef(null), s = as(e, i), [a, u] = j.useState(null), { trigger: c, onClose: f } = n, h = i.current, { onPointerInTransitChange: v } = r, m = j.useCallback(() => { u(null), v(!1) }, [v]), g = j.useCallback((S, b) => { const P = S.currentTarget, C = { x: S.clientX, y: S.clientY }, F = jI(C, P.getBoundingClientRect()), A = II(C, F), N = zI(b.getBoundingClientRect()), D = WI([...A, ...N]); u(D), v(!0) }, [v]); return j.useEffect(() => () => m(), [m]), j.useEffect(() => { if (c && h) { const S = P => g(P, h), b = P => g(P, c); return c.addEventListener("pointerleave", S), h.addEventListener("pointerleave", b), () => { c.removeEventListener("pointerleave", S), h.removeEventListener("pointerleave", b) } } }, [c, h, g, m]), j.useEffect(() => { if (a) { const S = b => { const P = b.target, C = { x: b.clientX, y: b.clientY }, F = (c == null ? void 0 : c.contains(P)) || (h == null ? void 0 : h.contains(P)), A = !UI(C, a); F ? m() : A && (m(), f()) }; return document.addEventListener("pointermove", S), () => document.removeEventListener("pointermove", S) } }, [c, h, a, f, m]), De.jsx(hk, { ...t, ref: s }) }), [NI, BI] = hd(dk, { isInside: !1 }), hk = j.forwardRef((t, e) => { const { __scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: s, onPointerDownOutside: a, ...u } = t, c = pd(aa, n), f = Um(n), { onClose: h } = c; return j.useEffect(() => (document.addEventListener(fb, h), () => document.removeEventListener(fb, h)), [h]), j.useEffect(() => { if (c.trigger) { const v = m => { const g = m.target; g != null && g.contains(c.trigger) && h() }; return window.addEventListener("scroll", v, { capture: !0 }), () => window.removeEventListener("scroll", v, { capture: !0 }) } }, [c.trigger, h]), De.jsx(B2, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: s, onPointerDownOutside: a, onFocusOutside: v => v.preventDefault(), onDismiss: h, children: De.jsxs(kI, { "data-state": c.stateAttribute, ...f, ...u, ref: e, style: { ...u.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }, children: [De.jsx(O2, { children: r }), De.jsx(NI, { scope: n, isInside: !0, children: De.jsx(IL, { id: c.contentId, role: "tooltip", children: i || r }) })] }) }) }); MI.displayName = aa; var pk = "TooltipArrow", LI = j.forwardRef((t, e) => { const { __scopeTooltip: n, ...r } = t, i = Um(n); return BI(pk, n).isInside ? null : De.jsx(AI, { ...i, ...r, ref: e }) }); LI.displayName = pk; function jI(t, e) { const n = Math.abs(e.top - t.y), r = Math.abs(e.bottom - t.y), i = Math.abs(e.right - t.x), s = Math.abs(e.left - t.x); switch (Math.min(n, r, i, s)) { case s: return "left"; case i: return "right"; case n: return "top"; case r: return "bottom"; default: throw new Error("unreachable") } } function II(t, e, n = 5) { const r = []; switch (e) { case "top": r.push({ x: t.x - n, y: t.y + n }, { x: t.x + n, y: t.y + n }); break; case "bottom": r.push({ x: t.x - n, y: t.y - n }, { x: t.x + n, y: t.y - n }); break; case "left": r.push({ x: t.x + n, y: t.y - n }, { x: t.x + n, y: t.y + n }); break; case "right": r.push({ x: t.x - n, y: t.y - n }, { x: t.x - n, y: t.y + n }); break }return r } function zI(t) { const { top: e, right: n, bottom: r, left: i } = t; return [{ x: i, y: e }, { x: n, y: e }, { x: n, y: r }, { x: i, y: r }] } function UI(t, e) { const { x: n, y: r } = t; let i = !1; for (let s = 0, a = e.length - 1; s < e.length; a = s++) { const u = e[s].x, c = e[s].y, f = e[a].x, h = e[a].y; c > r != h > r && n < (f - u) * (r - c) / (h - c) + u && (i = !i) } return i } function WI(t) { const e = t.slice(); return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), KI(e) } function KI(t) { if (t.length <= 1) return t.slice(); const e = []; for (let r = 0; r < t.length; r++) { const i = t[r]; for (; e.length >= 2;) { const s = e[e.length - 1], a = e[e.length - 2]; if ((s.x - a.x) * (i.y - a.y) >= (s.y - a.y) * (i.x - a.x)) e.pop(); else break } e.push(i) } e.pop(); const n = []; for (let r = t.length - 1; r >= 0; r--) { const i = t[r]; for (; n.length >= 2;) { const s = n[n.length - 1], a = n[n.length - 2]; if ((s.x - a.x) * (i.y - a.y) >= (s.y - a.y) * (i.x - a.x)) n.pop(); else break } n.push(i) } return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n) } var HI = fk, qI = j.createContext(void 0), GI = t => { const { dir: e, children: n } = t; return De.jsx(qI.Provider, { value: e, children: n }) }; function XI(t) { switch (t) { case "tomato": case "red": case "ruby": case "crimson": case "pink": case "plum": case "purple": case "violet": return "mauve"; case "iris": case "indigo": case "blue": case "sky": case "cyan": return "slate"; case "teal": case "jade": case "mint": case "green": return "sage"; case "grass": case "lime": return "olive"; case "yellow": case "amber": case "orange": case "brown": case "gold": case "bronze": return "sand"; case "gray": return "gray" } } const ZI = ["none", "small", "medium", "large", "full"], YI = ["inherit", "light", "dark"], QI = ["solid", "translucent"], JI = ["90%", "95%", "100%", "105%", "110%"], er = { ...I2, hasBackground: { type: "boolean", default: !0 }, appearance: { type: "enum", values: YI, default: "inherit" }, accentColor: { type: "enum", values: z2, default: "indigo" }, grayColor: { type: "enum", values: ej, default: "auto" }, panelBackground: { type: "enum", values: QI, default: "translucent" }, radius: { type: "enum", values: ZI, default: "medium" }, scaling: { type: "enum", values: JI, default: "100%" } }, Ls = () => { }, G0 = j.createContext(void 0), vk = j.forwardRef((t, e) => j.useContext(G0) === void 0 ? j.createElement(HI, { delayDuration: 200 }, j.createElement(GI, { dir: "ltr" }, j.createElement(mk, { ...t, ref: e }))) : j.createElement(Wm, { ...t, ref: e })); vk.displayName = "Theme"; const mk = j.forwardRef((t, e) => { const { appearance: n = er.appearance.default, accentColor: r = er.accentColor.default, grayColor: i = er.grayColor.default, panelBackground: s = er.panelBackground.default, radius: a = er.radius.default, scaling: u = er.scaling.default, hasBackground: c = er.hasBackground.default, ...f } = t, [h, v] = j.useState(n); j.useEffect(() => v(n), [n]); const [m, g] = j.useState(r); j.useEffect(() => g(r), [r]); const [S, b] = j.useState(i); j.useEffect(() => b(i), [i]); const [P, C] = j.useState(s); j.useEffect(() => C(s), [s]); const [F, A] = j.useState(a); j.useEffect(() => A(a), [a]); const [N, D] = j.useState(u); return j.useEffect(() => D(u), [u]), j.createElement(Wm, { ...f, ref: e, isRoot: !0, hasBackground: c, appearance: h, accentColor: m, grayColor: S, panelBackground: P, radius: F, scaling: N, onAppearanceChange: v, onAccentColorChange: g, onGrayColorChange: b, onPanelBackgroundChange: C, onRadiusChange: A, onScalingChange: D }) }); mk.displayName = "ThemeRoot"; const Wm = j.forwardRef((t, e) => { const n = j.useContext(G0), { asChild: r, isRoot: i, hasBackground: s, appearance: a = (n == null ? void 0 : n.appearance) ?? er.appearance.default, accentColor: u = (n == null ? void 0 : n.accentColor) ?? er.accentColor.default, grayColor: c = (n == null ? void 0 : n.resolvedGrayColor) ?? er.grayColor.default, panelBackground: f = (n == null ? void 0 : n.panelBackground) ?? er.panelBackground.default, radius: h = (n == null ? void 0 : n.radius) ?? er.radius.default, scaling: v = (n == null ? void 0 : n.scaling) ?? er.scaling.default, onAppearanceChange: m = Ls, onAccentColorChange: g = Ls, onGrayColorChange: S = Ls, onPanelBackgroundChange: b = Ls, onRadiusChange: P = Ls, onScalingChange: C = Ls, ...F } = t, A = r ? ld : "div", N = c === "auto" ? XI(u) : c, D = t.appearance === "light" || t.appearance === "dark", V = s === void 0 ? i || D : s; return j.createElement(G0.Provider, { value: j.useMemo(() => ({ appearance: a, accentColor: u, grayColor: c, resolvedGrayColor: N, panelBackground: f, radius: h, scaling: v, onAppearanceChange: m, onAccentColorChange: g, onGrayColorChange: S, onPanelBackgroundChange: b, onRadiusChange: P, onScalingChange: C }), [a, u, c, N, f, h, v, m, g, S, b, P, C]) }, j.createElement(A, { "data-is-root-theme": i ? "true" : "false", "data-accent-color": u, "data-gray-color": N, "data-has-background": V ? "true" : "false", "data-panel-background": f, "data-radius": h, "data-scaling": v, ref: e, ...F, className: Qs("radix-themes", { light: a === "light", dark: a === "dark" }, F.className) })) }); Wm.displayName = "ThemeImpl"; function X0() { return X0 = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, X0.apply(this, arguments) } var _I = { strings: ["These are the default values...", "You know what you should do?", "Use your own!", "Have a great day!"], stringsElement: null, typeSpeed: 0, startDelay: 0, backSpeed: 0, smartBackspace: !0, shuffle: !1, backDelay: 700, fadeOut: !1, fadeOutClass: "typed-fade-out", fadeOutDelay: 500, loop: !1, loopCount: 1 / 0, showCursor: !0, cursorChar: "|", autoInsertCss: !0, attr: null, bindInputFocusEvents: !1, contentType: "html", onBegin: function (t) { }, onComplete: function (t) { }, preStringTyped: function (t, e) { }, onStringTyped: function (t, e) { }, onLastStringBackspaced: function (t) { }, onTypingPaused: function (t, e) { }, onTypingResumed: function (t, e) { }, onReset: function (t) { }, onStop: function (t, e) { }, onStart: function (t, e) { }, onDestroy: function (t) { } }, $I = new (function () {
  function t() { } var e = t.prototype; return e.load = function (n, r, i) { if (n.el = typeof i == "string" ? document.querySelector(i) : i, n.options = X0({}, _I, r), n.isInput = n.el.tagName.toLowerCase() === "input", n.attr = n.options.attr, n.bindInputFocusEvents = n.options.bindInputFocusEvents, n.showCursor = !n.isInput && n.options.showCursor, n.cursorChar = n.options.cursorChar, n.cursorBlinking = !0, n.elContent = n.attr ? n.el.getAttribute(n.attr) : n.el.textContent, n.contentType = n.options.contentType, n.typeSpeed = n.options.typeSpeed, n.startDelay = n.options.startDelay, n.backSpeed = n.options.backSpeed, n.smartBackspace = n.options.smartBackspace, n.backDelay = n.options.backDelay, n.fadeOut = n.options.fadeOut, n.fadeOutClass = n.options.fadeOutClass, n.fadeOutDelay = n.options.fadeOutDelay, n.isPaused = !1, n.strings = n.options.strings.map(function (f) { return f.trim() }), n.stringsElement = typeof n.options.stringsElement == "string" ? document.querySelector(n.options.stringsElement) : n.options.stringsElement, n.stringsElement) { n.strings = [], n.stringsElement.style.cssText = "clip: rect(0 0 0 0);clip-path:inset(50%);height:1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px;"; var s = Array.prototype.slice.apply(n.stringsElement.children), a = s.length; if (a) for (var u = 0; u < a; u += 1)n.strings.push(s[u].innerHTML.trim()) } for (var c in n.strPos = 0, n.currentElContent = this.getCurrentElContent(n), n.currentElContent && n.currentElContent.length > 0 && (n.strPos = n.currentElContent.length - 1, n.strings.unshift(n.currentElContent)), n.sequence = [], n.strings) n.sequence[c] = c; n.arrayPos = 0, n.stopNum = 0, n.loop = n.options.loop, n.loopCount = n.options.loopCount, n.curLoop = 0, n.shuffle = n.options.shuffle, n.pause = { status: !1, typewrite: !0, curString: "", curStrPos: 0 }, n.typingComplete = !1, n.autoInsertCss = n.options.autoInsertCss, n.autoInsertCss && (this.appendCursorAnimationCss(n), this.appendFadeOutAnimationCss(n)) }, e.getCurrentElContent = function (n) { return n.attr ? n.el.getAttribute(n.attr) : n.isInput ? n.el.value : n.contentType === "html" ? n.el.innerHTML : n.el.textContent }, e.appendCursorAnimationCss = function (n) {
    var r = "data-typed-js-cursor-css"; if (n.showCursor && !document.querySelector("[" + r + "]")) {
      var i = document.createElement("style"); i.setAttribute(r, "true"), i.innerHTML = `
        .typed-cursor{
          opacity: 1;
        }
        .typed-cursor.typed-cursor--blink{
          animation: typedjsBlink 0.7s infinite;
          -webkit-animation: typedjsBlink 0.7s infinite;
                  animation: typedjsBlink 0.7s infinite;
        }
        @keyframes typedjsBlink{
          50% { opacity: 0.0; }
        }
        @-webkit-keyframes typedjsBlink{
          0% { opacity: 1; }
          50% { opacity: 0.0; }
          100% { opacity: 1; }
        }
      `, document.body.appendChild(i)
    }
  }, e.appendFadeOutAnimationCss = function (n) {
    var r = "data-typed-fadeout-js-css"; if (n.fadeOut && !document.querySelector("[" + r + "]")) {
      var i = document.createElement("style"); i.setAttribute(r, "true"), i.innerHTML = `
        .typed-fade-out{
          opacity: 0;
          transition: opacity .25s;
        }
        .typed-cursor.typed-cursor--blink.typed-fade-out{
          -webkit-animation: 0;
          animation: 0;
        }
      `, document.body.appendChild(i)
    }
  }, t
}()), db = new (function () { function t() { } var e = t.prototype; return e.typeHtmlChars = function (n, r, i) { if (i.contentType !== "html") return r; var s = n.substring(r).charAt(0); if (s === "<" || s === "&") { var a; for (a = s === "<" ? ">" : ";"; n.substring(r + 1).charAt(0) !== a && !(1 + ++r > n.length);); r++ } return r }, e.backSpaceHtmlChars = function (n, r, i) { if (i.contentType !== "html") return r; var s = n.substring(r).charAt(0); if (s === ">" || s === ";") { var a; for (a = s === ">" ? "<" : "&"; n.substring(r - 1).charAt(0) !== a && !(--r < 0);); r-- } return r }, t }()), e4 = function () { function t(n, r) { $I.load(this, r, n), this.begin() } var e = t.prototype; return e.toggle = function () { this.pause.status ? this.start() : this.stop() }, e.stop = function () { this.typingComplete || this.pause.status || (this.toggleBlinking(!0), this.pause.status = !0, this.options.onStop(this.arrayPos, this)) }, e.start = function () { this.typingComplete || this.pause.status && (this.pause.status = !1, this.pause.typewrite ? this.typewrite(this.pause.curString, this.pause.curStrPos) : this.backspace(this.pause.curString, this.pause.curStrPos), this.options.onStart(this.arrayPos, this)) }, e.destroy = function () { this.reset(!1), this.options.onDestroy(this) }, e.reset = function (n) { n === void 0 && (n = !0), clearInterval(this.timeout), this.replaceText(""), this.cursor && this.cursor.parentNode && (this.cursor.parentNode.removeChild(this.cursor), this.cursor = null), this.strPos = 0, this.arrayPos = 0, this.curLoop = 0, n && (this.insertCursor(), this.options.onReset(this), this.begin()) }, e.begin = function () { var n = this; this.options.onBegin(this), this.typingComplete = !1, this.shuffleStringsIfNeeded(this), this.insertCursor(), this.bindInputFocusEvents && this.bindFocusEvents(), this.timeout = setTimeout(function () { n.strPos === 0 ? n.typewrite(n.strings[n.sequence[n.arrayPos]], n.strPos) : n.backspace(n.strings[n.sequence[n.arrayPos]], n.strPos) }, this.startDelay) }, e.typewrite = function (n, r) { var i = this; this.fadeOut && this.el.classList.contains(this.fadeOutClass) && (this.el.classList.remove(this.fadeOutClass), this.cursor && this.cursor.classList.remove(this.fadeOutClass)); var s = this.humanizer(this.typeSpeed), a = 1; this.pause.status !== !0 ? this.timeout = setTimeout(function () { r = db.typeHtmlChars(n, r, i); var u = 0, c = n.substring(r); if (c.charAt(0) === "^" && /^\^\d+/.test(c)) { var f = 1; f += (c = /\d+/.exec(c)[0]).length, u = parseInt(c), i.temporaryPause = !0, i.options.onTypingPaused(i.arrayPos, i), n = n.substring(0, r) + n.substring(r + f), i.toggleBlinking(!0) } if (c.charAt(0) === "`") { for (; n.substring(r + a).charAt(0) !== "`" && (a++, !(r + a > n.length));); var h = n.substring(0, r), v = n.substring(h.length + 1, r + a), m = n.substring(r + a + 1); n = h + v + m, a-- } i.timeout = setTimeout(function () { i.toggleBlinking(!1), r >= n.length ? i.doneTyping(n, r) : i.keepTyping(n, r, a), i.temporaryPause && (i.temporaryPause = !1, i.options.onTypingResumed(i.arrayPos, i)) }, u) }, s) : this.setPauseStatus(n, r, !0) }, e.keepTyping = function (n, r, i) { r === 0 && (this.toggleBlinking(!1), this.options.preStringTyped(this.arrayPos, this)); var s = n.substring(0, r += i); this.replaceText(s), this.typewrite(n, r) }, e.doneTyping = function (n, r) { var i = this; this.options.onStringTyped(this.arrayPos, this), this.toggleBlinking(!0), this.arrayPos === this.strings.length - 1 && (this.complete(), this.loop === !1 || this.curLoop === this.loopCount) || (this.timeout = setTimeout(function () { i.backspace(n, r) }, this.backDelay)) }, e.backspace = function (n, r) { var i = this; if (this.pause.status !== !0) { if (this.fadeOut) return this.initFadeOut(); this.toggleBlinking(!1); var s = this.humanizer(this.backSpeed); this.timeout = setTimeout(function () { r = db.backSpaceHtmlChars(n, r, i); var a = n.substring(0, r); if (i.replaceText(a), i.smartBackspace) { var u = i.strings[i.arrayPos + 1]; i.stopNum = u && a === u.substring(0, r) ? r : 0 } r > i.stopNum ? (r--, i.backspace(n, r)) : r <= i.stopNum && (i.arrayPos++, i.arrayPos === i.strings.length ? (i.arrayPos = 0, i.options.onLastStringBackspaced(), i.shuffleStringsIfNeeded(), i.begin()) : i.typewrite(i.strings[i.sequence[i.arrayPos]], r)) }, s) } else this.setPauseStatus(n, r, !1) }, e.complete = function () { this.options.onComplete(this), this.loop ? this.curLoop++ : this.typingComplete = !0 }, e.setPauseStatus = function (n, r, i) { this.pause.typewrite = i, this.pause.curString = n, this.pause.curStrPos = r }, e.toggleBlinking = function (n) { this.cursor && (this.pause.status || this.cursorBlinking !== n && (this.cursorBlinking = n, n ? this.cursor.classList.add("typed-cursor--blink") : this.cursor.classList.remove("typed-cursor--blink"))) }, e.humanizer = function (n) { return Math.round(Math.random() * n / 2) + n }, e.shuffleStringsIfNeeded = function () { this.shuffle && (this.sequence = this.sequence.sort(function () { return Math.random() - .5 })) }, e.initFadeOut = function () { var n = this; return this.el.className += " " + this.fadeOutClass, this.cursor && (this.cursor.className += " " + this.fadeOutClass), setTimeout(function () { n.arrayPos++, n.replaceText(""), n.strings.length > n.arrayPos ? n.typewrite(n.strings[n.sequence[n.arrayPos]], 0) : (n.typewrite(n.strings[0], 0), n.arrayPos = 0) }, this.fadeOutDelay) }, e.replaceText = function (n) { this.attr ? this.el.setAttribute(this.attr, n) : this.isInput ? this.el.value = n : this.contentType === "html" ? this.el.innerHTML = n : this.el.textContent = n }, e.bindFocusEvents = function () { var n = this; this.isInput && (this.el.addEventListener("focus", function (r) { n.stop() }), this.el.addEventListener("blur", function (r) { n.el.value && n.el.value.length !== 0 || n.start() })) }, e.insertCursor = function () { this.showCursor && (this.cursor || (this.cursor = document.createElement("span"), this.cursor.className = "typed-cursor", this.cursor.setAttribute("aria-hidden", !0), this.cursor.innerHTML = this.cursorChar, this.el.parentNode && this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling))) }, t }(); const t4 = j.memo(({ style: t, className: e, typedRef: n, parseRef: r, stopped: i, children: s, startWhenVisible: a, ...u }) => { const c = j.useRef(null), f = j.useMemo(() => { var v; return [...Object.values(u).filter(m => typeof m == "boolean" || typeof m == "number" || typeof m == "string"), (v = u.strings) == null ? void 0 : v.join(",")] }, [u]); j.useEffect(() => { const v = r && r(c) || c.current, m = new e4(v, { ...u }); if ((i || a) && (m == null || m.stop()), a) { const g = new IntersectionObserver(([S]) => { S.isIntersecting && (m == null || m.start(), g.disconnect()) }); g.observe(v) } return n && m && n(m), () => { m.destroy() } }, f); const h = s ? Jh.cloneElement(s, { ref: c }) : Jh.createElement("span", { style: t, ref: c }); return Jh.createElement("span", { style: t, className: e, "data-testid": "react-typed" }, h) }); function n4() { return De.jsxs(U0, { size: "9", weight: "light", className: "ml-3 text-[#B4B4B4] mt-10", children: ["wellcome to ", De.jsx(U0, { size: "8", className: " ml-8  text-[#EEEEEE]", children: De.jsx(t4, { strings: ["TransformIt", "Speed", "PDF merger", "Image compressor", "image to PDF", "Pdf Compressor", "TransformIt"], typeSpeed: 180, backSpeed: 100 }) })] }) } function r4(t) { if (typeof Proxy > "u") return t; const e = new Map, n = (...r) => t(...r); return new Proxy(n, { get: (r, i) => i === "create" ? t : (e.has(i) || e.set(i, t(i)), e.get(i)) }) } const i4 = r4(F2); function o4(t) { const e = Am(() => ei(t)), { isStatic: n } = j.useContext(od); if (n) { const [, r] = j.useState(t); j.useEffect(() => e.on("change", r), []) } return e } function hb(t) { return typeof t == "number" ? t : parseFloat(t) } function s4(t, e = {}) { const { isStatic: n } = j.useContext(od), r = j.useRef(null), i = o4(pn(t) ? hb(t.get()) : t), s = j.useRef(i.get()), a = j.useRef(() => { }), u = () => { const f = r.current; f && f.time === 0 && f.sample(on.delta), c(), r.current = C8({ keyframes: [i.get(), s.current], velocity: i.getVelocity(), type: "spring", restDelta: .001, restSpeed: .01, ...e, onUpdate: a.current }) }, c = () => { r.current && r.current.stop() }; return j.useInsertionEffect(() => i.attach((f, h) => n ? h(f) : (s.current = f, a.current = h, bt.update(u), i.get()), c), [JSON.stringify(e)]), Pm(() => { if (pn(t)) return t.on("change", f => i.set(hb(f))) }, [i]), i } const $c = new WeakMap; let oo; function a4(t, e) { if (e) { const { inlineSize: n, blockSize: r } = e[0]; return { width: n, height: r } } else return t instanceof SVGElement && "getBBox" in t ? t.getBBox() : { width: t.offsetWidth, height: t.offsetHeight } } function l4({ target: t, contentRect: e, borderBoxSize: n }) { var r; (r = $c.get(t)) === null || r === void 0 || r.forEach(i => { i({ target: t, contentSize: e, get size() { return a4(t, n) } }) }) } function u4(t) { t.forEach(l4) } function c4() { typeof ResizeObserver > "u" || (oo = new ResizeObserver(u4)) } function f4(t, e) { oo || c4(); const n = f2(t); return n.forEach(r => { let i = $c.get(r); i || (i = new Set, $c.set(r, i)), i.add(e), oo == null || oo.observe(r) }), () => { n.forEach(r => { const i = $c.get(r); i == null || i.delete(e), i != null && i.size || oo == null || oo.unobserve(r) }) } } const ef = new Set; let Ml; function d4() { Ml = () => { const t = { width: window.innerWidth, height: window.innerHeight }, e = { target: window, size: t, contentSize: t }; ef.forEach(n => n(e)) }, window.addEventListener("resize", Ml) } function h4(t) { return ef.add(t), Ml || d4(), () => { ef.delete(t), !ef.size && Ml && (Ml = void 0) } } function p4(t, e) { return typeof t == "function" ? h4(t) : f4(t, e) } const v4 = 50, pb = () => ({ current: 0, offset: [], progress: 0, scrollLength: 0, targetOffset: 0, targetLength: 0, containerLength: 0, velocity: 0 }), m4 = () => ({ time: 0, x: pb(), y: pb() }), g4 = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } }; function vb(t, e, n, r) { const i = n[e], { length: s, position: a } = g4[e], u = i.current, c = n.time; i.current = t[`scroll${a}`], i.scrollLength = t[`scroll${s}`] - t[`client${s}`], i.offset.length = 0, i.offset[0] = 0, i.offset[1] = i.scrollLength, i.progress = $o(0, i.scrollLength, i.current); const f = r - c; i.velocity = f > v4 ? 0 : fm(i.current - u, f) } function y4(t, e, n) { vb(t, "x", e, n), vb(t, "y", e, n), e.time = n } function x4(t, e) { const n = { x: 0, y: 0 }; let r = t; for (; r && r !== e;)if (r instanceof HTMLElement) n.x += r.offsetLeft, n.y += r.offsetTop, r = r.offsetParent; else if (r.tagName === "svg") { const i = r.getBoundingClientRect(); r = r.parentElement; const s = r.getBoundingClientRect(); n.x += i.left - s.left, n.y += i.top - s.top } else if (r instanceof SVGGraphicsElement) { const { x: i, y: s } = r.getBBox(); n.x += i, n.y += s; let a = null, u = r.parentNode; for (; !a;)u.tagName === "svg" && (a = u), u = r.parentNode; r = a } else break; return n } const w4 = { Enter: [[0, 1], [1, 1]], Exit: [[0, 0], [1, 0]], Any: [[1, 0], [0, 1]], All: [[0, 0], [1, 1]] }, Z0 = { start: 0, center: .5, end: 1 }; function mb(t, e, n = 0) { let r = 0; if (t in Z0 && (t = Z0[t]), typeof t == "string") { const i = parseFloat(t); t.endsWith("px") ? r = i : t.endsWith("%") ? t = i / 100 : t.endsWith("vw") ? r = i / 100 * document.documentElement.clientWidth : t.endsWith("vh") ? r = i / 100 * document.documentElement.clientHeight : t = i } return typeof t == "number" && (r = e * t), n + r } const S4 = [0, 0]; function b4(t, e, n, r) { let i = Array.isArray(t) ? t : S4, s = 0, a = 0; return typeof t == "number" ? i = [t, t] : typeof t == "string" && (t = t.trim(), t.includes(" ") ? i = t.split(" ") : i = [t, Z0[t] ? t : "0"]), s = mb(i[0], n, r), a = mb(i[1], e), s - a } const C4 = { x: 0, y: 0 }; function P4(t) { return "getBBox" in t && t.tagName !== "svg" ? t.getBBox() : { width: t.clientWidth, height: t.clientHeight } } function T4(t, e, n) { const { offset: r = w4.All } = n, { target: i = t, axis: s = "y" } = n, a = s === "y" ? "height" : "width", u = i !== t ? x4(i, t) : C4, c = i === t ? { width: t.scrollWidth, height: t.scrollHeight } : P4(i), f = { width: t.clientWidth, height: t.clientHeight }; e[s].offset.length = 0; let h = !e[s].interpolate; const v = r.length; for (let m = 0; m < v; m++) { const g = b4(r[m], f[a], c[a], u[s]); !h && g !== e[s].interpolatorOffsets[m] && (h = !0), e[s].offset[m] = g } h && (e[s].interpolate = VT(e[s].offset, NT(r)), e[s].interpolatorOffsets = [...e[s].offset]), e[s].progress = e[s].interpolate(e[s].current) } function k4(t, e = t, n) { if (n.x.targetOffset = 0, n.y.targetOffset = 0, e !== t) { let r = e; for (; r && r !== t;)n.x.targetOffset += r.offsetLeft, n.y.targetOffset += r.offsetTop, r = r.offsetParent } n.x.targetLength = e === t ? e.scrollWidth : e.clientWidth, n.y.targetLength = e === t ? e.scrollHeight : e.clientHeight, n.x.containerLength = t.clientWidth, n.y.containerLength = t.clientHeight } function A4(t, e, n, r = {}) { return { measure: () => k4(t, r.target, n), update: i => { y4(t, n, i), (r.offset || r.target) && T4(t, n, r) }, notify: () => e(n) } } const sl = new WeakMap, gb = new WeakMap, qp = new WeakMap, yb = t => t === document.documentElement ? window : t; function Km(t, { container: e = document.documentElement, ...n } = {}) { let r = qp.get(e); r || (r = new Set, qp.set(e, r)); const i = m4(), s = A4(e, t, i, n); if (r.add(s), !sl.has(e)) { const u = () => { for (const m of r) m.measure() }, c = () => { for (const m of r) m.update(on.timestamp) }, f = () => { for (const m of r) m.notify() }, h = () => { bt.read(u, !1, !0), bt.read(c, !1, !0), bt.update(f, !1, !0) }; sl.set(e, h); const v = yb(e); window.addEventListener("resize", h, { passive: !0 }), e !== document.documentElement && gb.set(e, p4(e, h)), v.addEventListener("scroll", h, { passive: !0 }) } const a = sl.get(e); return bt.read(a, !1, !0), () => { var u; ai(a); const c = qp.get(e); if (!c || (c.delete(s), c.size)) return; const f = sl.get(e); sl.delete(e), f && (yb(e).removeEventListener("scroll", f), (u = gb.get(e)) === null || u === void 0 || u(), window.removeEventListener("resize", f)) } } function gk(t, e) { let n; const r = () => { const { currentTime: i } = e, a = (i === null ? 0 : i.value) / 100; n !== a && t(a), n = a }; return bt.update(r, !0), () => ai(r) } function E4({ source: t, container: e, axis: n = "y" }) { t && (e = t); const r = { value: 0 }, i = Km(s => { r.value = s[n].progress * 100 }, { container: e, axis: n }); return { currentTime: r, cancel: i } } const Gp = new Map; function yk({ source: t, container: e = document.documentElement, axis: n = "y" } = {}) { t && (e = t), Gp.has(e) || Gp.set(e, {}); const r = Gp.get(e); return r[n] || (r[n] = IT() ? new ScrollTimeline({ source: e, axis: n }) : E4({ source: e, axis: n })), r[n] } function F4(t) { return t.length === 2 } function xk(t) { return t && (t.target || t.offset) } function R4(t, e) { return F4(t) || xk(e) ? Km(n => { t(n[e.axis].progress, n) }, e) : gk(t, yk(e)) } function D4(t, e) { if (t.flatten(), xk(e)) return t.pause(), Km(n => { t.time = t.duration * n[e.axis].progress }, e); { const n = yk(e); return t.attachTimeline ? t.attachTimeline(n, r => (r.pause(), gk(i => { r.time = r.duration * i }, n))) : Ln } } function O4(t, { axis: e = "y", ...n } = {}) { const r = { axis: e, ...n }; return typeof t == "function" ? R4(t, r) : D4(t, r) } function xb(t, e) { uV(!!(!e || e.current)) } const M4 = () => ({ scrollX: ei(0), scrollY: ei(0), scrollXProgress: ei(0), scrollYProgress: ei(0) }); function V4({ container: t, target: e, layoutEffect: n = !0, ...r } = {}) { const i = Am(M4); return (n ? Pm : j.useEffect)(() => (xb("target", e), xb("container", t), O4((a, { x: u, y: c }) => { i.scrollX.set(u.current), i.scrollXProgress.set(u.progress), i.scrollY.set(c.current), i.scrollYProgress.set(c.progress) }, { ...r, container: (t == null ? void 0 : t.current) || void 0, target: (e == null ? void 0 : e.current) || void 0 })), [t, e, JSON.stringify(r.offset)]), i } function N4() { return De.jsxs("div", { className: "w-screen min-h-screen p-3 flex flex-col items-center justify-center bg-gradient-to-br from-[#311020] via-[#1a0a15] to-black relative overflow-hidden", children: [De.jsx("div", { className: "absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,rgba(255,255,255,0.08)_0%,transparent_70%)] pointer-events-none" }), De.jsx("div", { className: "absolute inset-0 opacity-20 animate-grain bg-[url('/grain.png')] pointer-events-none" }), De.jsx("div", { className: "absolute inset-0 opacity-15 bg-[repeating-linear-gradient(45deg,#6F5F58_0px,#6F5F58_1px,transparent_1px,transparent_12px)] pointer-events-none" }), De.jsx("div", { className: "absolute inset-0 opacity-10 bg-[radial-gradient(circle_at_center,#6F5F58_1px,transparent_1px)] bg-[size:20px_20px] pointer-events-none" }), De.jsx(B4, {}), De.jsx(n4, {}), De.jsx(zO, {}), De.jsx(TL, {})] }) } function B4() { const { scrollYProgress: t } = V4(), e = s4(t, { stiffness: 90, damping: 30, restDelta: .001 }); return De.jsx(De.Fragment, { children: De.jsx(i4.div, { id: "scroll-indicator", style: { scaleX: e, position: "fixed", top: 0, left: 0, right: 0, height: 3, originX: 0, backgroundColor: "#6F5F58", zIndex: 9999 } }) }) } mE.createRoot(document.getElementById("root")).render(De.jsx(j.StrictMode, { children: De.jsx(vk, { children: De.jsx(N4, {}) }) }));
